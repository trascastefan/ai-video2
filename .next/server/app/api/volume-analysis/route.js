"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/volume-analysis/route";
exports.ids = ["app/api/volume-analysis/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvolume-analysis%2Froute&page=%2Fapi%2Fvolume-analysis%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvolume-analysis%2Froute.ts&appDir=%2FUsers%2Fstefantrasca%2FCascadeProjects%2Fai-video%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fstefantrasca%2FCascadeProjects%2Fai-video&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvolume-analysis%2Froute&page=%2Fapi%2Fvolume-analysis%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvolume-analysis%2Froute.ts&appDir=%2FUsers%2Fstefantrasca%2FCascadeProjects%2Fai-video%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fstefantrasca%2FCascadeProjects%2Fai-video&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   headerHooks: () => (/* binding */ headerHooks),\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage),\n/* harmony export */   staticGenerationBailout: () => (/* binding */ staticGenerationBailout)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_stefantrasca_CascadeProjects_ai_video_app_api_volume_analysis_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/volume-analysis/route.ts */ \"(rsc)/./app/api/volume-analysis/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/volume-analysis/route\",\n        pathname: \"/api/volume-analysis\",\n        filename: \"route\",\n        bundlePath: \"app/api/volume-analysis/route\"\n    },\n    resolvedPagePath: \"/Users/stefantrasca/CascadeProjects/ai-video/app/api/volume-analysis/route.ts\",\n    nextConfigOutput,\n    userland: _Users_stefantrasca_CascadeProjects_ai_video_app_api_volume_analysis_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks, headerHooks, staticGenerationBailout } = routeModule;\nconst originalPathname = \"/api/volume-analysis/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZ2b2x1bWUtYW5hbHlzaXMlMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRnZvbHVtZS1hbmFseXNpcyUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRnZvbHVtZS1hbmFseXNpcyUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRnN0ZWZhbnRyYXNjYSUyRkNhc2NhZGVQcm9qZWN0cyUyRmFpLXZpZGVvJTJGYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj0lMkZVc2VycyUyRnN0ZWZhbnRyYXNjYSUyRkNhc2NhZGVQcm9qZWN0cyUyRmFpLXZpZGVvJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQzZCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUdBQXVHO0FBQy9HO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDNko7O0FBRTdKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktc3RvY2stdmlkZW8vP2M4MzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzL3N0ZWZhbnRyYXNjYS9DYXNjYWRlUHJvamVjdHMvYWktdmlkZW8vYXBwL2FwaS92b2x1bWUtYW5hbHlzaXMvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL3ZvbHVtZS1hbmFseXNpcy9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3ZvbHVtZS1hbmFseXNpc1wiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvdm9sdW1lLWFuYWx5c2lzL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL1VzZXJzL3N0ZWZhbnRyYXNjYS9DYXNjYWRlUHJvamVjdHMvYWktdmlkZW8vYXBwL2FwaS92b2x1bWUtYW5hbHlzaXMvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgaGVhZGVySG9va3MsIHN0YXRpY0dlbmVyYXRpb25CYWlsb3V0IH0gPSByb3V0ZU1vZHVsZTtcbmNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBcIi9hcGkvdm9sdW1lLWFuYWx5c2lzL3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIGhlYWRlckhvb2tzLCBzdGF0aWNHZW5lcmF0aW9uQmFpbG91dCwgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvolume-analysis%2Froute&page=%2Fapi%2Fvolume-analysis%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvolume-analysis%2Froute.ts&appDir=%2FUsers%2Fstefantrasca%2FCascadeProjects%2Fai-video%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fstefantrasca%2FCascadeProjects%2Fai-video&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/volume-analysis/route.ts":
/*!******************************************!*\
  !*** ./app/api/volume-analysis/route.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/web/exports/next-response */ \"(rsc)/./node_modules/next/dist/server/web/exports/next-response.js\");\n/* harmony import */ var _utils_finnhub__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/finnhub */ \"(rsc)/./app/utils/finnhub.ts\");\n/* harmony import */ var _utils_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/cache */ \"(rsc)/./app/utils/cache.ts\");\n/* harmony import */ var _utils_stock_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/stock-api */ \"(rsc)/./app/utils/stock-api.ts\");\n\n\n\n\n// Helper function to extract the base symbol without exchange prefix\nfunction getBaseSymbol(symbol) {\n    return symbol.replace(/\\..+$/, \"\").toUpperCase();\n}\n// Mock volume analysis for fallback\nfunction mockVolumeAnalysis(symbol, timeframe) {\n    return {\n        symbol: symbol,\n        companyName: symbol,\n        timeSeriesData: Array(30).fill(0).map((_, i)=>({\n                date: new Date(Date.now() - i * 86400000).toISOString().split(\"T\")[0],\n                open: 100 + Math.random() * 10,\n                high: 105 + Math.random() * 10,\n                low: 95 + Math.random() * 10,\n                close: 100 + Math.random() * 10,\n                volume: 1000000 + Math.random() * 2000000,\n                percentageChange: Math.random() * 4 - 2,\n                direction: Math.random() > 0.5 ? \"up\" : \"down\"\n            })),\n        significantMoves: [],\n        isMockData: true\n    };\n}\nasync function GET(request) {\n    const { searchParams } = new URL(request.url);\n    const symbol = searchParams.get(\"symbol\")?.toUpperCase();\n    // Convert timeframe to the format expected by the stock API\n    const timeframeParam = searchParams.get(\"timeframe\") || \"3m\";\n    const timeframe = (()=>{\n        switch(timeframeParam){\n            case \"1w\":\n                return \"1w\";\n            case \"1m\":\n                return \"1mo\";\n            case \"3m\":\n                return \"3mo\";\n            case \"6m\":\n                return \"6mo\";\n            case \"1y\":\n                return \"1y\";\n            default:\n                return \"3mo\";\n        }\n    })();\n    const forceRefresh = searchParams.get(\"force\") === \"true\";\n    const useMock = searchParams.get(\"mock\") === \"true\"; // Parameter to explicitly request mock data\n    const disallowMock = searchParams.get(\"mock\") === \"false\"; // New parameter to disallow mock data\n    if (!symbol) {\n        return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n            error: \"Symbol is required\"\n        }, {\n            status: 400\n        });\n    }\n    console.log(`Processing volume analysis request for ${symbol} with timeframe ${timeframe}${forceRefresh ? \" (forced refresh)\" : \"\"}${useMock ? \" (using mock data)\" : \"\"}${disallowMock ? \" (disallowing mock data)\" : \"\"}`);\n    // Get the base symbol without any exchange prefix\n    const baseSymbol = getBaseSymbol(symbol);\n    try {\n        // If mock data is explicitly requested, return it immediately\n        if (useMock) {\n            console.log(`Using mock data for ${symbol} volume analysis as explicitly requested`);\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json(mockVolumeAnalysis(symbol, timeframe));\n        }\n        // Skip cache check if a forced refresh is requested\n        if (!forceRefresh) {\n            // Check for cached data\n            const cachedData = _utils_cache__WEBPACK_IMPORTED_MODULE_2__.companyDataCache.get(baseSymbol);\n            if (cachedData?.timeSeriesData?.length) {\n                const cacheAge = Date.now() - (cachedData.lastUpdated || 0);\n                const maxAge = 3600000; // 1 hour\n                if (cacheAge < maxAge) {\n                    console.log(`Using cached volume analysis for ${symbol} (age: ${Math.round(cacheAge / 1000 / 60)} minutes)`);\n                    return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                        symbol: baseSymbol,\n                        companyName: cachedData.name || baseSymbol,\n                        timeSeriesData: cachedData.timeSeriesData,\n                        significantMoves: cachedData.significantMoves || []\n                    });\n                } else {\n                    console.log(`Cached volume analysis for ${symbol} is stale (${Math.round(cacheAge / 1000 / 60)} minutes old)`);\n                }\n            }\n        } else {\n            console.log(`Forced refresh requested for ${symbol}, bypassing cache entirely`);\n        }\n        // Fetch new data\n        const stockData = await (0,_utils_stock_api__WEBPACK_IMPORTED_MODULE_3__.getStockData)(symbol, timeframe);\n        if (!stockData.timeSeriesData || stockData.timeSeriesData.length === 0) {\n            throw new Error(\"No time series data available\");\n        }\n        // Process the data to find significant price moves\n        const timeSeriesData = stockData.timeSeriesData;\n        const significantMoves = [];\n        // Find days with significant price and volume movement\n        for(let i = 0; i < timeSeriesData.length; i++){\n            const day = timeSeriesData[i];\n            // Significant move criteria: >2% price change AND volume > 1.5x 30-day average\n            if (Math.abs(day.percentageChange) > 2) {\n                // Calculate average volume for previous 30 days\n                let volumeSum = 0;\n                let count = 0;\n                for(let j = i + 1; j < Math.min(i + 31, timeSeriesData.length); j++){\n                    volumeSum += timeSeriesData[j].volume;\n                    count++;\n                }\n                const avgVolume = count > 0 ? volumeSum / count : day.volume;\n                // Check if volume is significantly higher than average\n                if (day.volume > avgVolume * 1.5) {\n                    // This is a significant move - get the previous close for reference\n                    const previousClose = i < timeSeriesData.length - 1 ? timeSeriesData[i + 1].close : day.open;\n                    // Format the date for news lookup\n                    const moveDate = new Date(day.date);\n                    const formattedDate = (0,_utils_finnhub__WEBPACK_IMPORTED_MODULE_1__.formatDateYYYYMMDD)(moveDate);\n                    // Get news around this date\n                    const newsItems = await (0,_utils_stock_api__WEBPACK_IMPORTED_MODULE_3__.getCompanyNewsWithFallback)(symbol, 3);\n                    // Filter news items around the move date (3 days before and after)\n                    const relevantNews = newsItems.filter((item)=>{\n                        const newsDate = new Date(item.date);\n                        const daysDiff = Math.abs((newsDate.getTime() - moveDate.getTime()) / (1000 * 60 * 60 * 24));\n                        return daysDiff <= 3;\n                    });\n                    // Add to significant moves\n                    significantMoves.push({\n                        date: day.date,\n                        volume: day.volume,\n                        price: day.close,\n                        priceChange: day.close - previousClose,\n                        percentageChange: day.percentageChange,\n                        previousClose: previousClose,\n                        high: day.high,\n                        low: day.low,\n                        news: relevantNews\n                    });\n                }\n            }\n        }\n        // Get company profile for additional info\n        const companyProfile = await (0,_utils_stock_api__WEBPACK_IMPORTED_MODULE_3__.getCompanyProfileWithFallback)(symbol);\n        // Construct the response\n        const response = {\n            symbol: baseSymbol,\n            companyName: companyProfile.name || baseSymbol,\n            timeSeriesData: timeSeriesData.map((day)=>({\n                    date: day.date,\n                    open: day.open,\n                    high: day.high,\n                    low: day.low,\n                    close: day.close,\n                    volume: day.volume,\n                    percentageChange: day.percentageChange,\n                    direction: day.percentageChange >= 0 ? \"up\" : \"down\"\n                })),\n            significantMoves: significantMoves,\n            refreshedAt: new Date().toISOString()\n        };\n        // Cache the results if this isn't a forced refresh\n        if (!forceRefresh) {\n            _utils_cache__WEBPACK_IMPORTED_MODULE_2__.companyDataCache.set(baseSymbol, {\n                name: baseSymbol,\n                symbol: baseSymbol,\n                timeSeriesData: timeSeriesData,\n                significantMoves: significantMoves,\n                lastUpdated: Date.now()\n            });\n        }\n        return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json(response);\n    } catch (error) {\n        console.error(`Error in volume analysis API route for ${symbol}:`, error);\n        // For forced refresh, we don't want to return either cached or mock data\n        if (forceRefresh) {\n            console.log(`Refresh failed for ${symbol}, returning error instead of fallback`);\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                error: `Failed to refresh data: ${error instanceof Error ? error.message : \"Unknown error\"}`\n            }, {\n                status: 503\n            });\n        }\n        // Try cache as fallback if not forcing refresh\n        const cachedData = _utils_cache__WEBPACK_IMPORTED_MODULE_2__.companyDataCache.get(baseSymbol);\n        if (cachedData?.timeSeriesData?.length) {\n            console.log(`Using cached volume analysis for ${symbol} as fallback after error`);\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                symbol: baseSymbol,\n                companyName: cachedData.name || baseSymbol,\n                timeSeriesData: cachedData.timeSeriesData,\n                significantMoves: cachedData.significantMoves || [],\n                fromCache: true,\n                cacheTimestamp: cachedData.lastUpdated\n            });\n        }\n        // Use mock data as last resort, but only if not explicitly disallowed\n        if (!disallowMock) {\n            console.log(`Using mock data for ${symbol} volume analysis as last resort`);\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json(mockVolumeAnalysis(symbol, timeframe));\n        }\n        // If we get here, we couldn't provide any data\n        return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n            error: `Failed to fetch volume analysis data: ${error instanceof Error ? error.message : \"Unknown error\"}`\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL3ZvbHVtZS1hbmFseXNpcy9yb3V0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyQztBQUNpQztBQUNSO0FBQ3VFO0FBNEIzSSxxRUFBcUU7QUFDckUsU0FBU00sY0FBY0MsTUFBYztJQUNuQyxPQUFPQSxPQUFPQyxPQUFPLENBQUMsU0FBUyxJQUFJQyxXQUFXO0FBQ2hEO0FBRUEsb0NBQW9DO0FBQ3BDLFNBQVNDLG1CQUFtQkgsTUFBYyxFQUFFSSxTQUFpQjtJQUMzRCxPQUFPO1FBQ0xKLFFBQVFBO1FBQ1JLLGFBQWFMO1FBQ2JNLGdCQUFnQkMsTUFBTSxJQUFJQyxJQUFJLENBQUMsR0FBR0MsR0FBRyxDQUFDLENBQUNDLEdBQUdDLElBQU87Z0JBQy9DQyxNQUFNLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsS0FBS0gsSUFBSSxVQUFVSSxXQUFXLEdBQUdDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDckVDLE1BQU0sTUFBTUMsS0FBS0MsTUFBTSxLQUFLO2dCQUM1QkMsTUFBTSxNQUFNRixLQUFLQyxNQUFNLEtBQUs7Z0JBQzVCRSxLQUFLLEtBQUtILEtBQUtDLE1BQU0sS0FBSztnQkFDMUJHLE9BQU8sTUFBTUosS0FBS0MsTUFBTSxLQUFLO2dCQUM3QkksUUFBUSxVQUFVTCxLQUFLQyxNQUFNLEtBQUs7Z0JBQ2xDSyxrQkFBa0IsS0FBTUwsTUFBTSxLQUFLLElBQUs7Z0JBQ3hDTSxXQUFXUCxLQUFLQyxNQUFNLEtBQUssTUFBTSxPQUFPO1lBQzFDO1FBQ0FPLGtCQUFrQixFQUFFO1FBQ3BCQyxZQUFZO0lBQ2Q7QUFDRjtBQUVPLGVBQWVDLElBQUlDLE9BQWdCO0lBQ3hDLE1BQU0sRUFBRUMsWUFBWSxFQUFFLEdBQUcsSUFBSUMsSUFBSUYsUUFBUUcsR0FBRztJQUM1QyxNQUFNaEMsU0FBUzhCLGFBQWFHLEdBQUcsQ0FBQyxXQUFXL0I7SUFDM0MsNERBQTREO0lBQzVELE1BQU1nQyxpQkFBaUJKLGFBQWFHLEdBQUcsQ0FBQyxnQkFBZ0I7SUFDeEQsTUFBTTdCLFlBQVksQ0FBQztRQUNqQixPQUFROEI7WUFDTixLQUFLO2dCQUFNLE9BQU87WUFDbEIsS0FBSztnQkFBTSxPQUFPO1lBQ2xCLEtBQUs7Z0JBQU0sT0FBTztZQUNsQixLQUFLO2dCQUFNLE9BQU87WUFDbEIsS0FBSztnQkFBTSxPQUFPO1lBQ2xCO2dCQUFTLE9BQU87UUFDbEI7SUFDRjtJQUNBLE1BQU1DLGVBQWVMLGFBQWFHLEdBQUcsQ0FBQyxhQUFhO0lBQ25ELE1BQU1HLFVBQVVOLGFBQWFHLEdBQUcsQ0FBQyxZQUFZLFFBQVEsNENBQTRDO0lBQ2pHLE1BQU1JLGVBQWVQLGFBQWFHLEdBQUcsQ0FBQyxZQUFZLFNBQVMsc0NBQXNDO0lBRWpHLElBQUksQ0FBQ2pDLFFBQVE7UUFDWCxPQUFPUCxrRkFBWUEsQ0FBQzZDLElBQUksQ0FBQztZQUFFQyxPQUFPO1FBQXFCLEdBQUc7WUFBRUMsUUFBUTtRQUFJO0lBQzFFO0lBRUFDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHVDQUF1QyxFQUFFMUMsT0FBTyxnQkFBZ0IsRUFBRUksVUFBVSxFQUFFK0IsZUFBZSxzQkFBc0IsR0FBRyxFQUFFQyxVQUFVLHVCQUF1QixHQUFHLEVBQUVDLGVBQWUsNkJBQTZCLEdBQUcsQ0FBQztJQUUzTixrREFBa0Q7SUFDbEQsTUFBTU0sYUFBYTVDLGNBQWNDO0lBRWpDLElBQUk7UUFDRiw4REFBOEQ7UUFDOUQsSUFBSW9DLFNBQVM7WUFDWEssUUFBUUMsR0FBRyxDQUFDLENBQUMsb0JBQW9CLEVBQUUxQyxPQUFPLHdDQUF3QyxDQUFDO1lBQ25GLE9BQU9QLGtGQUFZQSxDQUFDNkMsSUFBSSxDQUFDbkMsbUJBQW1CSCxRQUFRSTtRQUN0RDtRQUVBLG9EQUFvRDtRQUNwRCxJQUFJLENBQUMrQixjQUFjO1lBQ2pCLHdCQUF3QjtZQUN4QixNQUFNUyxhQUFhakQsMERBQWdCQSxDQUFDc0MsR0FBRyxDQUFDVTtZQUV4QyxJQUFJQyxZQUFZdEMsZ0JBQWdCdUMsUUFBUTtnQkFDdEMsTUFBTUMsV0FBV2pDLEtBQUtDLEdBQUcsS0FBTThCLENBQUFBLFdBQVdHLFdBQVcsSUFBSTtnQkFDekQsTUFBTUMsU0FBUyxTQUFTLFNBQVM7Z0JBRWpDLElBQUlGLFdBQVdFLFFBQVE7b0JBQ3JCUCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxpQ0FBaUMsRUFBRTFDLE9BQU8sT0FBTyxFQUFFa0IsS0FBSytCLEtBQUssQ0FBQ0gsV0FBUyxPQUFLLElBQUksU0FBUyxDQUFDO29CQUN2RyxPQUFPckQsa0ZBQVlBLENBQUM2QyxJQUFJLENBQUM7d0JBQ3ZCdEMsUUFBUTJDO3dCQUNSdEMsYUFBYXVDLFdBQVdNLElBQUksSUFBSVA7d0JBQ2hDckMsZ0JBQWdCc0MsV0FBV3RDLGNBQWM7d0JBQ3pDb0Isa0JBQWtCa0IsV0FBV2xCLGdCQUFnQixJQUFJLEVBQUU7b0JBQ3JEO2dCQUNGLE9BQU87b0JBQ0xlLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDJCQUEyQixFQUFFMUMsT0FBTyxXQUFXLEVBQUVrQixLQUFLK0IsS0FBSyxDQUFDSCxXQUFTLE9BQUssSUFBSSxhQUFhLENBQUM7Z0JBQzNHO1lBQ0Y7UUFDRixPQUFPO1lBQ0xMLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDZCQUE2QixFQUFFMUMsT0FBTywwQkFBMEIsQ0FBQztRQUNoRjtRQUVBLGlCQUFpQjtRQUNqQixNQUFNbUQsWUFBWSxNQUFNdkQsOERBQVlBLENBQUNJLFFBQVFJO1FBRTdDLElBQUksQ0FBQytDLFVBQVU3QyxjQUFjLElBQUk2QyxVQUFVN0MsY0FBYyxDQUFDdUMsTUFBTSxLQUFLLEdBQUc7WUFDdEUsTUFBTSxJQUFJTyxNQUFNO1FBQ2xCO1FBRUEsbURBQW1EO1FBQ25ELE1BQU05QyxpQkFBaUI2QyxVQUFVN0MsY0FBYztRQUMvQyxNQUFNb0IsbUJBQW1CLEVBQUU7UUFFM0IsdURBQXVEO1FBQ3ZELElBQUssSUFBSWYsSUFBSSxHQUFHQSxJQUFJTCxlQUFldUMsTUFBTSxFQUFFbEMsSUFBSztZQUM5QyxNQUFNMEMsTUFBTS9DLGNBQWMsQ0FBQ0ssRUFBRTtZQUU3QiwrRUFBK0U7WUFDL0UsSUFBSU8sS0FBS29DLEdBQUcsQ0FBQ0QsSUFBSTdCLGdCQUFnQixJQUFJLEdBQUc7Z0JBQ3RDLGdEQUFnRDtnQkFDaEQsSUFBSStCLFlBQVk7Z0JBQ2hCLElBQUlDLFFBQVE7Z0JBRVosSUFBSyxJQUFJQyxJQUFJOUMsSUFBSSxHQUFHOEMsSUFBSXZDLEtBQUt3QyxHQUFHLENBQUMvQyxJQUFJLElBQUlMLGVBQWV1QyxNQUFNLEdBQUdZLElBQUs7b0JBQ3BFRixhQUFhakQsY0FBYyxDQUFDbUQsRUFBRSxDQUFDbEMsTUFBTTtvQkFDckNpQztnQkFDRjtnQkFFQSxNQUFNRyxZQUFZSCxRQUFRLElBQUlELFlBQVlDLFFBQVFILElBQUk5QixNQUFNO2dCQUU1RCx1REFBdUQ7Z0JBQ3ZELElBQUk4QixJQUFJOUIsTUFBTSxHQUFHb0MsWUFBWSxLQUFLO29CQUNoQyxvRUFBb0U7b0JBQ3BFLE1BQU1DLGdCQUFnQmpELElBQUlMLGVBQWV1QyxNQUFNLEdBQUcsSUFBSXZDLGNBQWMsQ0FBQ0ssSUFBSSxFQUFFLENBQUNXLEtBQUssR0FBRytCLElBQUlwQyxJQUFJO29CQUU1RixrQ0FBa0M7b0JBQ2xDLE1BQU00QyxXQUFXLElBQUloRCxLQUFLd0MsSUFBSXpDLElBQUk7b0JBQ2xDLE1BQU1rRCxnQkFBZ0JwRSxrRUFBa0JBLENBQUNtRTtvQkFFekMsNEJBQTRCO29CQUM1QixNQUFNRSxZQUFZLE1BQU1sRSw0RUFBMEJBLENBQUNHLFFBQVE7b0JBRTNELG1FQUFtRTtvQkFDbkUsTUFBTWdFLGVBQWVELFVBQVVFLE1BQU0sQ0FBQ0MsQ0FBQUE7d0JBQ3BDLE1BQU1DLFdBQVcsSUFBSXRELEtBQUtxRCxLQUFLdEQsSUFBSTt3QkFDbkMsTUFBTXdELFdBQVdsRCxLQUFLb0MsR0FBRyxDQUFDLENBQUNhLFNBQVNFLE9BQU8sS0FBS1IsU0FBU1EsT0FBTyxFQUFDLElBQU0sUUFBTyxLQUFLLEtBQUssRUFBQzt3QkFDekYsT0FBT0QsWUFBWTtvQkFDckI7b0JBRUEsMkJBQTJCO29CQUMzQjFDLGlCQUFpQjRDLElBQUksQ0FBQzt3QkFDcEIxRCxNQUFNeUMsSUFBSXpDLElBQUk7d0JBQ2RXLFFBQVE4QixJQUFJOUIsTUFBTTt3QkFDbEJnRCxPQUFPbEIsSUFBSS9CLEtBQUs7d0JBQ2hCa0QsYUFBYW5CLElBQUkvQixLQUFLLEdBQUdzQzt3QkFDekJwQyxrQkFBa0I2QixJQUFJN0IsZ0JBQWdCO3dCQUN0Q29DLGVBQWVBO3dCQUNmeEMsTUFBTWlDLElBQUlqQyxJQUFJO3dCQUNkQyxLQUFLZ0MsSUFBSWhDLEdBQUc7d0JBQ1pvRCxNQUFNVDtvQkFDUjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSwwQ0FBMEM7UUFDMUMsTUFBTVUsaUJBQWlCLE1BQU01RSwrRUFBNkJBLENBQUNFO1FBRTNELHlCQUF5QjtRQUN6QixNQUFNMkUsV0FBVztZQUNmM0UsUUFBUTJDO1lBQ1J0QyxhQUFhcUUsZUFBZXhCLElBQUksSUFBSVA7WUFDcENyQyxnQkFBZ0JBLGVBQWVHLEdBQUcsQ0FBQzRDLENBQUFBLE1BQVE7b0JBQ3pDekMsTUFBTXlDLElBQUl6QyxJQUFJO29CQUNkSyxNQUFNb0MsSUFBSXBDLElBQUk7b0JBQ2RHLE1BQU1pQyxJQUFJakMsSUFBSTtvQkFDZEMsS0FBS2dDLElBQUloQyxHQUFHO29CQUNaQyxPQUFPK0IsSUFBSS9CLEtBQUs7b0JBQ2hCQyxRQUFROEIsSUFBSTlCLE1BQU07b0JBQ2xCQyxrQkFBa0I2QixJQUFJN0IsZ0JBQWdCO29CQUN0Q0MsV0FBVzRCLElBQUk3QixnQkFBZ0IsSUFBSSxJQUFJLE9BQU87Z0JBQ2hEO1lBQ0FFLGtCQUFrQkE7WUFDbEJrRCxhQUFhLElBQUkvRCxPQUFPRSxXQUFXO1FBQ3JDO1FBRUEsbURBQW1EO1FBQ25ELElBQUksQ0FBQ29CLGNBQWM7WUFDakJ4QywwREFBZ0JBLENBQUNrRixHQUFHLENBQUNsQyxZQUFZO2dCQUMvQk8sTUFBTVA7Z0JBQ04zQyxRQUFRMkM7Z0JBQ1JyQyxnQkFBZ0JBO2dCQUNoQm9CLGtCQUFrQkE7Z0JBQ2xCcUIsYUFBYWxDLEtBQUtDLEdBQUc7WUFDdkI7UUFDRjtRQUVBLE9BQU9yQixrRkFBWUEsQ0FBQzZDLElBQUksQ0FBQ3FDO0lBQzNCLEVBQUUsT0FBT3BDLE9BQU87UUFDZEUsUUFBUUYsS0FBSyxDQUFDLENBQUMsdUNBQXVDLEVBQUV2QyxPQUFPLENBQUMsQ0FBQyxFQUFFdUM7UUFFbkUseUVBQXlFO1FBQ3pFLElBQUlKLGNBQWM7WUFDaEJNLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG1CQUFtQixFQUFFMUMsT0FBTyxxQ0FBcUMsQ0FBQztZQUMvRSxPQUFPUCxrRkFBWUEsQ0FBQzZDLElBQUksQ0FDdEI7Z0JBQUVDLE9BQU8sQ0FBQyx3QkFBd0IsRUFBRUEsaUJBQWlCYSxRQUFRYixNQUFNdUMsT0FBTyxHQUFHLGdCQUFnQixDQUFDO1lBQUMsR0FDL0Y7Z0JBQUV0QyxRQUFRO1lBQUk7UUFFbEI7UUFFQSwrQ0FBK0M7UUFDL0MsTUFBTUksYUFBYWpELDBEQUFnQkEsQ0FBQ3NDLEdBQUcsQ0FBQ1U7UUFFeEMsSUFBSUMsWUFBWXRDLGdCQUFnQnVDLFFBQVE7WUFDdENKLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLGlDQUFpQyxFQUFFMUMsT0FBTyx3QkFBd0IsQ0FBQztZQUNoRixPQUFPUCxrRkFBWUEsQ0FBQzZDLElBQUksQ0FBQztnQkFDdkJ0QyxRQUFRMkM7Z0JBQ1J0QyxhQUFhdUMsV0FBV00sSUFBSSxJQUFJUDtnQkFDaENyQyxnQkFBZ0JzQyxXQUFXdEMsY0FBYztnQkFDekNvQixrQkFBa0JrQixXQUFXbEIsZ0JBQWdCLElBQUksRUFBRTtnQkFDbkRxRCxXQUFXO2dCQUNYQyxnQkFBZ0JwQyxXQUFXRyxXQUFXO1lBQ3hDO1FBQ0Y7UUFFQSxzRUFBc0U7UUFDdEUsSUFBSSxDQUFDVixjQUFjO1lBQ2pCSSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxvQkFBb0IsRUFBRTFDLE9BQU8sK0JBQStCLENBQUM7WUFDMUUsT0FBT1Asa0ZBQVlBLENBQUM2QyxJQUFJLENBQUNuQyxtQkFBbUJILFFBQVFJO1FBQ3REO1FBRUEsK0NBQStDO1FBQy9DLE9BQU9YLGtGQUFZQSxDQUFDNkMsSUFBSSxDQUN0QjtZQUFFQyxPQUFPLENBQUMsc0NBQXNDLEVBQUVBLGlCQUFpQmEsUUFBUWIsTUFBTXVDLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQztRQUFDLEdBQzdHO1lBQUV0QyxRQUFRO1FBQUk7SUFFbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXN0b2NrLXZpZGVvLy4vYXBwL2FwaS92b2x1bWUtYW5hbHlzaXMvcm91dGUudHM/NTYyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyBnZXRDb21wYW55UHJvZmlsZSwgZm9ybWF0RGF0ZVlZWVlNTUREIH0gZnJvbSAnLi4vLi4vdXRpbHMvZmlubmh1Yic7XG5pbXBvcnQgeyBjb21wYW55RGF0YUNhY2hlLCBpc1JhdGVMaW1pdGVkIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2FjaGUnO1xuaW1wb3J0IHsgZ2V0U3RvY2tEYXRhLCBnZXRDb21wYW55TmV3c1dpdGhGYWxsYmFjaywgZ2V0Q29tcGFueVByb2ZpbGVXaXRoRmFsbGJhY2ssIE5ld3NJdGVtIGFzIFN0b2NrTmV3c0l0ZW0gfSBmcm9tICcuLi8uLi91dGlscy9zdG9jay1hcGknO1xuXG5pbnRlcmZhY2UgTmV3c0l0ZW0ge1xuICBkYXRlOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHNvdXJjZTogc3RyaW5nO1xuICB1cmw6IHN0cmluZztcbiAgc3VtbWFyeT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNpZ25pZmljYW50TW92ZSB7XG4gIGRhdGU6IHN0cmluZztcbiAgdm9sdW1lOiBudW1iZXI7XG4gIHByaWNlOiBudW1iZXI7XG4gIHByaWNlQ2hhbmdlOiBudW1iZXI7XG4gIHBlcmNlbnRhZ2VDaGFuZ2U6IG51bWJlcjtcbiAgcHJldmlvdXNDbG9zZTogbnVtYmVyO1xuICBoaWdoOiBudW1iZXI7XG4gIGxvdzogbnVtYmVyO1xuICBuZXdzOiBOZXdzSXRlbVtdO1xufVxuXG5pbnRlcmZhY2UgVm9sdW1lQW5hbHlzaXNSZXNwb25zZSB7XG4gIGNvbXBhbnk6IGFueTtcbiAgdGltZVNlcmllc0RhdGE6IGFueVtdO1xuICBzaWduaWZpY2FudE1vdmVzOiBTaWduaWZpY2FudE1vdmVbXTtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGV4dHJhY3QgdGhlIGJhc2Ugc3ltYm9sIHdpdGhvdXQgZXhjaGFuZ2UgcHJlZml4XG5mdW5jdGlvbiBnZXRCYXNlU3ltYm9sKHN5bWJvbDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN5bWJvbC5yZXBsYWNlKC9cXC4uKyQvLCAnJykudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gTW9jayB2b2x1bWUgYW5hbHlzaXMgZm9yIGZhbGxiYWNrXG5mdW5jdGlvbiBtb2NrVm9sdW1lQW5hbHlzaXMoc3ltYm9sOiBzdHJpbmcsIHRpbWVmcmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiB7XG4gICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgY29tcGFueU5hbWU6IHN5bWJvbCxcbiAgICB0aW1lU2VyaWVzRGF0YTogQXJyYXkoMzApLmZpbGwoMCkubWFwKChfLCBpKSA9PiAoe1xuICAgICAgZGF0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIGkgKiA4NjQwMDAwMCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgb3BlbjogMTAwICsgTWF0aC5yYW5kb20oKSAqIDEwLFxuICAgICAgaGlnaDogMTA1ICsgTWF0aC5yYW5kb20oKSAqIDEwLFxuICAgICAgbG93OiA5NSArIE1hdGgucmFuZG9tKCkgKiAxMCxcbiAgICAgIGNsb3NlOiAxMDAgKyBNYXRoLnJhbmRvbSgpICogMTAsXG4gICAgICB2b2x1bWU6IDEwMDAwMDAgKyBNYXRoLnJhbmRvbSgpICogMjAwMDAwMCxcbiAgICAgIHBlcmNlbnRhZ2VDaGFuZ2U6IChNYXRoLnJhbmRvbSgpICogNCkgLSAyLFxuICAgICAgZGlyZWN0aW9uOiBNYXRoLnJhbmRvbSgpID4gMC41ID8gJ3VwJyA6ICdkb3duJ1xuICAgIH0pKSxcbiAgICBzaWduaWZpY2FudE1vdmVzOiBbXSxcbiAgICBpc01vY2tEYXRhOiB0cnVlXG4gIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQocmVxdWVzdDogUmVxdWVzdCkge1xuICBjb25zdCB7IHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gIGNvbnN0IHN5bWJvbCA9IHNlYXJjaFBhcmFtcy5nZXQoJ3N5bWJvbCcpPy50b1VwcGVyQ2FzZSgpO1xuICAvLyBDb252ZXJ0IHRpbWVmcmFtZSB0byB0aGUgZm9ybWF0IGV4cGVjdGVkIGJ5IHRoZSBzdG9jayBBUElcbiAgY29uc3QgdGltZWZyYW1lUGFyYW0gPSBzZWFyY2hQYXJhbXMuZ2V0KCd0aW1lZnJhbWUnKSB8fCAnM20nO1xuICBjb25zdCB0aW1lZnJhbWUgPSAoKCkgPT4ge1xuICAgIHN3aXRjaCAodGltZWZyYW1lUGFyYW0pIHtcbiAgICAgIGNhc2UgJzF3JzogcmV0dXJuICcxdyc7XG4gICAgICBjYXNlICcxbSc6IHJldHVybiAnMW1vJztcbiAgICAgIGNhc2UgJzNtJzogcmV0dXJuICczbW8nO1xuICAgICAgY2FzZSAnNm0nOiByZXR1cm4gJzZtbyc7XG4gICAgICBjYXNlICcxeSc6IHJldHVybiAnMXknO1xuICAgICAgZGVmYXVsdDogcmV0dXJuICczbW8nO1xuICAgIH1cbiAgfSkoKTtcbiAgY29uc3QgZm9yY2VSZWZyZXNoID0gc2VhcmNoUGFyYW1zLmdldCgnZm9yY2UnKSA9PT0gJ3RydWUnO1xuICBjb25zdCB1c2VNb2NrID0gc2VhcmNoUGFyYW1zLmdldCgnbW9jaycpID09PSAndHJ1ZSc7IC8vIFBhcmFtZXRlciB0byBleHBsaWNpdGx5IHJlcXVlc3QgbW9jayBkYXRhXG4gIGNvbnN0IGRpc2FsbG93TW9jayA9IHNlYXJjaFBhcmFtcy5nZXQoJ21vY2snKSA9PT0gJ2ZhbHNlJzsgLy8gTmV3IHBhcmFtZXRlciB0byBkaXNhbGxvdyBtb2NrIGRhdGFcblxuICBpZiAoIXN5bWJvbCkge1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnU3ltYm9sIGlzIHJlcXVpcmVkJyB9LCB7IHN0YXR1czogNDAwIH0pO1xuICB9XG4gIFxuICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyB2b2x1bWUgYW5hbHlzaXMgcmVxdWVzdCBmb3IgJHtzeW1ib2x9IHdpdGggdGltZWZyYW1lICR7dGltZWZyYW1lfSR7Zm9yY2VSZWZyZXNoID8gJyAoZm9yY2VkIHJlZnJlc2gpJyA6ICcnfSR7dXNlTW9jayA/ICcgKHVzaW5nIG1vY2sgZGF0YSknIDogJyd9JHtkaXNhbGxvd01vY2sgPyAnIChkaXNhbGxvd2luZyBtb2NrIGRhdGEpJyA6ICcnfWApO1xuXG4gIC8vIEdldCB0aGUgYmFzZSBzeW1ib2wgd2l0aG91dCBhbnkgZXhjaGFuZ2UgcHJlZml4XG4gIGNvbnN0IGJhc2VTeW1ib2wgPSBnZXRCYXNlU3ltYm9sKHN5bWJvbCk7XG4gIFxuICB0cnkge1xuICAgIC8vIElmIG1vY2sgZGF0YSBpcyBleHBsaWNpdGx5IHJlcXVlc3RlZCwgcmV0dXJuIGl0IGltbWVkaWF0ZWx5XG4gICAgaWYgKHVzZU1vY2spIHtcbiAgICAgIGNvbnNvbGUubG9nKGBVc2luZyBtb2NrIGRhdGEgZm9yICR7c3ltYm9sfSB2b2x1bWUgYW5hbHlzaXMgYXMgZXhwbGljaXRseSByZXF1ZXN0ZWRgKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihtb2NrVm9sdW1lQW5hbHlzaXMoc3ltYm9sLCB0aW1lZnJhbWUpKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2tpcCBjYWNoZSBjaGVjayBpZiBhIGZvcmNlZCByZWZyZXNoIGlzIHJlcXVlc3RlZFxuICAgIGlmICghZm9yY2VSZWZyZXNoKSB7XG4gICAgICAvLyBDaGVjayBmb3IgY2FjaGVkIGRhdGFcbiAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSBjb21wYW55RGF0YUNhY2hlLmdldChiYXNlU3ltYm9sKTtcbiAgICAgIFxuICAgICAgaWYgKGNhY2hlZERhdGE/LnRpbWVTZXJpZXNEYXRhPy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY2FjaGVBZ2UgPSBEYXRlLm5vdygpIC0gKGNhY2hlZERhdGEubGFzdFVwZGF0ZWQgfHwgMCk7XG4gICAgICAgIGNvbnN0IG1heEFnZSA9IDM2MDAwMDA7IC8vIDEgaG91clxuICAgICAgICBcbiAgICAgICAgaWYgKGNhY2hlQWdlIDwgbWF4QWdlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIGNhY2hlZCB2b2x1bWUgYW5hbHlzaXMgZm9yICR7c3ltYm9sfSAoYWdlOiAke01hdGgucm91bmQoY2FjaGVBZ2UvMTAwMC82MCl9IG1pbnV0ZXMpYCk7XG4gICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgIHN5bWJvbDogYmFzZVN5bWJvbCxcbiAgICAgICAgICAgIGNvbXBhbnlOYW1lOiBjYWNoZWREYXRhLm5hbWUgfHwgYmFzZVN5bWJvbCxcbiAgICAgICAgICAgIHRpbWVTZXJpZXNEYXRhOiBjYWNoZWREYXRhLnRpbWVTZXJpZXNEYXRhLFxuICAgICAgICAgICAgc2lnbmlmaWNhbnRNb3ZlczogY2FjaGVkRGF0YS5zaWduaWZpY2FudE1vdmVzIHx8IFtdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYENhY2hlZCB2b2x1bWUgYW5hbHlzaXMgZm9yICR7c3ltYm9sfSBpcyBzdGFsZSAoJHtNYXRoLnJvdW5kKGNhY2hlQWdlLzEwMDAvNjApfSBtaW51dGVzIG9sZClgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhgRm9yY2VkIHJlZnJlc2ggcmVxdWVzdGVkIGZvciAke3N5bWJvbH0sIGJ5cGFzc2luZyBjYWNoZSBlbnRpcmVseWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBGZXRjaCBuZXcgZGF0YVxuICAgIGNvbnN0IHN0b2NrRGF0YSA9IGF3YWl0IGdldFN0b2NrRGF0YShzeW1ib2wsIHRpbWVmcmFtZSk7XG4gICAgXG4gICAgaWYgKCFzdG9ja0RhdGEudGltZVNlcmllc0RhdGEgfHwgc3RvY2tEYXRhLnRpbWVTZXJpZXNEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0aW1lIHNlcmllcyBkYXRhIGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBQcm9jZXNzIHRoZSBkYXRhIHRvIGZpbmQgc2lnbmlmaWNhbnQgcHJpY2UgbW92ZXNcbiAgICBjb25zdCB0aW1lU2VyaWVzRGF0YSA9IHN0b2NrRGF0YS50aW1lU2VyaWVzRGF0YTtcbiAgICBjb25zdCBzaWduaWZpY2FudE1vdmVzID0gW107XG4gICAgXG4gICAgLy8gRmluZCBkYXlzIHdpdGggc2lnbmlmaWNhbnQgcHJpY2UgYW5kIHZvbHVtZSBtb3ZlbWVudFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVNlcmllc0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRheSA9IHRpbWVTZXJpZXNEYXRhW2ldO1xuICAgICAgXG4gICAgICAvLyBTaWduaWZpY2FudCBtb3ZlIGNyaXRlcmlhOiA+MiUgcHJpY2UgY2hhbmdlIEFORCB2b2x1bWUgPiAxLjV4IDMwLWRheSBhdmVyYWdlXG4gICAgICBpZiAoTWF0aC5hYnMoZGF5LnBlcmNlbnRhZ2VDaGFuZ2UpID4gMikge1xuICAgICAgICAvLyBDYWxjdWxhdGUgYXZlcmFnZSB2b2x1bWUgZm9yIHByZXZpb3VzIDMwIGRheXNcbiAgICAgICAgbGV0IHZvbHVtZVN1bSA9IDA7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBNYXRoLm1pbihpICsgMzEsIHRpbWVTZXJpZXNEYXRhLmxlbmd0aCk7IGorKykge1xuICAgICAgICAgIHZvbHVtZVN1bSArPSB0aW1lU2VyaWVzRGF0YVtqXS52b2x1bWU7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgYXZnVm9sdW1lID0gY291bnQgPiAwID8gdm9sdW1lU3VtIC8gY291bnQgOiBkYXkudm9sdW1lO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdm9sdW1lIGlzIHNpZ25pZmljYW50bHkgaGlnaGVyIHRoYW4gYXZlcmFnZVxuICAgICAgICBpZiAoZGF5LnZvbHVtZSA+IGF2Z1ZvbHVtZSAqIDEuNSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaWduaWZpY2FudCBtb3ZlIC0gZ2V0IHRoZSBwcmV2aW91cyBjbG9zZSBmb3IgcmVmZXJlbmNlXG4gICAgICAgICAgY29uc3QgcHJldmlvdXNDbG9zZSA9IGkgPCB0aW1lU2VyaWVzRGF0YS5sZW5ndGggLSAxID8gdGltZVNlcmllc0RhdGFbaSArIDFdLmNsb3NlIDogZGF5Lm9wZW47XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9ybWF0IHRoZSBkYXRlIGZvciBuZXdzIGxvb2t1cFxuICAgICAgICAgIGNvbnN0IG1vdmVEYXRlID0gbmV3IERhdGUoZGF5LmRhdGUpO1xuICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSBmb3JtYXREYXRlWVlZWU1NREQobW92ZURhdGUpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCBuZXdzIGFyb3VuZCB0aGlzIGRhdGVcbiAgICAgICAgICBjb25zdCBuZXdzSXRlbXMgPSBhd2FpdCBnZXRDb21wYW55TmV3c1dpdGhGYWxsYmFjayhzeW1ib2wsIDMpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZpbHRlciBuZXdzIGl0ZW1zIGFyb3VuZCB0aGUgbW92ZSBkYXRlICgzIGRheXMgYmVmb3JlIGFuZCBhZnRlcilcbiAgICAgICAgICBjb25zdCByZWxldmFudE5ld3MgPSBuZXdzSXRlbXMuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3c0RhdGUgPSBuZXcgRGF0ZShpdGVtLmRhdGUpO1xuICAgICAgICAgICAgY29uc3QgZGF5c0RpZmYgPSBNYXRoLmFicygobmV3c0RhdGUuZ2V0VGltZSgpIC0gbW92ZURhdGUuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSk7XG4gICAgICAgICAgICByZXR1cm4gZGF5c0RpZmYgPD0gMztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgdG8gc2lnbmlmaWNhbnQgbW92ZXNcbiAgICAgICAgICBzaWduaWZpY2FudE1vdmVzLnB1c2goe1xuICAgICAgICAgICAgZGF0ZTogZGF5LmRhdGUsXG4gICAgICAgICAgICB2b2x1bWU6IGRheS52b2x1bWUsXG4gICAgICAgICAgICBwcmljZTogZGF5LmNsb3NlLFxuICAgICAgICAgICAgcHJpY2VDaGFuZ2U6IGRheS5jbG9zZSAtIHByZXZpb3VzQ2xvc2UsXG4gICAgICAgICAgICBwZXJjZW50YWdlQ2hhbmdlOiBkYXkucGVyY2VudGFnZUNoYW5nZSxcbiAgICAgICAgICAgIHByZXZpb3VzQ2xvc2U6IHByZXZpb3VzQ2xvc2UsXG4gICAgICAgICAgICBoaWdoOiBkYXkuaGlnaCxcbiAgICAgICAgICAgIGxvdzogZGF5LmxvdyxcbiAgICAgICAgICAgIG5ld3M6IHJlbGV2YW50TmV3c1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEdldCBjb21wYW55IHByb2ZpbGUgZm9yIGFkZGl0aW9uYWwgaW5mb1xuICAgIGNvbnN0IGNvbXBhbnlQcm9maWxlID0gYXdhaXQgZ2V0Q29tcGFueVByb2ZpbGVXaXRoRmFsbGJhY2soc3ltYm9sKTtcbiAgICBcbiAgICAvLyBDb25zdHJ1Y3QgdGhlIHJlc3BvbnNlXG4gICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICBzeW1ib2w6IGJhc2VTeW1ib2wsXG4gICAgICBjb21wYW55TmFtZTogY29tcGFueVByb2ZpbGUubmFtZSB8fCBiYXNlU3ltYm9sLFxuICAgICAgdGltZVNlcmllc0RhdGE6IHRpbWVTZXJpZXNEYXRhLm1hcChkYXkgPT4gKHtcbiAgICAgICAgZGF0ZTogZGF5LmRhdGUsXG4gICAgICAgIG9wZW46IGRheS5vcGVuLFxuICAgICAgICBoaWdoOiBkYXkuaGlnaCxcbiAgICAgICAgbG93OiBkYXkubG93LFxuICAgICAgICBjbG9zZTogZGF5LmNsb3NlLFxuICAgICAgICB2b2x1bWU6IGRheS52b2x1bWUsXG4gICAgICAgIHBlcmNlbnRhZ2VDaGFuZ2U6IGRheS5wZXJjZW50YWdlQ2hhbmdlLFxuICAgICAgICBkaXJlY3Rpb246IGRheS5wZXJjZW50YWdlQ2hhbmdlID49IDAgPyAndXAnIDogJ2Rvd24nXG4gICAgICB9KSksXG4gICAgICBzaWduaWZpY2FudE1vdmVzOiBzaWduaWZpY2FudE1vdmVzLFxuICAgICAgcmVmcmVzaGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgXG4gICAgLy8gQ2FjaGUgdGhlIHJlc3VsdHMgaWYgdGhpcyBpc24ndCBhIGZvcmNlZCByZWZyZXNoXG4gICAgaWYgKCFmb3JjZVJlZnJlc2gpIHtcbiAgICAgIGNvbXBhbnlEYXRhQ2FjaGUuc2V0KGJhc2VTeW1ib2wsIHtcbiAgICAgICAgbmFtZTogYmFzZVN5bWJvbCxcbiAgICAgICAgc3ltYm9sOiBiYXNlU3ltYm9sLFxuICAgICAgICB0aW1lU2VyaWVzRGF0YTogdGltZVNlcmllc0RhdGEsXG4gICAgICAgIHNpZ25pZmljYW50TW92ZXM6IHNpZ25pZmljYW50TW92ZXMsXG4gICAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHJlc3BvbnNlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiB2b2x1bWUgYW5hbHlzaXMgQVBJIHJvdXRlIGZvciAke3N5bWJvbH06YCwgZXJyb3IpO1xuICAgIFxuICAgIC8vIEZvciBmb3JjZWQgcmVmcmVzaCwgd2UgZG9uJ3Qgd2FudCB0byByZXR1cm4gZWl0aGVyIGNhY2hlZCBvciBtb2NrIGRhdGFcbiAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICBjb25zb2xlLmxvZyhgUmVmcmVzaCBmYWlsZWQgZm9yICR7c3ltYm9sfSwgcmV0dXJuaW5nIGVycm9yIGluc3RlYWQgb2YgZmFsbGJhY2tgKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogYEZhaWxlZCB0byByZWZyZXNoIGRhdGE6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCB9LFxuICAgICAgICB7IHN0YXR1czogNTAzIH1cbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSBjYWNoZSBhcyBmYWxsYmFjayBpZiBub3QgZm9yY2luZyByZWZyZXNoXG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IGNvbXBhbnlEYXRhQ2FjaGUuZ2V0KGJhc2VTeW1ib2wpO1xuICAgIFxuICAgIGlmIChjYWNoZWREYXRhPy50aW1lU2VyaWVzRGF0YT8ubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZyhgVXNpbmcgY2FjaGVkIHZvbHVtZSBhbmFseXNpcyBmb3IgJHtzeW1ib2x9IGFzIGZhbGxiYWNrIGFmdGVyIGVycm9yYCk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICBzeW1ib2w6IGJhc2VTeW1ib2wsXG4gICAgICAgIGNvbXBhbnlOYW1lOiBjYWNoZWREYXRhLm5hbWUgfHwgYmFzZVN5bWJvbCxcbiAgICAgICAgdGltZVNlcmllc0RhdGE6IGNhY2hlZERhdGEudGltZVNlcmllc0RhdGEsXG4gICAgICAgIHNpZ25pZmljYW50TW92ZXM6IGNhY2hlZERhdGEuc2lnbmlmaWNhbnRNb3ZlcyB8fCBbXSxcbiAgICAgICAgZnJvbUNhY2hlOiB0cnVlLFxuICAgICAgICBjYWNoZVRpbWVzdGFtcDogY2FjaGVkRGF0YS5sYXN0VXBkYXRlZFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVzZSBtb2NrIGRhdGEgYXMgbGFzdCByZXNvcnQsIGJ1dCBvbmx5IGlmIG5vdCBleHBsaWNpdGx5IGRpc2FsbG93ZWRcbiAgICBpZiAoIWRpc2FsbG93TW9jaykge1xuICAgICAgY29uc29sZS5sb2coYFVzaW5nIG1vY2sgZGF0YSBmb3IgJHtzeW1ib2x9IHZvbHVtZSBhbmFseXNpcyBhcyBsYXN0IHJlc29ydGApO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKG1vY2tWb2x1bWVBbmFseXNpcyhzeW1ib2wsIHRpbWVmcmFtZSkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgd2UgY291bGRuJ3QgcHJvdmlkZSBhbnkgZGF0YVxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6IGBGYWlsZWQgdG8gZmV0Y2ggdm9sdW1lIGFuYWx5c2lzIGRhdGE6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKTtcbiAgfVxufSAiXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiZm9ybWF0RGF0ZVlZWVlNTUREIiwiY29tcGFueURhdGFDYWNoZSIsImdldFN0b2NrRGF0YSIsImdldENvbXBhbnlOZXdzV2l0aEZhbGxiYWNrIiwiZ2V0Q29tcGFueVByb2ZpbGVXaXRoRmFsbGJhY2siLCJnZXRCYXNlU3ltYm9sIiwic3ltYm9sIiwicmVwbGFjZSIsInRvVXBwZXJDYXNlIiwibW9ja1ZvbHVtZUFuYWx5c2lzIiwidGltZWZyYW1lIiwiY29tcGFueU5hbWUiLCJ0aW1lU2VyaWVzRGF0YSIsIkFycmF5IiwiZmlsbCIsIm1hcCIsIl8iLCJpIiwiZGF0ZSIsIkRhdGUiLCJub3ciLCJ0b0lTT1N0cmluZyIsInNwbGl0Iiwib3BlbiIsIk1hdGgiLCJyYW5kb20iLCJoaWdoIiwibG93IiwiY2xvc2UiLCJ2b2x1bWUiLCJwZXJjZW50YWdlQ2hhbmdlIiwiZGlyZWN0aW9uIiwic2lnbmlmaWNhbnRNb3ZlcyIsImlzTW9ja0RhdGEiLCJHRVQiLCJyZXF1ZXN0Iiwic2VhcmNoUGFyYW1zIiwiVVJMIiwidXJsIiwiZ2V0IiwidGltZWZyYW1lUGFyYW0iLCJmb3JjZVJlZnJlc2giLCJ1c2VNb2NrIiwiZGlzYWxsb3dNb2NrIiwianNvbiIsImVycm9yIiwic3RhdHVzIiwiY29uc29sZSIsImxvZyIsImJhc2VTeW1ib2wiLCJjYWNoZWREYXRhIiwibGVuZ3RoIiwiY2FjaGVBZ2UiLCJsYXN0VXBkYXRlZCIsIm1heEFnZSIsInJvdW5kIiwibmFtZSIsInN0b2NrRGF0YSIsIkVycm9yIiwiZGF5IiwiYWJzIiwidm9sdW1lU3VtIiwiY291bnQiLCJqIiwibWluIiwiYXZnVm9sdW1lIiwicHJldmlvdXNDbG9zZSIsIm1vdmVEYXRlIiwiZm9ybWF0dGVkRGF0ZSIsIm5ld3NJdGVtcyIsInJlbGV2YW50TmV3cyIsImZpbHRlciIsIml0ZW0iLCJuZXdzRGF0ZSIsImRheXNEaWZmIiwiZ2V0VGltZSIsInB1c2giLCJwcmljZSIsInByaWNlQ2hhbmdlIiwibmV3cyIsImNvbXBhbnlQcm9maWxlIiwicmVzcG9uc2UiLCJyZWZyZXNoZWRBdCIsInNldCIsIm1lc3NhZ2UiLCJmcm9tQ2FjaGUiLCJjYWNoZVRpbWVzdGFtcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/volume-analysis/route.ts\n");

/***/ }),

/***/ "(rsc)/./app/utils/alphavantage.ts":
/*!***********************************!*\
  !*** ./app/utils/alphavantage.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDailyTimeSeries: () => (/* binding */ getDailyTimeSeries)\n/* harmony export */ });\n/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cache */ \"(rsc)/./app/utils/cache.ts\");\nconst ALPHA_VANTAGE_API_KEY = process.env.ALPHA_VANTAGE_API_KEY;\nconst BASE_URL = \"https://www.alphavantage.co/query\";\n\nif (!ALPHA_VANTAGE_API_KEY) {\n    console.error(\"ALPHA_VANTAGE_API_KEY is not set in environment variables\");\n}\n// Generate 90 days of mock data with more significant price movements\nconst MOCK_DATA = Array.from({\n    length: 90\n}, (_, i)=>{\n    const date = new Date();\n    date.setDate(date.getDate() - i);\n    // Base values with more dramatic variations\n    const basePrice = 182.50;\n    const volatility = 5.0; // Increased volatility\n    // Generate more dramatic price movements\n    const randomChange = (Math.random() - 0.5) * volatility * 2; // Double the potential change\n    const open = basePrice + randomChange;\n    const high = open + Math.random() * volatility * 1.5;\n    const low = open - Math.random() * volatility * 1.5;\n    const close = (open + high + low) / 3 + (Math.random() - 0.5) * volatility;\n    // Generate volume with occasional spikes\n    const baseVolume = 45000000;\n    const volumeSpike = Math.random() < 0.2 ? 3 : 1; // 20% chance of volume spike\n    const volume = Math.floor(baseVolume + Math.random() * 15000000 * volumeSpike);\n    const percentageChange = (close - open) / open * 100;\n    return {\n        date: date.toISOString().split(\"T\")[0],\n        open: Number(open.toFixed(2)),\n        high: Number(high.toFixed(2)),\n        low: Number(low.toFixed(2)),\n        close: Number(close.toFixed(2)),\n        volume: volume,\n        percentageChange: Number(percentageChange.toFixed(2)),\n        direction: percentageChange >= 0 ? \"up\" : \"down\"\n    };\n});\nasync function makeRequest(url) {\n    console.log(\"Making Alpha Vantage API request:\", url.replace(process.env.ALPHA_VANTAGE_API_KEY || \"\", \"[API_KEY]\"));\n    try {\n        const response = await fetch(url);\n        if (!response.ok) {\n            console.error(\"Alpha Vantage API error:\", response.status, response.statusText);\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        console.log(\"Alpha Vantage API response structure:\", Object.keys(data));\n        return data;\n    } catch (error) {\n        console.error(\"Error in Alpha Vantage makeRequest:\", error);\n        throw error;\n    }\n}\nasync function getDailyTimeSeries(symbol, timeframe = \"3m\") {\n    try {\n        console.log(`Getting daily data for ${symbol} with timeframe ${timeframe}`);\n        // Check if we have cached data for this symbol/timeframe\n        const cachedData = _cache__WEBPACK_IMPORTED_MODULE_0__.companyDataCache.get(symbol);\n        // Use TIME_SERIES_DAILY API endpoint to get historical data\n        const outputSize = timeframe === \"1y\" || timeframe === \"5y\" ? \"full\" : \"compact\";\n        const url = `${BASE_URL}?function=TIME_SERIES_DAILY&symbol=${symbol}&outputsize=${outputSize}&apikey=${ALPHA_VANTAGE_API_KEY}`;\n        try {\n            const data = await makeRequest(url);\n            // Check for rate limiting\n            if (data.Information?.includes(\"API rate limit\")) {\n                console.log(\"API rate limited, using cached data if available\");\n                (0,_cache__WEBPACK_IMPORTED_MODULE_0__.setRateLimited)(true);\n                // If we have cached data, use it\n                if (cachedData?.timeSeriesData?.length) {\n                    console.log(`Using cached data for ${symbol}`);\n                    return {\n                        allDailyData: cachedData.timeSeriesData,\n                        significantPriceMoves: cachedData.significantMoves\n                    };\n                }\n                // Otherwise fall back to mock data\n                console.log(\"No cached data available, using mock data\");\n                return processVolumeData(MOCK_DATA);\n            }\n            // Reset rate limited flag when we successfully get data\n            (0,_cache__WEBPACK_IMPORTED_MODULE_0__.setRateLimited)(false);\n            if (!data[\"Time Series (Daily)\"]) {\n                console.error(\"Invalid Alpha Vantage response structure:\", data);\n                // Check for cached data before falling back to mock\n                if (cachedData?.timeSeriesData?.length) {\n                    console.log(`Using cached data for ${symbol}`);\n                    return {\n                        allDailyData: cachedData.timeSeriesData,\n                        significantPriceMoves: cachedData.significantMoves\n                    };\n                }\n                console.log(\"Falling back to mock data\");\n                return processVolumeData(MOCK_DATA);\n            }\n            const timeSeriesData = data[\"Time Series (Daily)\"];\n            const daysToInclude = getTimeframeDays(timeframe);\n            // Process historical data\n            const processedData = Object.entries(timeSeriesData).map(([date, values])=>{\n                const open = parseFloat(values[\"1. open\"]);\n                const close = parseFloat(values[\"4. close\"]);\n                const percentageChange = (close - open) / open * 100;\n                return {\n                    date,\n                    open,\n                    high: parseFloat(values[\"2. high\"]),\n                    low: parseFloat(values[\"3. low\"]),\n                    close,\n                    volume: parseInt(values[\"5. volume\"], 10),\n                    percentageChange: Number(percentageChange.toFixed(2)),\n                    direction: percentageChange >= 0 ? \"up\" : \"down\"\n                };\n            })// Sort by date descending (most recent first)\n            .sort((a, b)=>new Date(b.date).getTime() - new Date(a.date).getTime())// Limit to the number of days needed for the timeframe\n            .slice(0, daysToInclude);\n            console.log(`Successfully processed ${processedData.length} days of time series data`);\n            // Process the data\n            const result = processVolumeData(processedData);\n            // Cache the successful result\n            _cache__WEBPACK_IMPORTED_MODULE_0__.companyDataCache.set(symbol, {\n                timeSeriesData: result.allDailyData,\n                significantMoves: result.significantPriceMoves\n            });\n            return result;\n        } catch (error) {\n            console.error(\"Error fetching from Alpha Vantage:\", error);\n            // Set rate limited flag as this might be a rate limit error\n            (0,_cache__WEBPACK_IMPORTED_MODULE_0__.setRateLimited)(true);\n            // Check for cached data before falling back to mock\n            if (cachedData?.timeSeriesData?.length) {\n                console.log(`Using cached data for ${symbol}`);\n                return {\n                    allDailyData: cachedData.timeSeriesData,\n                    significantPriceMoves: cachedData.significantMoves\n                };\n            }\n            return processVolumeData(MOCK_DATA);\n        }\n    } catch (error) {\n        console.error(\"Error in getDailyTimeSeries:\", error);\n        // Check for cached data before falling back to mock\n        const cachedData = _cache__WEBPACK_IMPORTED_MODULE_0__.companyDataCache.get(symbol);\n        if (cachedData?.timeSeriesData?.length) {\n            console.log(`Using cached data for ${symbol}`);\n            return {\n                allDailyData: cachedData.timeSeriesData,\n                significantPriceMoves: cachedData.significantMoves\n            };\n        }\n        return processVolumeData(MOCK_DATA);\n    }\n}\nfunction calculateImpactScore(data) {\n    // Find max values for normalization\n    const maxVolume = Math.max(...data.map((day)=>day.volume));\n    const maxAbsPercentChange = Math.max(...data.map((day)=>Math.abs(day.percentageChange)));\n    return data.map((day)=>({\n            ...day,\n            impactScore: // Normalize and weight percentage change (weight: 3)\n            3 * Math.abs(day.percentageChange) / maxAbsPercentChange + // Normalize and weight volume (weight: 2)\n            2 * day.volume / maxVolume\n        }));\n}\nfunction processVolumeData(data) {\n    // Sort by date descending to ensure consistent order\n    const allDailyData = [\n        ...data\n    ].sort((a, b)=>new Date(b.date).getTime() - new Date(a.date).getTime());\n    // Calculate impact scores for all days\n    const daysWithImpactScores = calculateImpactScore(allDailyData);\n    // Get top 5 days by impact score\n    const significantPriceMoves = daysWithImpactScores.sort((a, b)=>(b.impactScore || 0) - (a.impactScore || 0)).slice(0, 5);\n    return {\n        allDailyData: daysWithImpactScores,\n        significantPriceMoves\n    };\n}\nfunction getTimeframeDays(timeframe) {\n    switch(timeframe){\n        case \"1w\":\n            return 7;\n        case \"1m\":\n            return 30;\n        case \"3m\":\n            return 90;\n        case \"1y\":\n            return 365;\n        case \"5y\":\n            return 1825;\n        default:\n            return 90; // Default to 3 months\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvdXRpbHMvYWxwaGF2YW50YWdlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsTUFBTUEsd0JBQXdCQyxRQUFRQyxHQUFHLENBQUNGLHFCQUFxQjtBQUMvRCxNQUFNRyxXQUFXO0FBRTBDO0FBRTNELElBQUksQ0FBQ0gsdUJBQXVCO0lBQzFCTSxRQUFRQyxLQUFLLENBQUM7QUFDaEI7QUFFQSxzRUFBc0U7QUFDdEUsTUFBTUMsWUFBeUJDLE1BQU1DLElBQUksQ0FBQztJQUFFQyxRQUFRO0FBQUcsR0FBRyxDQUFDQyxHQUFHQztJQUM1RCxNQUFNQyxPQUFPLElBQUlDO0lBQ2pCRCxLQUFLRSxPQUFPLENBQUNGLEtBQUtHLE9BQU8sS0FBS0o7SUFFOUIsNENBQTRDO0lBQzVDLE1BQU1LLFlBQVk7SUFDbEIsTUFBTUMsYUFBYSxLQUFLLHVCQUF1QjtJQUUvQyx5Q0FBeUM7SUFDekMsTUFBTUMsZUFBZSxDQUFDQyxLQUFLQyxNQUFNLEtBQUssR0FBRSxJQUFLSCxhQUFhLEdBQUcsOEJBQThCO0lBQzNGLE1BQU1JLE9BQU9MLFlBQVlFO0lBQ3pCLE1BQU1JLE9BQU9ELE9BQU9GLEtBQUtDLE1BQU0sS0FBS0gsYUFBYTtJQUNqRCxNQUFNTSxNQUFNRixPQUFPRixLQUFLQyxNQUFNLEtBQUtILGFBQWE7SUFDaEQsTUFBTU8sUUFBUSxDQUFDSCxPQUFPQyxPQUFPQyxHQUFFLElBQUssSUFBSSxDQUFDSixLQUFLQyxNQUFNLEtBQUssR0FBRSxJQUFLSDtJQUVoRSx5Q0FBeUM7SUFDekMsTUFBTVEsYUFBYTtJQUNuQixNQUFNQyxjQUFjUCxLQUFLQyxNQUFNLEtBQUssTUFBTSxJQUFJLEdBQUcsNkJBQTZCO0lBQzlFLE1BQU1PLFNBQVNSLEtBQUtTLEtBQUssQ0FBQ0gsYUFBY04sS0FBS0MsTUFBTSxLQUFLLFdBQVdNO0lBRW5FLE1BQU1HLG1CQUFtQixDQUFFTCxRQUFRSCxJQUFHLElBQUtBLE9BQVE7SUFFbkQsT0FBTztRQUNMVCxNQUFNQSxLQUFLa0IsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDdENWLE1BQU1XLE9BQU9YLEtBQUtZLE9BQU8sQ0FBQztRQUMxQlgsTUFBTVUsT0FBT1YsS0FBS1csT0FBTyxDQUFDO1FBQzFCVixLQUFLUyxPQUFPVCxJQUFJVSxPQUFPLENBQUM7UUFDeEJULE9BQU9RLE9BQU9SLE1BQU1TLE9BQU8sQ0FBQztRQUM1Qk4sUUFBUUE7UUFDUkUsa0JBQWtCRyxPQUFPSCxpQkFBaUJJLE9BQU8sQ0FBQztRQUNsREMsV0FBV0wsb0JBQW9CLElBQUksT0FBTztJQUM1QztBQUNGO0FBdURBLGVBQWVNLFlBQVlDLEdBQVc7SUFDcENoQyxRQUFRaUMsR0FBRyxDQUFDLHFDQUFxQ0QsSUFBSUUsT0FBTyxDQUFDdkMsUUFBUUMsR0FBRyxDQUFDRixxQkFBcUIsSUFBSSxJQUFJO0lBQ3RHLElBQUk7UUFDRixNQUFNeUMsV0FBVyxNQUFNQyxNQUFNSjtRQUM3QixJQUFJLENBQUNHLFNBQVNFLEVBQUUsRUFBRTtZQUNoQnJDLFFBQVFDLEtBQUssQ0FBQyw0QkFBNEJrQyxTQUFTRyxNQUFNLEVBQUVILFNBQVNJLFVBQVU7WUFDOUUsTUFBTSxJQUFJQyxNQUFNLENBQUMsb0JBQW9CLEVBQUVMLFNBQVNHLE1BQU0sQ0FBQyxDQUFDO1FBQzFEO1FBQ0EsTUFBTUcsT0FBTyxNQUFNTixTQUFTTyxJQUFJO1FBQ2hDMUMsUUFBUWlDLEdBQUcsQ0FBQyx5Q0FBeUNVLE9BQU9DLElBQUksQ0FBQ0g7UUFDakUsT0FBT0E7SUFDVCxFQUFFLE9BQU94QyxPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyx1Q0FBdUNBO1FBQ3JELE1BQU1BO0lBQ1I7QUFDRjtBQUVPLGVBQWU0QyxtQkFBbUJDLE1BQWMsRUFBRUMsWUFBb0IsSUFBSTtJQUMvRSxJQUFJO1FBQ0YvQyxRQUFRaUMsR0FBRyxDQUFDLENBQUMsdUJBQXVCLEVBQUVhLE9BQU8sZ0JBQWdCLEVBQUVDLFVBQVUsQ0FBQztRQUUxRSx5REFBeUQ7UUFDekQsTUFBTUMsYUFBYWxELG9EQUFnQkEsQ0FBQ21ELEdBQUcsQ0FBQ0g7UUFFeEMsNERBQTREO1FBQzVELE1BQU1JLGFBQWFILGNBQWMsUUFBUUEsY0FBYyxPQUFPLFNBQVM7UUFDdkUsTUFBTWYsTUFBTSxDQUFDLEVBQUVuQyxTQUFTLG1DQUFtQyxFQUFFaUQsT0FBTyxZQUFZLEVBQUVJLFdBQVcsUUFBUSxFQUFFeEQsc0JBQXNCLENBQUM7UUFFOUgsSUFBSTtZQUNGLE1BQU0rQyxPQUFvQyxNQUFNVixZQUFZQztZQUU1RCwwQkFBMEI7WUFDMUIsSUFBSVMsS0FBS1UsV0FBVyxFQUFFQyxTQUFTLG1CQUFtQjtnQkFDaERwRCxRQUFRaUMsR0FBRyxDQUFDO2dCQUNabEMsc0RBQWNBLENBQUM7Z0JBRWYsaUNBQWlDO2dCQUNqQyxJQUFJaUQsWUFBWUssZ0JBQWdCaEQsUUFBUTtvQkFDdENMLFFBQVFpQyxHQUFHLENBQUMsQ0FBQyxzQkFBc0IsRUFBRWEsT0FBTyxDQUFDO29CQUM3QyxPQUFPO3dCQUNMUSxjQUFjTixXQUFXSyxjQUFjO3dCQUN2Q0UsdUJBQXVCUCxXQUFXUSxnQkFBZ0I7b0JBQ3BEO2dCQUNGO2dCQUVBLG1DQUFtQztnQkFDbkN4RCxRQUFRaUMsR0FBRyxDQUFDO2dCQUNaLE9BQU93QixrQkFBa0J2RDtZQUMzQjtZQUVBLHdEQUF3RDtZQUN4REgsc0RBQWNBLENBQUM7WUFFZixJQUFJLENBQUMwQyxJQUFJLENBQUMsc0JBQXNCLEVBQUU7Z0JBQ2hDekMsUUFBUUMsS0FBSyxDQUFDLDZDQUE2Q3dDO2dCQUUzRCxvREFBb0Q7Z0JBQ3BELElBQUlPLFlBQVlLLGdCQUFnQmhELFFBQVE7b0JBQ3RDTCxRQUFRaUMsR0FBRyxDQUFDLENBQUMsc0JBQXNCLEVBQUVhLE9BQU8sQ0FBQztvQkFDN0MsT0FBTzt3QkFDTFEsY0FBY04sV0FBV0ssY0FBYzt3QkFDdkNFLHVCQUF1QlAsV0FBV1EsZ0JBQWdCO29CQUNwRDtnQkFDRjtnQkFFQXhELFFBQVFpQyxHQUFHLENBQUM7Z0JBQ1osT0FBT3dCLGtCQUFrQnZEO1lBQzNCO1lBRUEsTUFBTW1ELGlCQUFpQlosSUFBSSxDQUFDLHNCQUFzQjtZQUNsRCxNQUFNaUIsZ0JBQWdCQyxpQkFBaUJaO1lBRXZDLDBCQUEwQjtZQUMxQixNQUFNYSxnQkFBNkJqQixPQUFPa0IsT0FBTyxDQUFDUixnQkFDL0NTLEdBQUcsQ0FBQyxDQUFDLENBQUN0RCxNQUFNdUQsT0FBTztnQkFDbEIsTUFBTTlDLE9BQU8rQyxXQUFXRCxNQUFNLENBQUMsVUFBVTtnQkFDekMsTUFBTTNDLFFBQVE0QyxXQUFXRCxNQUFNLENBQUMsV0FBVztnQkFDM0MsTUFBTXRDLG1CQUFtQixDQUFFTCxRQUFRSCxJQUFHLElBQUtBLE9BQVE7Z0JBRW5ELE9BQU87b0JBQ0xUO29CQUNBUztvQkFDQUMsTUFBTThDLFdBQVdELE1BQU0sQ0FBQyxVQUFVO29CQUNsQzVDLEtBQUs2QyxXQUFXRCxNQUFNLENBQUMsU0FBUztvQkFDaEMzQztvQkFDQUcsUUFBUTBDLFNBQVNGLE1BQU0sQ0FBQyxZQUFZLEVBQUU7b0JBQ3RDdEMsa0JBQWtCRyxPQUFPSCxpQkFBaUJJLE9BQU8sQ0FBQztvQkFDbERDLFdBQVdMLG9CQUFvQixJQUFJLE9BQWdCO2dCQUNyRDtZQUNGLEVBQ0EsOENBQThDO2FBQzdDeUMsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU0sSUFBSTNELEtBQUsyRCxFQUFFNUQsSUFBSSxFQUFFNkQsT0FBTyxLQUFLLElBQUk1RCxLQUFLMEQsRUFBRTNELElBQUksRUFBRTZELE9BQU8sR0FDckUsdURBQXVEO2FBQ3REQyxLQUFLLENBQUMsR0FBR1o7WUFFWjFELFFBQVFpQyxHQUFHLENBQUMsQ0FBQyx1QkFBdUIsRUFBRTJCLGNBQWN2RCxNQUFNLENBQUMseUJBQXlCLENBQUM7WUFFckYsbUJBQW1CO1lBQ25CLE1BQU1rRSxTQUFTZCxrQkFBa0JHO1lBRWpDLDhCQUE4QjtZQUM5QjlELG9EQUFnQkEsQ0FBQzBFLEdBQUcsQ0FBQzFCLFFBQVE7Z0JBQzNCTyxnQkFBZ0JrQixPQUFPakIsWUFBWTtnQkFDbkNFLGtCQUFrQmUsT0FBT2hCLHFCQUFxQjtZQUNoRDtZQUVBLE9BQU9nQjtRQUNULEVBQUUsT0FBT3RFLE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLHNDQUFzQ0E7WUFFcEQsNERBQTREO1lBQzVERixzREFBY0EsQ0FBQztZQUVmLG9EQUFvRDtZQUNwRCxJQUFJaUQsWUFBWUssZ0JBQWdCaEQsUUFBUTtnQkFDdENMLFFBQVFpQyxHQUFHLENBQUMsQ0FBQyxzQkFBc0IsRUFBRWEsT0FBTyxDQUFDO2dCQUM3QyxPQUFPO29CQUNMUSxjQUFjTixXQUFXSyxjQUFjO29CQUN2Q0UsdUJBQXVCUCxXQUFXUSxnQkFBZ0I7Z0JBQ3BEO1lBQ0Y7WUFFQSxPQUFPQyxrQkFBa0J2RDtRQUMzQjtJQUNGLEVBQUUsT0FBT0QsT0FBTztRQUNkRCxRQUFRQyxLQUFLLENBQUMsZ0NBQWdDQTtRQUU5QyxvREFBb0Q7UUFDcEQsTUFBTStDLGFBQWFsRCxvREFBZ0JBLENBQUNtRCxHQUFHLENBQUNIO1FBQ3hDLElBQUlFLFlBQVlLLGdCQUFnQmhELFFBQVE7WUFDdENMLFFBQVFpQyxHQUFHLENBQUMsQ0FBQyxzQkFBc0IsRUFBRWEsT0FBTyxDQUFDO1lBQzdDLE9BQU87Z0JBQ0xRLGNBQWNOLFdBQVdLLGNBQWM7Z0JBQ3ZDRSx1QkFBdUJQLFdBQVdRLGdCQUFnQjtZQUNwRDtRQUNGO1FBRUEsT0FBT0Msa0JBQWtCdkQ7SUFDM0I7QUFDRjtBQUVBLFNBQVN1RSxxQkFBcUJoQyxJQUFpQjtJQUM3QyxvQ0FBb0M7SUFDcEMsTUFBTWlDLFlBQVkzRCxLQUFLNEQsR0FBRyxJQUFJbEMsS0FBS3FCLEdBQUcsQ0FBQ2MsQ0FBQUEsTUFBT0EsSUFBSXJELE1BQU07SUFDeEQsTUFBTXNELHNCQUFzQjlELEtBQUs0RCxHQUFHLElBQUlsQyxLQUFLcUIsR0FBRyxDQUFDYyxDQUFBQSxNQUFPN0QsS0FBSytELEdBQUcsQ0FBQ0YsSUFBSW5ELGdCQUFnQjtJQUVyRixPQUFPZ0IsS0FBS3FCLEdBQUcsQ0FBQ2MsQ0FBQUEsTUFBUTtZQUN0QixHQUFHQSxHQUFHO1lBQ05HLGFBRUUscURBRHFEO1lBQ3BELElBQUloRSxLQUFLK0QsR0FBRyxDQUFDRixJQUFJbkQsZ0JBQWdCLElBQUlvRCxzQkFDdEMsMENBQTBDO1lBQ3pDLElBQUlELElBQUlyRCxNQUFNLEdBQUdtRDtRQUV0QjtBQUNGO0FBRUEsU0FBU2pCLGtCQUFrQmhCLElBQWlCO0lBQzFDLHFEQUFxRDtJQUNyRCxNQUFNYSxlQUFlO1dBQUliO0tBQUssQ0FBQ3lCLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUN0QyxJQUFJM0QsS0FBSzJELEVBQUU1RCxJQUFJLEVBQUU2RCxPQUFPLEtBQUssSUFBSTVELEtBQUswRCxFQUFFM0QsSUFBSSxFQUFFNkQsT0FBTztJQUd2RCx1Q0FBdUM7SUFDdkMsTUFBTVcsdUJBQXVCUCxxQkFBcUJuQjtJQUVsRCxpQ0FBaUM7SUFDakMsTUFBTUMsd0JBQXdCeUIscUJBQzNCZCxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDQSxFQUFFVyxXQUFXLElBQUksS0FBTVosQ0FBQUEsRUFBRVksV0FBVyxJQUFJLElBQ3hEVCxLQUFLLENBQUMsR0FBRztJQUVaLE9BQU87UUFDTGhCLGNBQWMwQjtRQUNkekI7SUFDRjtBQUNGO0FBRUEsU0FBU0ksaUJBQWlCWixTQUFpQjtJQUN6QyxPQUFRQTtRQUNOLEtBQUs7WUFBTSxPQUFPO1FBQ2xCLEtBQUs7WUFBTSxPQUFPO1FBQ2xCLEtBQUs7WUFBTSxPQUFPO1FBQ2xCLEtBQUs7WUFBTSxPQUFPO1FBQ2xCLEtBQUs7WUFBTSxPQUFPO1FBQ2xCO1lBQVMsT0FBTyxJQUFJLHNCQUFzQjtJQUM1QztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktc3RvY2stdmlkZW8vLi9hcHAvdXRpbHMvYWxwaGF2YW50YWdlLnRzPzBjNTIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQUxQSEFfVkFOVEFHRV9BUElfS0VZID0gcHJvY2Vzcy5lbnYuQUxQSEFfVkFOVEFHRV9BUElfS0VZO1xuY29uc3QgQkFTRV9VUkwgPSAnaHR0cHM6Ly93d3cuYWxwaGF2YW50YWdlLmNvL3F1ZXJ5JztcblxuaW1wb3J0IHsgY29tcGFueURhdGFDYWNoZSwgc2V0UmF0ZUxpbWl0ZWQgfSBmcm9tICcuL2NhY2hlJztcblxuaWYgKCFBTFBIQV9WQU5UQUdFX0FQSV9LRVkpIHtcbiAgY29uc29sZS5lcnJvcignQUxQSEFfVkFOVEFHRV9BUElfS0VZIGlzIG5vdCBzZXQgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzJyk7XG59XG5cbi8vIEdlbmVyYXRlIDkwIGRheXMgb2YgbW9jayBkYXRhIHdpdGggbW9yZSBzaWduaWZpY2FudCBwcmljZSBtb3ZlbWVudHNcbmNvbnN0IE1PQ0tfREFUQTogRGFpbHlEYXRhW10gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA5MCB9LCAoXywgaSkgPT4ge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoKTtcbiAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gaSk7XG4gIFxuICAvLyBCYXNlIHZhbHVlcyB3aXRoIG1vcmUgZHJhbWF0aWMgdmFyaWF0aW9uc1xuICBjb25zdCBiYXNlUHJpY2UgPSAxODIuNTA7XG4gIGNvbnN0IHZvbGF0aWxpdHkgPSA1LjA7IC8vIEluY3JlYXNlZCB2b2xhdGlsaXR5XG4gIFxuICAvLyBHZW5lcmF0ZSBtb3JlIGRyYW1hdGljIHByaWNlIG1vdmVtZW50c1xuICBjb25zdCByYW5kb21DaGFuZ2UgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB2b2xhdGlsaXR5ICogMjsgLy8gRG91YmxlIHRoZSBwb3RlbnRpYWwgY2hhbmdlXG4gIGNvbnN0IG9wZW4gPSBiYXNlUHJpY2UgKyByYW5kb21DaGFuZ2U7XG4gIGNvbnN0IGhpZ2ggPSBvcGVuICsgTWF0aC5yYW5kb20oKSAqIHZvbGF0aWxpdHkgKiAxLjU7XG4gIGNvbnN0IGxvdyA9IG9wZW4gLSBNYXRoLnJhbmRvbSgpICogdm9sYXRpbGl0eSAqIDEuNTtcbiAgY29uc3QgY2xvc2UgPSAob3BlbiArIGhpZ2ggKyBsb3cpIC8gMyArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHZvbGF0aWxpdHk7XG4gIFxuICAvLyBHZW5lcmF0ZSB2b2x1bWUgd2l0aCBvY2Nhc2lvbmFsIHNwaWtlc1xuICBjb25zdCBiYXNlVm9sdW1lID0gNDUwMDAwMDA7XG4gIGNvbnN0IHZvbHVtZVNwaWtlID0gTWF0aC5yYW5kb20oKSA8IDAuMiA/IDMgOiAxOyAvLyAyMCUgY2hhbmNlIG9mIHZvbHVtZSBzcGlrZVxuICBjb25zdCB2b2x1bWUgPSBNYXRoLmZsb29yKGJhc2VWb2x1bWUgKyAoTWF0aC5yYW5kb20oKSAqIDE1MDAwMDAwICogdm9sdW1lU3Bpa2UpKTtcbiAgXG4gIGNvbnN0IHBlcmNlbnRhZ2VDaGFuZ2UgPSAoKGNsb3NlIC0gb3BlbikgLyBvcGVuKSAqIDEwMDtcbiAgXG4gIHJldHVybiB7XG4gICAgZGF0ZTogZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgb3BlbjogTnVtYmVyKG9wZW4udG9GaXhlZCgyKSksXG4gICAgaGlnaDogTnVtYmVyKGhpZ2gudG9GaXhlZCgyKSksXG4gICAgbG93OiBOdW1iZXIobG93LnRvRml4ZWQoMikpLFxuICAgIGNsb3NlOiBOdW1iZXIoY2xvc2UudG9GaXhlZCgyKSksXG4gICAgdm9sdW1lOiB2b2x1bWUsXG4gICAgcGVyY2VudGFnZUNoYW5nZTogTnVtYmVyKHBlcmNlbnRhZ2VDaGFuZ2UudG9GaXhlZCgyKSksXG4gICAgZGlyZWN0aW9uOiBwZXJjZW50YWdlQ2hhbmdlID49IDAgPyAndXAnIDogJ2Rvd24nXG4gIH07XG59KTtcblxuaW50ZXJmYWNlIEFscGhhVmFudGFnZVF1b3RlIHtcbiAgJ0dsb2JhbCBRdW90ZSc6IHtcbiAgICAnMDEuIHN5bWJvbCc6IHN0cmluZztcbiAgICAnMDIuIG9wZW4nOiBzdHJpbmc7XG4gICAgJzAzLiBoaWdoJzogc3RyaW5nO1xuICAgICcwNC4gbG93Jzogc3RyaW5nO1xuICAgICcwNS4gcHJpY2UnOiBzdHJpbmc7XG4gICAgJzA2LiB2b2x1bWUnOiBzdHJpbmc7XG4gICAgJzA3LiBsYXRlc3QgdHJhZGluZyBkYXknOiBzdHJpbmc7XG4gICAgJzA4LiBwcmV2aW91cyBjbG9zZSc6IHN0cmluZztcbiAgICAnMDkuIGNoYW5nZSc6IHN0cmluZztcbiAgICAnMTAuIGNoYW5nZSBwZXJjZW50Jzogc3RyaW5nO1xuICB9O1xuICBJbmZvcm1hdGlvbj86IHN0cmluZzsgLy8gRm9yIGVycm9yIHJlc3BvbnNlc1xufVxuXG5pbnRlcmZhY2UgQWxwaGFWYW50YWdlRGFpbHlUaW1lU2VyaWVzIHtcbiAgJ01ldGEgRGF0YSc6IHtcbiAgICAnMS4gSW5mb3JtYXRpb24nOiBzdHJpbmc7XG4gICAgJzIuIFN5bWJvbCc6IHN0cmluZztcbiAgICAnMy4gTGFzdCBSZWZyZXNoZWQnOiBzdHJpbmc7XG4gICAgJzQuIE91dHB1dCBTaXplJzogc3RyaW5nO1xuICAgICc1LiBUaW1lIFpvbmUnOiBzdHJpbmc7XG4gIH07XG4gICdUaW1lIFNlcmllcyAoRGFpbHkpJzoge1xuICAgIFtkYXRlOiBzdHJpbmddOiB7XG4gICAgICAnMS4gb3Blbic6IHN0cmluZztcbiAgICAgICcyLiBoaWdoJzogc3RyaW5nO1xuICAgICAgJzMuIGxvdyc6IHN0cmluZztcbiAgICAgICc0LiBjbG9zZSc6IHN0cmluZztcbiAgICAgICc1LiB2b2x1bWUnOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgSW5mb3JtYXRpb24/OiBzdHJpbmc7IC8vIEZvciBlcnJvciByZXNwb25zZXNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYWlseURhdGEge1xuICBkYXRlOiBzdHJpbmc7XG4gIG9wZW46IG51bWJlcjtcbiAgaGlnaDogbnVtYmVyO1xuICBsb3c6IG51bWJlcjtcbiAgY2xvc2U6IG51bWJlcjtcbiAgdm9sdW1lOiBudW1iZXI7XG4gIHBlcmNlbnRhZ2VDaGFuZ2U6IG51bWJlcjtcbiAgZGlyZWN0aW9uOiAndXAnIHwgJ2Rvd24nO1xuICBpbXBhY3RTY29yZT86IG51bWJlcjsgLy8gQWRkZWQgaW1wYWN0IHNjb3JlXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc2VkVm9sdW1lRGF0YSB7XG4gIGFsbERhaWx5RGF0YTogRGFpbHlEYXRhW107XG4gIHNpZ25pZmljYW50UHJpY2VNb3ZlczogRGFpbHlEYXRhW107XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KHVybDogc3RyaW5nKSB7XG4gIGNvbnNvbGUubG9nKCdNYWtpbmcgQWxwaGEgVmFudGFnZSBBUEkgcmVxdWVzdDonLCB1cmwucmVwbGFjZShwcm9jZXNzLmVudi5BTFBIQV9WQU5UQUdFX0FQSV9LRVkgfHwgJycsICdbQVBJX0tFWV0nKSk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FscGhhIFZhbnRhZ2UgQVBJIGVycm9yOicsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc29sZS5sb2coJ0FscGhhIFZhbnRhZ2UgQVBJIHJlc3BvbnNlIHN0cnVjdHVyZTonLCBPYmplY3Qua2V5cyhkYXRhKSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gQWxwaGEgVmFudGFnZSBtYWtlUmVxdWVzdDonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERhaWx5VGltZVNlcmllcyhzeW1ib2w6IHN0cmluZywgdGltZWZyYW1lOiBzdHJpbmcgPSAnM20nKTogUHJvbWlzZTxQcm9jZXNzZWRWb2x1bWVEYXRhPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYEdldHRpbmcgZGFpbHkgZGF0YSBmb3IgJHtzeW1ib2x9IHdpdGggdGltZWZyYW1lICR7dGltZWZyYW1lfWApO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgY2FjaGVkIGRhdGEgZm9yIHRoaXMgc3ltYm9sL3RpbWVmcmFtZVxuICAgIGNvbnN0IGNhY2hlZERhdGEgPSBjb21wYW55RGF0YUNhY2hlLmdldChzeW1ib2wpO1xuICAgIFxuICAgIC8vIFVzZSBUSU1FX1NFUklFU19EQUlMWSBBUEkgZW5kcG9pbnQgdG8gZ2V0IGhpc3RvcmljYWwgZGF0YVxuICAgIGNvbnN0IG91dHB1dFNpemUgPSB0aW1lZnJhbWUgPT09ICcxeScgfHwgdGltZWZyYW1lID09PSAnNXknID8gJ2Z1bGwnIDogJ2NvbXBhY3QnO1xuICAgIGNvbnN0IHVybCA9IGAke0JBU0VfVVJMfT9mdW5jdGlvbj1USU1FX1NFUklFU19EQUlMWSZzeW1ib2w9JHtzeW1ib2x9Jm91dHB1dHNpemU9JHtvdXRwdXRTaXplfSZhcGlrZXk9JHtBTFBIQV9WQU5UQUdFX0FQSV9LRVl9YDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YTogQWxwaGFWYW50YWdlRGFpbHlUaW1lU2VyaWVzID0gYXdhaXQgbWFrZVJlcXVlc3QodXJsKTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIHJhdGUgbGltaXRpbmdcbiAgICAgIGlmIChkYXRhLkluZm9ybWF0aW9uPy5pbmNsdWRlcygnQVBJIHJhdGUgbGltaXQnKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnQVBJIHJhdGUgbGltaXRlZCwgdXNpbmcgY2FjaGVkIGRhdGEgaWYgYXZhaWxhYmxlJyk7XG4gICAgICAgIHNldFJhdGVMaW1pdGVkKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBjYWNoZWQgZGF0YSwgdXNlIGl0XG4gICAgICAgIGlmIChjYWNoZWREYXRhPy50aW1lU2VyaWVzRGF0YT8ubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIGNhY2hlZCBkYXRhIGZvciAke3N5bWJvbH1gKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsRGFpbHlEYXRhOiBjYWNoZWREYXRhLnRpbWVTZXJpZXNEYXRhLFxuICAgICAgICAgICAgc2lnbmlmaWNhbnRQcmljZU1vdmVzOiBjYWNoZWREYXRhLnNpZ25pZmljYW50TW92ZXNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBPdGhlcndpc2UgZmFsbCBiYWNrIHRvIG1vY2sgZGF0YVxuICAgICAgICBjb25zb2xlLmxvZygnTm8gY2FjaGVkIGRhdGEgYXZhaWxhYmxlLCB1c2luZyBtb2NrIGRhdGEnKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NWb2x1bWVEYXRhKE1PQ0tfREFUQSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHJhdGUgbGltaXRlZCBmbGFnIHdoZW4gd2Ugc3VjY2Vzc2Z1bGx5IGdldCBkYXRhXG4gICAgICBzZXRSYXRlTGltaXRlZChmYWxzZSk7XG5cbiAgICAgIGlmICghZGF0YVsnVGltZSBTZXJpZXMgKERhaWx5KSddKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgQWxwaGEgVmFudGFnZSByZXNwb25zZSBzdHJ1Y3R1cmU6JywgZGF0YSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBmb3IgY2FjaGVkIGRhdGEgYmVmb3JlIGZhbGxpbmcgYmFjayB0byBtb2NrXG4gICAgICAgIGlmIChjYWNoZWREYXRhPy50aW1lU2VyaWVzRGF0YT8ubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIGNhY2hlZCBkYXRhIGZvciAke3N5bWJvbH1gKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsRGFpbHlEYXRhOiBjYWNoZWREYXRhLnRpbWVTZXJpZXNEYXRhLFxuICAgICAgICAgICAgc2lnbmlmaWNhbnRQcmljZU1vdmVzOiBjYWNoZWREYXRhLnNpZ25pZmljYW50TW92ZXNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnRmFsbGluZyBiYWNrIHRvIG1vY2sgZGF0YScpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc1ZvbHVtZURhdGEoTU9DS19EQVRBKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGltZVNlcmllc0RhdGEgPSBkYXRhWydUaW1lIFNlcmllcyAoRGFpbHkpJ107XG4gICAgICBjb25zdCBkYXlzVG9JbmNsdWRlID0gZ2V0VGltZWZyYW1lRGF5cyh0aW1lZnJhbWUpO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGhpc3RvcmljYWwgZGF0YVxuICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YTogRGFpbHlEYXRhW10gPSBPYmplY3QuZW50cmllcyh0aW1lU2VyaWVzRGF0YSlcbiAgICAgICAgLm1hcCgoW2RhdGUsIHZhbHVlc10pID0+IHtcbiAgICAgICAgICBjb25zdCBvcGVuID0gcGFyc2VGbG9hdCh2YWx1ZXNbJzEuIG9wZW4nXSk7XG4gICAgICAgICAgY29uc3QgY2xvc2UgPSBwYXJzZUZsb2F0KHZhbHVlc1snNC4gY2xvc2UnXSk7XG4gICAgICAgICAgY29uc3QgcGVyY2VudGFnZUNoYW5nZSA9ICgoY2xvc2UgLSBvcGVuKSAvIG9wZW4pICogMTAwO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgb3BlbixcbiAgICAgICAgICAgIGhpZ2g6IHBhcnNlRmxvYXQodmFsdWVzWycyLiBoaWdoJ10pLFxuICAgICAgICAgICAgbG93OiBwYXJzZUZsb2F0KHZhbHVlc1snMy4gbG93J10pLFxuICAgICAgICAgICAgY2xvc2UsXG4gICAgICAgICAgICB2b2x1bWU6IHBhcnNlSW50KHZhbHVlc1snNS4gdm9sdW1lJ10sIDEwKSxcbiAgICAgICAgICAgIHBlcmNlbnRhZ2VDaGFuZ2U6IE51bWJlcihwZXJjZW50YWdlQ2hhbmdlLnRvRml4ZWQoMikpLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBwZXJjZW50YWdlQ2hhbmdlID49IDAgPyAndXAnIGFzIGNvbnN0IDogJ2Rvd24nIGFzIGNvbnN0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgLy8gU29ydCBieSBkYXRlIGRlc2NlbmRpbmcgKG1vc3QgcmVjZW50IGZpcnN0KVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi5kYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmRhdGUpLmdldFRpbWUoKSlcbiAgICAgICAgLy8gTGltaXQgdG8gdGhlIG51bWJlciBvZiBkYXlzIG5lZWRlZCBmb3IgdGhlIHRpbWVmcmFtZVxuICAgICAgICAuc2xpY2UoMCwgZGF5c1RvSW5jbHVkZSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgcHJvY2Vzc2VkICR7cHJvY2Vzc2VkRGF0YS5sZW5ndGh9IGRheXMgb2YgdGltZSBzZXJpZXMgZGF0YWApO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIHRoZSBkYXRhXG4gICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzVm9sdW1lRGF0YShwcm9jZXNzZWREYXRhKTtcbiAgICAgIFxuICAgICAgLy8gQ2FjaGUgdGhlIHN1Y2Nlc3NmdWwgcmVzdWx0XG4gICAgICBjb21wYW55RGF0YUNhY2hlLnNldChzeW1ib2wsIHtcbiAgICAgICAgdGltZVNlcmllc0RhdGE6IHJlc3VsdC5hbGxEYWlseURhdGEsXG4gICAgICAgIHNpZ25pZmljYW50TW92ZXM6IHJlc3VsdC5zaWduaWZpY2FudFByaWNlTW92ZXNcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBmcm9tIEFscGhhIFZhbnRhZ2U6JywgZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBTZXQgcmF0ZSBsaW1pdGVkIGZsYWcgYXMgdGhpcyBtaWdodCBiZSBhIHJhdGUgbGltaXQgZXJyb3JcbiAgICAgIHNldFJhdGVMaW1pdGVkKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgY2FjaGVkIGRhdGEgYmVmb3JlIGZhbGxpbmcgYmFjayB0byBtb2NrXG4gICAgICBpZiAoY2FjaGVkRGF0YT8udGltZVNlcmllc0RhdGE/Lmxlbmd0aCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgVXNpbmcgY2FjaGVkIGRhdGEgZm9yICR7c3ltYm9sfWApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFsbERhaWx5RGF0YTogY2FjaGVkRGF0YS50aW1lU2VyaWVzRGF0YSxcbiAgICAgICAgICBzaWduaWZpY2FudFByaWNlTW92ZXM6IGNhY2hlZERhdGEuc2lnbmlmaWNhbnRNb3Zlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcHJvY2Vzc1ZvbHVtZURhdGEoTU9DS19EQVRBKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2V0RGFpbHlUaW1lU2VyaWVzOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgY2FjaGVkIGRhdGEgYmVmb3JlIGZhbGxpbmcgYmFjayB0byBtb2NrXG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IGNvbXBhbnlEYXRhQ2FjaGUuZ2V0KHN5bWJvbCk7XG4gICAgaWYgKGNhY2hlZERhdGE/LnRpbWVTZXJpZXNEYXRhPy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBVc2luZyBjYWNoZWQgZGF0YSBmb3IgJHtzeW1ib2x9YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbGxEYWlseURhdGE6IGNhY2hlZERhdGEudGltZVNlcmllc0RhdGEsXG4gICAgICAgIHNpZ25pZmljYW50UHJpY2VNb3ZlczogY2FjaGVkRGF0YS5zaWduaWZpY2FudE1vdmVzXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcHJvY2Vzc1ZvbHVtZURhdGEoTU9DS19EQVRBKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJbXBhY3RTY29yZShkYXRhOiBEYWlseURhdGFbXSk6IERhaWx5RGF0YVtdIHtcbiAgLy8gRmluZCBtYXggdmFsdWVzIGZvciBub3JtYWxpemF0aW9uXG4gIGNvbnN0IG1heFZvbHVtZSA9IE1hdGgubWF4KC4uLmRhdGEubWFwKGRheSA9PiBkYXkudm9sdW1lKSk7XG4gIGNvbnN0IG1heEFic1BlcmNlbnRDaGFuZ2UgPSBNYXRoLm1heCguLi5kYXRhLm1hcChkYXkgPT4gTWF0aC5hYnMoZGF5LnBlcmNlbnRhZ2VDaGFuZ2UpKSk7XG5cbiAgcmV0dXJuIGRhdGEubWFwKGRheSA9PiAoe1xuICAgIC4uLmRheSxcbiAgICBpbXBhY3RTY29yZTogKFxuICAgICAgLy8gTm9ybWFsaXplIGFuZCB3ZWlnaHQgcGVyY2VudGFnZSBjaGFuZ2UgKHdlaWdodDogMylcbiAgICAgICgzICogTWF0aC5hYnMoZGF5LnBlcmNlbnRhZ2VDaGFuZ2UpIC8gbWF4QWJzUGVyY2VudENoYW5nZSkgK1xuICAgICAgLy8gTm9ybWFsaXplIGFuZCB3ZWlnaHQgdm9sdW1lICh3ZWlnaHQ6IDIpXG4gICAgICAoMiAqIGRheS52b2x1bWUgLyBtYXhWb2x1bWUpXG4gICAgKVxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NWb2x1bWVEYXRhKGRhdGE6IERhaWx5RGF0YVtdKTogUHJvY2Vzc2VkVm9sdW1lRGF0YSB7XG4gIC8vIFNvcnQgYnkgZGF0ZSBkZXNjZW5kaW5nIHRvIGVuc3VyZSBjb25zaXN0ZW50IG9yZGVyXG4gIGNvbnN0IGFsbERhaWx5RGF0YSA9IFsuLi5kYXRhXS5zb3J0KChhLCBiKSA9PiBcbiAgICBuZXcgRGF0ZShiLmRhdGUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuZGF0ZSkuZ2V0VGltZSgpXG4gICk7XG5cbiAgLy8gQ2FsY3VsYXRlIGltcGFjdCBzY29yZXMgZm9yIGFsbCBkYXlzXG4gIGNvbnN0IGRheXNXaXRoSW1wYWN0U2NvcmVzID0gY2FsY3VsYXRlSW1wYWN0U2NvcmUoYWxsRGFpbHlEYXRhKTtcblxuICAvLyBHZXQgdG9wIDUgZGF5cyBieSBpbXBhY3Qgc2NvcmVcbiAgY29uc3Qgc2lnbmlmaWNhbnRQcmljZU1vdmVzID0gZGF5c1dpdGhJbXBhY3RTY29yZXNcbiAgICAuc29ydCgoYSwgYikgPT4gKGIuaW1wYWN0U2NvcmUgfHwgMCkgLSAoYS5pbXBhY3RTY29yZSB8fCAwKSlcbiAgICAuc2xpY2UoMCwgNSk7XG5cbiAgcmV0dXJuIHtcbiAgICBhbGxEYWlseURhdGE6IGRheXNXaXRoSW1wYWN0U2NvcmVzLFxuICAgIHNpZ25pZmljYW50UHJpY2VNb3Zlc1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUaW1lZnJhbWVEYXlzKHRpbWVmcmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0aW1lZnJhbWUpIHtcbiAgICBjYXNlICcxdyc6IHJldHVybiA3O1xuICAgIGNhc2UgJzFtJzogcmV0dXJuIDMwO1xuICAgIGNhc2UgJzNtJzogcmV0dXJuIDkwO1xuICAgIGNhc2UgJzF5JzogcmV0dXJuIDM2NTtcbiAgICBjYXNlICc1eSc6IHJldHVybiAxODI1O1xuICAgIGRlZmF1bHQ6IHJldHVybiA5MDsgLy8gRGVmYXVsdCB0byAzIG1vbnRoc1xuICB9XG59ICJdLCJuYW1lcyI6WyJBTFBIQV9WQU5UQUdFX0FQSV9LRVkiLCJwcm9jZXNzIiwiZW52IiwiQkFTRV9VUkwiLCJjb21wYW55RGF0YUNhY2hlIiwic2V0UmF0ZUxpbWl0ZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJNT0NLX0RBVEEiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsImRhdGUiLCJEYXRlIiwic2V0RGF0ZSIsImdldERhdGUiLCJiYXNlUHJpY2UiLCJ2b2xhdGlsaXR5IiwicmFuZG9tQ2hhbmdlIiwiTWF0aCIsInJhbmRvbSIsIm9wZW4iLCJoaWdoIiwibG93IiwiY2xvc2UiLCJiYXNlVm9sdW1lIiwidm9sdW1lU3Bpa2UiLCJ2b2x1bWUiLCJmbG9vciIsInBlcmNlbnRhZ2VDaGFuZ2UiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwiTnVtYmVyIiwidG9GaXhlZCIsImRpcmVjdGlvbiIsIm1ha2VSZXF1ZXN0IiwidXJsIiwibG9nIiwicmVwbGFjZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJFcnJvciIsImRhdGEiLCJqc29uIiwiT2JqZWN0Iiwia2V5cyIsImdldERhaWx5VGltZVNlcmllcyIsInN5bWJvbCIsInRpbWVmcmFtZSIsImNhY2hlZERhdGEiLCJnZXQiLCJvdXRwdXRTaXplIiwiSW5mb3JtYXRpb24iLCJpbmNsdWRlcyIsInRpbWVTZXJpZXNEYXRhIiwiYWxsRGFpbHlEYXRhIiwic2lnbmlmaWNhbnRQcmljZU1vdmVzIiwic2lnbmlmaWNhbnRNb3ZlcyIsInByb2Nlc3NWb2x1bWVEYXRhIiwiZGF5c1RvSW5jbHVkZSIsImdldFRpbWVmcmFtZURheXMiLCJwcm9jZXNzZWREYXRhIiwiZW50cmllcyIsIm1hcCIsInZhbHVlcyIsInBhcnNlRmxvYXQiLCJwYXJzZUludCIsInNvcnQiLCJhIiwiYiIsImdldFRpbWUiLCJzbGljZSIsInJlc3VsdCIsInNldCIsImNhbGN1bGF0ZUltcGFjdFNjb3JlIiwibWF4Vm9sdW1lIiwibWF4IiwiZGF5IiwibWF4QWJzUGVyY2VudENoYW5nZSIsImFicyIsImltcGFjdFNjb3JlIiwiZGF5c1dpdGhJbXBhY3RTY29yZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/utils/alphavantage.ts\n");

/***/ }),

/***/ "(rsc)/./app/utils/cache.ts":
/*!****************************!*\
  !*** ./app/utils/cache.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkRateLimit: () => (/* binding */ checkRateLimit),\n/* harmony export */   companyDataCache: () => (/* binding */ companyDataCache),\n/* harmony export */   isRateLimited: () => (/* binding */ isRateLimited),\n/* harmony export */   rateLimitedUntil: () => (/* binding */ rateLimitedUntil),\n/* harmony export */   setRateLimited: () => (/* binding */ setRateLimited)\n/* harmony export */ });\n// Cache utility for storing company data with improved expiration and storage strategies\n// Enhanced LRU cache for company data with expiration times and priority levels\nclass CompanyDataCache {\n    constructor(maxSize = 20){\n        this.cache = new Map();\n        this.maxSize = maxSize;\n        this.accessOrder = [];\n        this.storageAvailable =  false && 0;\n        // Load cache from localStorage if available\n        if (this.storageAvailable) {\n            this.loadFromStorage();\n            // Set up periodic cleanup of expired items\n            setInterval(()=>this.cleanupExpired(), 60000); // Check every minute\n        }\n    }\n    // Get company data from cache\n    get(symbol) {\n        // First check memory cache\n        let data = this.cache.get(symbol);\n        // If not in memory cache but storage is available, try to load from localStorage\n        if (!data && this.storageAvailable) {\n            data = this.loadItemFromStorage(symbol);\n            if (data) {\n                this.cache.set(symbol, data);\n            }\n        }\n        if (data) {\n            // Check if data is expired\n            if (data.expiresAt && data.expiresAt < Date.now()) {\n                console.log(`Cache expired for ${symbol}`);\n                // Keep but mark as stale by moving to end of access order\n                this.accessOrder = this.accessOrder.filter((s)=>s !== symbol);\n                this.accessOrder.push(symbol);\n                return undefined;\n            }\n            // Update access order (move to front)\n            this.accessOrder = this.accessOrder.filter((s)=>s !== symbol);\n            this.accessOrder.unshift(symbol);\n        }\n        return data;\n    }\n    // Store company data in cache\n    set(symbol, data, options = {}) {\n        // Get existing data or create new entry\n        const existingData = this.cache.get(symbol) || {\n            symbol,\n            name: \"\",\n            timeSeriesData: [],\n            significantMoves: [],\n            companyInfo: null,\n            lastUpdated: Date.now(),\n            expiresAt: Date.now() + 24 * 60 * 60 * 1000 // Default 24 hours\n        };\n        // Calculate expiration based on data type and provided options\n        let expirationTime = options.expirationTime;\n        if (!expirationTime) {\n            // Default expiration times based on data type\n            if (data.companyInfo) {\n                // Company profiles change rarely - cache for 7 days\n                expirationTime = 7 * 24 * 60 * 60 * 1000;\n            } else if (data.timeSeriesData && data.timeSeriesData.length > 0) {\n                // Price data - cache for 1 hour during market hours, longer after market close\n                const now = new Date();\n                const isMarketHours = now.getUTCHours() >= 13 && now.getUTCHours() < 20 && // 9AM-4PM ET\n                now.getUTCDay() > 0 && now.getUTCDay() < 6; // Mon-Fri\n                expirationTime = isMarketHours ? 60 * 60 * 1000 : 12 * 60 * 60 * 1000;\n            } else {\n                // Other data - default 24 hours\n                expirationTime = 24 * 60 * 60 * 1000;\n            }\n        }\n        // Merge new data with existing\n        const updatedData = {\n            ...existingData,\n            ...data,\n            lastUpdated: Date.now(),\n            expiresAt: Date.now() + expirationTime\n        };\n        // Store updated data\n        this.cache.set(symbol, updatedData);\n        // Update access order\n        this.accessOrder = this.accessOrder.filter((s)=>s !== symbol);\n        this.accessOrder.unshift(symbol);\n        // Save to localStorage if available\n        if (this.storageAvailable) {\n            this.saveItemToStorage(symbol, updatedData);\n        }\n        // Remove oldest entry if cache exceeds max size\n        if (this.accessOrder.length > this.maxSize) {\n            const oldest = this.accessOrder.pop();\n            if (oldest) {\n                this.cache.delete(oldest);\n                if (this.storageAvailable) {\n                    this.removeItemFromStorage(oldest);\n                }\n            }\n        }\n    }\n    // Clean up expired items\n    cleanupExpired() {\n        const now = Date.now();\n        Array.from(this.cache.entries()).forEach(([symbol, data])=>{\n            if (data.expiresAt && data.expiresAt < now) {\n                console.log(`Auto cleaning expired cache for ${symbol}`);\n            // We don't immediately remove expired items; they'll be removed when they're\n            // at the end of the access order and the cache reaches max size\n            }\n        });\n    }\n    // Save cache to localStorage\n    saveToStorage() {\n        try {\n            // Only store the most recently used items to avoid storage limits\n            const topItems = this.accessOrder.slice(0, 10);\n            const storageData = topItems.map((symbol)=>{\n                const data = this.cache.get(symbol);\n                return [\n                    symbol,\n                    data\n                ];\n            });\n            localStorage.setItem(\"companyDataCache\", JSON.stringify(storageData));\n        } catch (error) {\n            console.error(\"Failed to save cache to localStorage:\", error);\n        }\n    }\n    // Save single item to storage\n    saveItemToStorage(symbol, data) {\n        try {\n            localStorage.setItem(`companyCache_${symbol}`, JSON.stringify(data));\n        } catch (error) {\n            console.error(`Failed to save ${symbol} cache to localStorage:`, error);\n        }\n    }\n    // Remove item from storage\n    removeItemFromStorage(symbol) {\n        try {\n            localStorage.removeItem(`companyCache_${symbol}`);\n        } catch (error) {\n            console.error(`Failed to remove ${symbol} from localStorage:`, error);\n        }\n    }\n    // Load cache from localStorage\n    loadFromStorage() {\n        try {\n            // Load individual stocks (more reliable than bulk loading)\n            const keys = Object.keys(localStorage);\n            const cacheKeys = keys.filter((key)=>key.startsWith(\"companyCache_\"));\n            for (const key of cacheKeys){\n                const symbol = key.replace(\"companyCache_\", \"\");\n                this.loadItemFromStorage(symbol);\n            }\n        } catch (error) {\n            console.error(\"Failed to load cache from localStorage:\", error);\n        }\n    }\n    // Load individual item from storage\n    loadItemFromStorage(symbol) {\n        try {\n            const dataStr = localStorage.getItem(`companyCache_${symbol}`);\n            if (dataStr) {\n                const data = JSON.parse(dataStr);\n                this.cache.set(symbol, data);\n                // Update access order without triggering cleanup\n                this.accessOrder = this.accessOrder.filter((s)=>s !== symbol);\n                this.accessOrder.push(symbol);\n                return data;\n            }\n        } catch (error) {\n            console.error(`Failed to load ${symbol} from localStorage:`, error);\n        }\n        return undefined;\n    }\n    // Get all cached company data sorted by last access\n    getAll() {\n        return this.accessOrder.map((symbol)=>this.cache.get(symbol)).filter(Boolean);\n    }\n    // Get all valid (non-expired) cached company data \n    getAllValid() {\n        const now = Date.now();\n        return this.accessOrder.map((symbol)=>this.cache.get(symbol)).filter((data)=>data && (!data.expiresAt || data.expiresAt > now));\n    }\n    // Check if company exists in cache and is not expired\n    has(symbol) {\n        const data = this.cache.get(symbol);\n        if (!data) return false;\n        if (data.expiresAt && data.expiresAt < Date.now()) return false;\n        return true;\n    }\n    // Check if company exists in cache (even if expired)\n    hasExpired(symbol) {\n        const data = this.cache.get(symbol);\n        return !!data && data.expiresAt < Date.now();\n    }\n    // Get count of cached companies\n    get size() {\n        return this.cache.size;\n    }\n    // Check how much time is left before expiration\n    getTimeToExpiration(symbol) {\n        const data = this.cache.get(symbol);\n        if (!data || !data.expiresAt) return 0;\n        return Math.max(0, data.expiresAt - Date.now());\n    }\n}\n// Create singleton instance with larger capacity\nconst companyDataCache = new CompanyDataCache(20);\n// Function to detect if APIs are rate limited\nlet isRateLimited = false;\nlet rateLimitedUntil = 0;\nfunction setRateLimited(limited, durationMs = 60 * 60 * 1000) {\n    isRateLimited = limited;\n    if (limited) {\n        rateLimitedUntil = Date.now() + durationMs;\n    } else {\n        rateLimitedUntil = 0;\n    }\n    // Store rate limit status to session storage to persist across page refreshes\n    if (false) {}\n}\nfunction checkRateLimit() {\n    if (rateLimitedUntil > 0 && Date.now() > rateLimitedUntil) {\n        // Rate limit period has expired\n        setRateLimited(false);\n    }\n    return isRateLimited;\n}\n// Initialize rate limit status from session storage\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUNDLFFBQVEsQ0FBQ0EsS0FBS0csU0FBUyxFQUFFLE9BQU87UUFDckMsT0FBTzBELEtBQUtDLEdBQUcsQ0FBQyxHQUFHOUQsS0FBS0csU0FBUyxHQUFHQyxLQUFLQyxHQUFHO0lBQzlDO0FBQ0Y7QUFFQSxpREFBaUQ7QUFDMUMsTUFBTTBELG1CQUFtQixJQUFJNUUsaUJBQWlCLElBQUk7QUFFekQsOENBQThDO0FBQ3ZDLElBQUk2RSxnQkFBZ0IsTUFBTTtBQUMxQixJQUFJQyxtQkFBbUIsRUFBRTtBQUV6QixTQUFTQyxlQUFlQyxPQUFnQixFQUFFQyxhQUFxQixLQUFLLEtBQUssSUFBSTtJQUNsRkosZ0JBQWdCRztJQUVoQixJQUFJQSxTQUFTO1FBQ1hGLG1CQUFtQjdELEtBQUtDLEdBQUcsS0FBSytEO0lBQ2xDLE9BQU87UUFDTEgsbUJBQW1CO0lBQ3JCO0lBRUEsOEVBQThFO0lBQzlFLElBQUksS0FBa0IsRUFBYSxFQUdsQztBQUNIO0FBRU8sU0FBU087SUFDZCxJQUFJUCxtQkFBbUIsS0FBSzdELEtBQUtDLEdBQUcsS0FBSzRELGtCQUFrQjtRQUN6RCxnQ0FBZ0M7UUFDaENDLGVBQWU7SUFDakI7SUFDQSxPQUFPRjtBQUNUO0FBRUEsb0RBQW9EO0FBQ3BELElBQUksS0FBa0IsRUFBYSxFQWVsQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXN0b2NrLXZpZGVvLy4vYXBwL3V0aWxzL2NhY2hlLnRzPzhmZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FjaGUgdXRpbGl0eSBmb3Igc3RvcmluZyBjb21wYW55IGRhdGEgd2l0aCBpbXByb3ZlZCBleHBpcmF0aW9uIGFuZCBzdG9yYWdlIHN0cmF0ZWdpZXNcblxuaW50ZXJmYWNlIENhY2hlZENvbXBhbnlEYXRhIHtcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgdGltZVNlcmllc0RhdGE6IGFueVtdO1xuICBzaWduaWZpY2FudE1vdmVzOiBhbnlbXTtcbiAgY29tcGFueUluZm86IGFueTtcbiAgbGFzdFVwZGF0ZWQ6IG51bWJlcjtcbiAgZXhwaXJlc0F0OiBudW1iZXI7IC8vIE5ldyBleHBpcmF0aW9uIHRpbWVzdGFtcFxufVxuXG5pbnRlcmZhY2UgQ2FjaGVPcHRpb25zIHtcbiAgZXhwaXJhdGlvblRpbWU/OiBudW1iZXI7IC8vIFRpbWUgaW4gbWlsbGlzZWNvbmRzIHVudGlsIGRhdGEgZXhwaXJlc1xuICBwcmlvcml0eT86ICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdyc7IC8vIFByaW9yaXR5IGxldmVsIGZvciBjYWNoZSByZXRlbnRpb25cbn1cblxuLy8gRW5oYW5jZWQgTFJVIGNhY2hlIGZvciBjb21wYW55IGRhdGEgd2l0aCBleHBpcmF0aW9uIHRpbWVzIGFuZCBwcmlvcml0eSBsZXZlbHNcbmNsYXNzIENvbXBhbnlEYXRhQ2FjaGUge1xuICBwcml2YXRlIGNhY2hlOiBNYXA8c3RyaW5nLCBDYWNoZWRDb21wYW55RGF0YT47XG4gIHByaXZhdGUgbWF4U2l6ZTogbnVtYmVyO1xuICBwcml2YXRlIGFjY2Vzc09yZGVyOiBzdHJpbmdbXTtcbiAgcHJpdmF0ZSBzdG9yYWdlQXZhaWxhYmxlOiBib29sZWFuO1xuICBcbiAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDIwKSB7IC8vIEluY3JlYXNlZCBtYXggc2l6ZSBmcm9tIDUgdG8gMjBcbiAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubWF4U2l6ZSA9IG1heFNpemU7XG4gICAgdGhpcy5hY2Nlc3NPcmRlciA9IFtdO1xuICAgIHRoaXMuc3RvcmFnZUF2YWlsYWJsZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnO1xuICAgIFxuICAgIC8vIExvYWQgY2FjaGUgZnJvbSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHRoaXMuc3RvcmFnZUF2YWlsYWJsZSkge1xuICAgICAgdGhpcy5sb2FkRnJvbVN0b3JhZ2UoKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IHVwIHBlcmlvZGljIGNsZWFudXAgb2YgZXhwaXJlZCBpdGVtc1xuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5jbGVhbnVwRXhwaXJlZCgpLCA2MDAwMCk7IC8vIENoZWNrIGV2ZXJ5IG1pbnV0ZVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBjb21wYW55IGRhdGEgZnJvbSBjYWNoZVxuICBnZXQoc3ltYm9sOiBzdHJpbmcpOiBDYWNoZWRDb21wYW55RGF0YSB8IHVuZGVmaW5lZCB7XG4gICAgLy8gRmlyc3QgY2hlY2sgbWVtb3J5IGNhY2hlXG4gICAgbGV0IGRhdGEgPSB0aGlzLmNhY2hlLmdldChzeW1ib2wpO1xuICAgIFxuICAgIC8vIElmIG5vdCBpbiBtZW1vcnkgY2FjaGUgYnV0IHN0b3JhZ2UgaXMgYXZhaWxhYmxlLCB0cnkgdG8gbG9hZCBmcm9tIGxvY2FsU3RvcmFnZVxuICAgIGlmICghZGF0YSAmJiB0aGlzLnN0b3JhZ2VBdmFpbGFibGUpIHtcbiAgICAgIGRhdGEgPSB0aGlzLmxvYWRJdGVtRnJvbVN0b3JhZ2Uoc3ltYm9sKTtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KHN5bWJvbCwgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChkYXRhKSB7XG4gICAgICAvLyBDaGVjayBpZiBkYXRhIGlzIGV4cGlyZWRcbiAgICAgIGlmIChkYXRhLmV4cGlyZXNBdCAmJiBkYXRhLmV4cGlyZXNBdCA8IERhdGUubm93KCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coYENhY2hlIGV4cGlyZWQgZm9yICR7c3ltYm9sfWApO1xuICAgICAgICAvLyBLZWVwIGJ1dCBtYXJrIGFzIHN0YWxlIGJ5IG1vdmluZyB0byBlbmQgb2YgYWNjZXNzIG9yZGVyXG4gICAgICAgIHRoaXMuYWNjZXNzT3JkZXIgPSB0aGlzLmFjY2Vzc09yZGVyLmZpbHRlcihzID0+IHMgIT09IHN5bWJvbCk7XG4gICAgICAgIHRoaXMuYWNjZXNzT3JkZXIucHVzaChzeW1ib2wpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVcGRhdGUgYWNjZXNzIG9yZGVyIChtb3ZlIHRvIGZyb250KVxuICAgICAgdGhpcy5hY2Nlc3NPcmRlciA9IHRoaXMuYWNjZXNzT3JkZXIuZmlsdGVyKHMgPT4gcyAhPT0gc3ltYm9sKTtcbiAgICAgIHRoaXMuYWNjZXNzT3JkZXIudW5zaGlmdChzeW1ib2wpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8vIFN0b3JlIGNvbXBhbnkgZGF0YSBpbiBjYWNoZVxuICBzZXQoc3ltYm9sOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8Q2FjaGVkQ29tcGFueURhdGE+LCBvcHRpb25zOiBDYWNoZU9wdGlvbnMgPSB7fSk6IHZvaWQge1xuICAgIC8vIEdldCBleGlzdGluZyBkYXRhIG9yIGNyZWF0ZSBuZXcgZW50cnlcbiAgICBjb25zdCBleGlzdGluZ0RhdGEgPSB0aGlzLmNhY2hlLmdldChzeW1ib2wpIHx8IHtcbiAgICAgIHN5bWJvbCxcbiAgICAgIG5hbWU6ICcnLFxuICAgICAgdGltZVNlcmllc0RhdGE6IFtdLFxuICAgICAgc2lnbmlmaWNhbnRNb3ZlczogW10sXG4gICAgICBjb21wYW55SW5mbzogbnVsbCxcbiAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpLFxuICAgICAgZXhwaXJlc0F0OiBEYXRlLm5vdygpICsgMjQgKiA2MCAqIDYwICogMTAwMCAvLyBEZWZhdWx0IDI0IGhvdXJzXG4gICAgfTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZXhwaXJhdGlvbiBiYXNlZCBvbiBkYXRhIHR5cGUgYW5kIHByb3ZpZGVkIG9wdGlvbnNcbiAgICBsZXQgZXhwaXJhdGlvblRpbWUgPSBvcHRpb25zLmV4cGlyYXRpb25UaW1lO1xuICAgIGlmICghZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIERlZmF1bHQgZXhwaXJhdGlvbiB0aW1lcyBiYXNlZCBvbiBkYXRhIHR5cGVcbiAgICAgIGlmIChkYXRhLmNvbXBhbnlJbmZvKSB7XG4gICAgICAgIC8vIENvbXBhbnkgcHJvZmlsZXMgY2hhbmdlIHJhcmVseSAtIGNhY2hlIGZvciA3IGRheXNcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSA3ICogMjQgKiA2MCAqIDYwICogMTAwMDtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50aW1lU2VyaWVzRGF0YSAmJiBkYXRhLnRpbWVTZXJpZXNEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gUHJpY2UgZGF0YSAtIGNhY2hlIGZvciAxIGhvdXIgZHVyaW5nIG1hcmtldCBob3VycywgbG9uZ2VyIGFmdGVyIG1hcmtldCBjbG9zZVxuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBpc01hcmtldEhvdXJzID0gbm93LmdldFVUQ0hvdXJzKCkgPj0gMTMgJiYgbm93LmdldFVUQ0hvdXJzKCkgPCAyMCAmJiAvLyA5QU0tNFBNIEVUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdy5nZXRVVENEYXkoKSA+IDAgJiYgbm93LmdldFVUQ0RheSgpIDwgNjsgLy8gTW9uLUZyaVxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IGlzTWFya2V0SG91cnMgPyA2MCAqIDYwICogMTAwMCA6IDEyICogNjAgKiA2MCAqIDEwMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlciBkYXRhIC0gZGVmYXVsdCAyNCBob3Vyc1xuICAgICAgICBleHBpcmF0aW9uVGltZSA9IDI0ICogNjAgKiA2MCAqIDEwMDA7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIE1lcmdlIG5ldyBkYXRhIHdpdGggZXhpc3RpbmdcbiAgICBjb25zdCB1cGRhdGVkRGF0YSA9IHtcbiAgICAgIC4uLmV4aXN0aW5nRGF0YSxcbiAgICAgIC4uLmRhdGEsXG4gICAgICBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKSxcbiAgICAgIGV4cGlyZXNBdDogRGF0ZS5ub3coKSArIGV4cGlyYXRpb25UaW1lXG4gICAgfTtcbiAgICBcbiAgICAvLyBTdG9yZSB1cGRhdGVkIGRhdGFcbiAgICB0aGlzLmNhY2hlLnNldChzeW1ib2wsIHVwZGF0ZWREYXRhKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgYWNjZXNzIG9yZGVyXG4gICAgdGhpcy5hY2Nlc3NPcmRlciA9IHRoaXMuYWNjZXNzT3JkZXIuZmlsdGVyKHMgPT4gcyAhPT0gc3ltYm9sKTtcbiAgICB0aGlzLmFjY2Vzc09yZGVyLnVuc2hpZnQoc3ltYm9sKTtcbiAgICBcbiAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICBpZiAodGhpcy5zdG9yYWdlQXZhaWxhYmxlKSB7XG4gICAgICB0aGlzLnNhdmVJdGVtVG9TdG9yYWdlKHN5bWJvbCwgdXBkYXRlZERhdGEpO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZW1vdmUgb2xkZXN0IGVudHJ5IGlmIGNhY2hlIGV4Y2VlZHMgbWF4IHNpemVcbiAgICBpZiAodGhpcy5hY2Nlc3NPcmRlci5sZW5ndGggPiB0aGlzLm1heFNpemUpIHtcbiAgICAgIGNvbnN0IG9sZGVzdCA9IHRoaXMuYWNjZXNzT3JkZXIucG9wKCk7XG4gICAgICBpZiAob2xkZXN0KSB7XG4gICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKG9sZGVzdCk7XG4gICAgICAgIGlmICh0aGlzLnN0b3JhZ2VBdmFpbGFibGUpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUl0ZW1Gcm9tU3RvcmFnZShvbGRlc3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgZXhwaXJlZCBpdGVtc1xuICBwcml2YXRlIGNsZWFudXBFeHBpcmVkKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmNhY2hlLmVudHJpZXMoKSkuZm9yRWFjaCgoW3N5bWJvbCwgZGF0YV0pID0+IHtcbiAgICAgIGlmIChkYXRhLmV4cGlyZXNBdCAmJiBkYXRhLmV4cGlyZXNBdCA8IG5vdykge1xuICAgICAgICBjb25zb2xlLmxvZyhgQXV0byBjbGVhbmluZyBleHBpcmVkIGNhY2hlIGZvciAke3N5bWJvbH1gKTtcbiAgICAgICAgLy8gV2UgZG9uJ3QgaW1tZWRpYXRlbHkgcmVtb3ZlIGV4cGlyZWQgaXRlbXM7IHRoZXknbGwgYmUgcmVtb3ZlZCB3aGVuIHRoZXkncmVcbiAgICAgICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgYWNjZXNzIG9yZGVyIGFuZCB0aGUgY2FjaGUgcmVhY2hlcyBtYXggc2l6ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gU2F2ZSBjYWNoZSB0byBsb2NhbFN0b3JhZ2VcbiAgcHJpdmF0ZSBzYXZlVG9TdG9yYWdlKCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICAvLyBPbmx5IHN0b3JlIHRoZSBtb3N0IHJlY2VudGx5IHVzZWQgaXRlbXMgdG8gYXZvaWQgc3RvcmFnZSBsaW1pdHNcbiAgICAgIGNvbnN0IHRvcEl0ZW1zID0gdGhpcy5hY2Nlc3NPcmRlci5zbGljZSgwLCAxMCk7XG4gICAgICBjb25zdCBzdG9yYWdlRGF0YSA9IHRvcEl0ZW1zLm1hcChzeW1ib2wgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5jYWNoZS5nZXQoc3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIFtzeW1ib2wsIGRhdGFdO1xuICAgICAgfSk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY29tcGFueURhdGFDYWNoZScsIEpTT04uc3RyaW5naWZ5KHN0b3JhZ2VEYXRhKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIGNhY2hlIHRvIGxvY2FsU3RvcmFnZTonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gU2F2ZSBzaW5nbGUgaXRlbSB0byBzdG9yYWdlXG4gIHByaXZhdGUgc2F2ZUl0ZW1Ub1N0b3JhZ2Uoc3ltYm9sOiBzdHJpbmcsIGRhdGE6IENhY2hlZENvbXBhbnlEYXRhKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGBjb21wYW55Q2FjaGVfJHtzeW1ib2x9YCwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gc2F2ZSAke3N5bWJvbH0gY2FjaGUgdG8gbG9jYWxTdG9yYWdlOmAsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgaXRlbSBmcm9tIHN0b3JhZ2VcbiAgcHJpdmF0ZSByZW1vdmVJdGVtRnJvbVN0b3JhZ2Uoc3ltYm9sOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oYGNvbXBhbnlDYWNoZV8ke3N5bWJvbH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHJlbW92ZSAke3N5bWJvbH0gZnJvbSBsb2NhbFN0b3JhZ2U6YCwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgY2FjaGUgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgcHJpdmF0ZSBsb2FkRnJvbVN0b3JhZ2UoKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIExvYWQgaW5kaXZpZHVhbCBzdG9ja3MgKG1vcmUgcmVsaWFibGUgdGhhbiBidWxrIGxvYWRpbmcpXG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKTtcbiAgICAgIGNvbnN0IGNhY2hlS2V5cyA9IGtleXMuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgnY29tcGFueUNhY2hlXycpKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgY2FjaGVLZXlzKSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IGtleS5yZXBsYWNlKCdjb21wYW55Q2FjaGVfJywgJycpO1xuICAgICAgICB0aGlzLmxvYWRJdGVtRnJvbVN0b3JhZ2Uoc3ltYm9sKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgY2FjaGUgZnJvbSBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgaW5kaXZpZHVhbCBpdGVtIGZyb20gc3RvcmFnZVxuICBwcml2YXRlIGxvYWRJdGVtRnJvbVN0b3JhZ2Uoc3ltYm9sOiBzdHJpbmcpOiBDYWNoZWRDb21wYW55RGF0YSB8IHVuZGVmaW5lZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGFTdHIgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShgY29tcGFueUNhY2hlXyR7c3ltYm9sfWApO1xuICAgICAgaWYgKGRhdGFTdHIpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZGF0YVN0cikgYXMgQ2FjaGVkQ29tcGFueURhdGE7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KHN5bWJvbCwgZGF0YSk7XG4gICAgICAgIC8vIFVwZGF0ZSBhY2Nlc3Mgb3JkZXIgd2l0aG91dCB0cmlnZ2VyaW5nIGNsZWFudXBcbiAgICAgICAgdGhpcy5hY2Nlc3NPcmRlciA9IHRoaXMuYWNjZXNzT3JkZXIuZmlsdGVyKHMgPT4gcyAhPT0gc3ltYm9sKTtcbiAgICAgICAgdGhpcy5hY2Nlc3NPcmRlci5wdXNoKHN5bWJvbCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCAke3N5bWJvbH0gZnJvbSBsb2NhbFN0b3JhZ2U6YCwgZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gR2V0IGFsbCBjYWNoZWQgY29tcGFueSBkYXRhIHNvcnRlZCBieSBsYXN0IGFjY2Vzc1xuICBnZXRBbGwoKTogQ2FjaGVkQ29tcGFueURhdGFbXSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjZXNzT3JkZXIubWFwKHN5bWJvbCA9PiB0aGlzLmNhY2hlLmdldChzeW1ib2wpISkuZmlsdGVyKEJvb2xlYW4pO1xuICB9XG5cbiAgLy8gR2V0IGFsbCB2YWxpZCAobm9uLWV4cGlyZWQpIGNhY2hlZCBjb21wYW55IGRhdGEgXG4gIGdldEFsbFZhbGlkKCk6IENhY2hlZENvbXBhbnlEYXRhW10ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHRoaXMuYWNjZXNzT3JkZXJcbiAgICAgIC5tYXAoc3ltYm9sID0+IHRoaXMuY2FjaGUuZ2V0KHN5bWJvbCkhKVxuICAgICAgLmZpbHRlcihkYXRhID0+IGRhdGEgJiYgKCFkYXRhLmV4cGlyZXNBdCB8fCBkYXRhLmV4cGlyZXNBdCA+IG5vdykpO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgY29tcGFueSBleGlzdHMgaW4gY2FjaGUgYW5kIGlzIG5vdCBleHBpcmVkXG4gIGhhcyhzeW1ib2w6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNhY2hlLmdldChzeW1ib2wpO1xuICAgIGlmICghZGF0YSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkYXRhLmV4cGlyZXNBdCAmJiBkYXRhLmV4cGlyZXNBdCA8IERhdGUubm93KCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGNvbXBhbnkgZXhpc3RzIGluIGNhY2hlIChldmVuIGlmIGV4cGlyZWQpXG4gIGhhc0V4cGlyZWQoc3ltYm9sOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jYWNoZS5nZXQoc3ltYm9sKTtcbiAgICByZXR1cm4gISFkYXRhICYmIGRhdGEuZXhwaXJlc0F0IDwgRGF0ZS5ub3coKTtcbiAgfVxuXG4gIC8vIEdldCBjb3VudCBvZiBjYWNoZWQgY29tcGFuaWVzXG4gIGdldCBzaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGUuc2l6ZTtcbiAgfVxuXG4gIC8vIENoZWNrIGhvdyBtdWNoIHRpbWUgaXMgbGVmdCBiZWZvcmUgZXhwaXJhdGlvblxuICBnZXRUaW1lVG9FeHBpcmF0aW9uKHN5bWJvbDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jYWNoZS5nZXQoc3ltYm9sKTtcbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEuZXhwaXJlc0F0KSByZXR1cm4gMDtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgZGF0YS5leHBpcmVzQXQgLSBEYXRlLm5vdygpKTtcbiAgfVxufVxuXG4vLyBDcmVhdGUgc2luZ2xldG9uIGluc3RhbmNlIHdpdGggbGFyZ2VyIGNhcGFjaXR5XG5leHBvcnQgY29uc3QgY29tcGFueURhdGFDYWNoZSA9IG5ldyBDb21wYW55RGF0YUNhY2hlKDIwKTtcblxuLy8gRnVuY3Rpb24gdG8gZGV0ZWN0IGlmIEFQSXMgYXJlIHJhdGUgbGltaXRlZFxuZXhwb3J0IGxldCBpc1JhdGVMaW1pdGVkID0gZmFsc2U7XG5leHBvcnQgbGV0IHJhdGVMaW1pdGVkVW50aWwgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0UmF0ZUxpbWl0ZWQobGltaXRlZDogYm9vbGVhbiwgZHVyYXRpb25NczogbnVtYmVyID0gNjAgKiA2MCAqIDEwMDApOiB2b2lkIHtcbiAgaXNSYXRlTGltaXRlZCA9IGxpbWl0ZWQ7XG4gIFxuICBpZiAobGltaXRlZCkge1xuICAgIHJhdGVMaW1pdGVkVW50aWwgPSBEYXRlLm5vdygpICsgZHVyYXRpb25NcztcbiAgfSBlbHNlIHtcbiAgICByYXRlTGltaXRlZFVudGlsID0gMDtcbiAgfVxuICBcbiAgLy8gU3RvcmUgcmF0ZSBsaW1pdCBzdGF0dXMgdG8gc2Vzc2lvbiBzdG9yYWdlIHRvIHBlcnNpc3QgYWNyb3NzIHBhZ2UgcmVmcmVzaGVzXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdpc1JhdGVMaW1pdGVkJywgU3RyaW5nKGxpbWl0ZWQpKTtcbiAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgncmF0ZUxpbWl0ZWRVbnRpbCcsIFN0cmluZyhyYXRlTGltaXRlZFVudGlsKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmF0ZUxpbWl0KCk6IGJvb2xlYW4ge1xuICBpZiAocmF0ZUxpbWl0ZWRVbnRpbCA+IDAgJiYgRGF0ZS5ub3coKSA+IHJhdGVMaW1pdGVkVW50aWwpIHtcbiAgICAvLyBSYXRlIGxpbWl0IHBlcmlvZCBoYXMgZXhwaXJlZFxuICAgIHNldFJhdGVMaW1pdGVkKGZhbHNlKTtcbiAgfVxuICByZXR1cm4gaXNSYXRlTGltaXRlZDtcbn1cblxuLy8gSW5pdGlhbGl6ZSByYXRlIGxpbWl0IHN0YXR1cyBmcm9tIHNlc3Npb24gc3RvcmFnZVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGNvbnN0IHN0b3JlZFN0YXR1cyA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdpc1JhdGVMaW1pdGVkJyk7XG4gIGNvbnN0IHN0b3JlZFVudGlsID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ3JhdGVMaW1pdGVkVW50aWwnKTtcbiAgXG4gIGlmIChzdG9yZWRTdGF0dXMpIHtcbiAgICBpc1JhdGVMaW1pdGVkID0gc3RvcmVkU3RhdHVzID09PSAndHJ1ZSc7XG4gIH1cbiAgXG4gIGlmIChzdG9yZWRVbnRpbCkge1xuICAgIHJhdGVMaW1pdGVkVW50aWwgPSBwYXJzZUludChzdG9yZWRVbnRpbCwgMTApO1xuICAgIC8vIENoZWNrIGlmIHJhdGUgbGltaXQgaGFzIGV4cGlyZWRcbiAgICBpZiAocmF0ZUxpbWl0ZWRVbnRpbCA+IDAgJiYgRGF0ZS5ub3coKSA+IHJhdGVMaW1pdGVkVW50aWwpIHtcbiAgICAgIHNldFJhdGVMaW1pdGVkKGZhbHNlKTtcbiAgICB9XG4gIH1cbn0gIl0sIm5hbWVzIjpbIkNvbXBhbnlEYXRhQ2FjaGUiLCJjb25zdHJ1Y3RvciIsIm1heFNpemUiLCJjYWNoZSIsIk1hcCIsImFjY2Vzc09yZGVyIiwic3RvcmFnZUF2YWlsYWJsZSIsImxvY2FsU3RvcmFnZSIsImxvYWRGcm9tU3RvcmFnZSIsInNldEludGVydmFsIiwiY2xlYW51cEV4cGlyZWQiLCJnZXQiLCJzeW1ib2wiLCJkYXRhIiwibG9hZEl0ZW1Gcm9tU3RvcmFnZSIsInNldCIsImV4cGlyZXNBdCIsIkRhdGUiLCJub3ciLCJjb25zb2xlIiwibG9nIiwiZmlsdGVyIiwicyIsInB1c2giLCJ1bmRlZmluZWQiLCJ1bnNoaWZ0Iiwib3B0aW9ucyIsImV4aXN0aW5nRGF0YSIsIm5hbWUiLCJ0aW1lU2VyaWVzRGF0YSIsInNpZ25pZmljYW50TW92ZXMiLCJjb21wYW55SW5mbyIsImxhc3RVcGRhdGVkIiwiZXhwaXJhdGlvblRpbWUiLCJsZW5ndGgiLCJpc01hcmtldEhvdXJzIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENEYXkiLCJ1cGRhdGVkRGF0YSIsInNhdmVJdGVtVG9TdG9yYWdlIiwib2xkZXN0IiwicG9wIiwiZGVsZXRlIiwicmVtb3ZlSXRlbUZyb21TdG9yYWdlIiwiQXJyYXkiLCJmcm9tIiwiZW50cmllcyIsImZvckVhY2giLCJzYXZlVG9TdG9yYWdlIiwidG9wSXRlbXMiLCJzbGljZSIsInN0b3JhZ2VEYXRhIiwibWFwIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsInJlbW92ZUl0ZW0iLCJrZXlzIiwiT2JqZWN0IiwiY2FjaGVLZXlzIiwia2V5Iiwic3RhcnRzV2l0aCIsInJlcGxhY2UiLCJkYXRhU3RyIiwiZ2V0SXRlbSIsInBhcnNlIiwiZ2V0QWxsIiwiQm9vbGVhbiIsImdldEFsbFZhbGlkIiwiaGFzIiwiaGFzRXhwaXJlZCIsInNpemUiLCJnZXRUaW1lVG9FeHBpcmF0aW9uIiwiTWF0aCIsIm1heCIsImNvbXBhbnlEYXRhQ2FjaGUiLCJpc1JhdGVMaW1pdGVkIiwicmF0ZUxpbWl0ZWRVbnRpbCIsInNldFJhdGVMaW1pdGVkIiwibGltaXRlZCIsImR1cmF0aW9uTXMiLCJ3aW5kb3ciLCJzZXNzaW9uU3RvcmFnZSIsIlN0cmluZyIsImNoZWNrUmF0ZUxpbWl0Iiwic3RvcmVkU3RhdHVzIiwic3RvcmVkVW50aWwiLCJwYXJzZUludCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/utils/cache.ts\n");

/***/ }),

/***/ "(rsc)/./app/utils/finnhub.ts":
/*!******************************!*\
  !*** ./app/utils/finnhub.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeWebSocket: () => (/* binding */ closeWebSocket),\n/* harmony export */   connectWebSocket: () => (/* binding */ connectWebSocket),\n/* harmony export */   formatDateYYYYMMDD: () => (/* binding */ formatDateYYYYMMDD),\n/* harmony export */   getCompanyNews: () => (/* binding */ getCompanyNews),\n/* harmony export */   getCompanyProfile: () => (/* binding */ getCompanyProfile),\n/* harmony export */   getStockCandles: () => (/* binding */ getStockCandles),\n/* harmony export */   getTimeframeTimestamps: () => (/* binding */ getTimeframeTimestamps),\n/* harmony export */   searchSymbol: () => (/* binding */ searchSymbol),\n/* harmony export */   subscribeToSymbol: () => (/* binding */ subscribeToSymbol),\n/* harmony export */   unsubscribeFromSymbol: () => (/* binding */ unsubscribeFromSymbol)\n/* harmony export */ });\n/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cache */ \"(rsc)/./app/utils/cache.ts\");\nconst FINNHUB_API_KEY = process.env.FINNHUB_API_KEY;\nconst BASE_URL = \"https://finnhub.io/api/v1\";\n\nif (!FINNHUB_API_KEY) {\n    console.error(\"FINNHUB_API_KEY is not set in environment variables\");\n}\nasync function makeRequest(url) {\n    console.log(\"Making Finnhub API request:\", url);\n    try {\n        const response = await fetch(url);\n        // Check for rate limiting by status code\n        if (response.status === 429) {\n            console.error(\"Finnhub API rate limit reached\");\n            (0,_cache__WEBPACK_IMPORTED_MODULE_0__.setRateLimited)(true);\n            throw new Error(\"Rate limit reached\");\n        }\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        // Reset rate limited flag when we successfully get data\n        (0,_cache__WEBPACK_IMPORTED_MODULE_0__.setRateLimited)(false);\n        console.log(\"Finnhub API response:\", data);\n        return data;\n    } catch (error) {\n        console.error(\"Error making Finnhub API request:\", error);\n        if (error.message === \"Rate limit reached\") {\n            throw error; // Re-throw to handle it in the calling function\n        }\n        // For other errors, let's assume API might be having issues\n        (0,_cache__WEBPACK_IMPORTED_MODULE_0__.setRateLimited)(true);\n        throw error;\n    }\n}\nasync function getStockCandles(symbol, from, to, resolution = \"D\") {\n    const url = `${BASE_URL}/stock/candle?symbol=${symbol}&resolution=${resolution}&from=${from}&to=${to}&token=${FINNHUB_API_KEY}`;\n    return makeRequest(url);\n}\nasync function getCompanyProfile(symbol) {\n    try {\n        // Try to get from cache first if rate limited\n        const cachedData = _cache__WEBPACK_IMPORTED_MODULE_0__.companyDataCache.get(symbol);\n        if (cachedData?.companyInfo) {\n            console.log(`Using cached company info for ${symbol}`);\n            return cachedData.companyInfo;\n        }\n        const url = `${BASE_URL}/stock/profile2?symbol=${symbol}&token=${FINNHUB_API_KEY}`;\n        const data = await makeRequest(url);\n        // Cache the company info\n        if (data && data.name) {\n            _cache__WEBPACK_IMPORTED_MODULE_0__.companyDataCache.set(symbol, {\n                name: data.name,\n                companyInfo: data\n            });\n        }\n        return data;\n    } catch (error) {\n        console.error(`Error getting company profile for ${symbol}:`, error);\n        // If we have cached data, use it\n        const cachedData = _cache__WEBPACK_IMPORTED_MODULE_0__.companyDataCache.get(symbol);\n        if (cachedData?.companyInfo) {\n            console.log(`Using cached company info for ${symbol}`);\n            return cachedData.companyInfo;\n        }\n        // Otherwise throw the error\n        throw error;\n    }\n}\nasync function getCompanyNews(symbol, from, to) {\n    try {\n        const url = `${BASE_URL}/company-news?symbol=${symbol}&from=${from}&to=${to}&token=${FINNHUB_API_KEY}`;\n        return makeRequest(url);\n    } catch (error) {\n        console.error(`Error getting company news for ${symbol}:`, error);\n        // Return empty array on error rather than throwing\n        return [];\n    }\n}\nasync function searchSymbol(query) {\n    const url = `${BASE_URL}/search?q=${query}&token=${FINNHUB_API_KEY}`;\n    const data = await makeRequest(url);\n    return data.result || [];\n}\nfunction getTimeframeTimestamps(timeframe) {\n    const now = new Date();\n    const to = Math.floor(now.getTime() / 1000);\n    let from;\n    switch(timeframe){\n        case \"1w\":\n            from = to - 7 * 24 * 60 * 60;\n            break;\n        case \"1m\":\n            from = to - 30 * 24 * 60 * 60;\n            break;\n        case \"3m\":\n            from = to - 90 * 24 * 60 * 60;\n            break;\n        case \"1y\":\n            from = to - 365 * 24 * 60 * 60;\n            break;\n        case \"5y\":\n            from = to - 5 * 365 * 24 * 60 * 60;\n            break;\n        default:\n            from = to - 30 * 24 * 60 * 60;\n    }\n    return {\n        from,\n        to\n    };\n}\nfunction formatDateYYYYMMDD(date) {\n    return date.toISOString().split(\"T\")[0];\n}\nlet ws = null;\nlet subscribers = new Map();\nlet pendingSubscriptions = new Set();\nlet isConnecting = false;\nfunction connectWebSocket() {\n    if (ws?.readyState === WebSocket.OPEN) {\n        return Promise.resolve(ws);\n    }\n    if (isConnecting) {\n        return new Promise((resolve)=>{\n            const checkConnection = setInterval(()=>{\n                if (ws?.readyState === WebSocket.OPEN) {\n                    clearInterval(checkConnection);\n                    resolve(ws);\n                }\n            }, 100);\n        });\n    }\n    isConnecting = true;\n    return new Promise((resolve, reject)=>{\n        ws = new WebSocket(`wss://ws.finnhub.io?token=${FINNHUB_API_KEY}`);\n        ws.onopen = ()=>{\n            console.log(\"Finnhub WebSocket connected\");\n            isConnecting = false;\n            // Subscribe to any pending symbols\n            pendingSubscriptions.forEach((symbol)=>{\n                ws?.send(JSON.stringify({\n                    type: \"subscribe\",\n                    symbol\n                }));\n            });\n            pendingSubscriptions.clear();\n            resolve(ws);\n        };\n        ws.onmessage = (event)=>{\n            const message = JSON.parse(event.data);\n            if (message.type === \"trade\") {\n                message.data.forEach((trade)=>{\n                    const symbol = trade.s;\n                    const callbacks = subscribers.get(symbol);\n                    if (callbacks) {\n                        callbacks.forEach((callback)=>callback(trade));\n                    }\n                });\n            }\n        };\n        ws.onerror = (error)=>{\n            console.error(\"Finnhub WebSocket error:\", error);\n            isConnecting = false;\n            reject(error);\n        };\n        ws.onclose = ()=>{\n            console.log(\"Finnhub WebSocket connection closed\");\n            isConnecting = false;\n            ws = null;\n            // Keep track of current subscriptions for reconnection\n            subscribers.forEach((_, symbol)=>{\n                pendingSubscriptions.add(symbol);\n            });\n        };\n    });\n}\nasync function subscribeToSymbol(symbol, callback) {\n    try {\n        const socket = await connectWebSocket();\n        if (!subscribers.has(symbol)) {\n            subscribers.set(symbol, new Set());\n            socket.send(JSON.stringify({\n                type: \"subscribe\",\n                symbol\n            }));\n        }\n        subscribers.get(symbol)?.add(callback);\n    } catch (error) {\n        console.error(`Error subscribing to ${symbol}:`, error);\n    }\n}\nasync function unsubscribeFromSymbol(symbol, callback) {\n    if (!ws || ws.readyState !== WebSocket.OPEN) return;\n    try {\n        if (callback) {\n            subscribers.get(symbol)?.delete(callback);\n            if (subscribers.get(symbol)?.size === 0) {\n                ws.send(JSON.stringify({\n                    type: \"unsubscribe\",\n                    symbol\n                }));\n                subscribers.delete(symbol);\n                pendingSubscriptions.delete(symbol);\n            }\n        } else {\n            ws.send(JSON.stringify({\n                type: \"unsubscribe\",\n                symbol\n            }));\n            subscribers.delete(symbol);\n            pendingSubscriptions.delete(symbol);\n        }\n    } catch (error) {\n        console.error(`Error unsubscribing from ${symbol}:`, error);\n    }\n}\nfunction closeWebSocket() {\n    if (ws) {\n        subscribers.clear();\n        pendingSubscriptions.clear();\n        ws.close();\n        ws = null;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3ZDdkMsR0FBR2tCLElBQUksQ0FBQ0MsS0FBS0MsU0FBUyxDQUFDO29CQUFFQyxNQUFNO29CQUFlOUM7Z0JBQU87Z0JBQ3JEMEIsWUFBWXFDLE1BQU0sQ0FBQy9EO2dCQUNuQjRCLHFCQUFxQm1DLE1BQU0sQ0FBQy9EO1lBQzlCO1FBQ0YsT0FBTztZQUNMeUIsR0FBR2tCLElBQUksQ0FBQ0MsS0FBS0MsU0FBUyxDQUFDO2dCQUFFQyxNQUFNO2dCQUFlOUM7WUFBTztZQUNyRDBCLFlBQVlxQyxNQUFNLENBQUMvRDtZQUNuQjRCLHFCQUFxQm1DLE1BQU0sQ0FBQy9EO1FBQzlCO0lBQ0YsRUFBRSxPQUFPYixPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyxDQUFDLHlCQUF5QixFQUFFYSxPQUFPLENBQUMsQ0FBQyxFQUFFYjtJQUN2RDtBQUNGO0FBRU8sU0FBUzhFO0lBQ2QsSUFBSXhDLElBQUk7UUFDTkMsWUFBWXFCLEtBQUs7UUFDakJuQixxQkFBcUJtQixLQUFLO1FBQzFCdEIsR0FBR3lDLEtBQUs7UUFDUnpDLEtBQUs7SUFDUDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktc3RvY2stdmlkZW8vLi9hcHAvdXRpbHMvZmlubmh1Yi50cz9mNmY5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEZJTk5IVUJfQVBJX0tFWSA9IHByb2Nlc3MuZW52LkZJTk5IVUJfQVBJX0tFWTtcbmNvbnN0IEJBU0VfVVJMID0gJ2h0dHBzOi8vZmlubmh1Yi5pby9hcGkvdjEnO1xuaW1wb3J0IHsgY29tcGFueURhdGFDYWNoZSwgc2V0UmF0ZUxpbWl0ZWQgfSBmcm9tICcuL2NhY2hlJztcblxuaWYgKCFGSU5OSFVCX0FQSV9LRVkpIHtcbiAgY29uc29sZS5lcnJvcignRklOTkhVQl9BUElfS0VZIGlzIG5vdCBzZXQgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzJyk7XG59XG5cbmludGVyZmFjZSBTdG9ja0NhbmRsZSB7XG4gIGM6IG51bWJlcltdOyAvLyBDbG9zZSBwcmljZXNcbiAgaDogbnVtYmVyW107IC8vIEhpZ2ggcHJpY2VzXG4gIGw6IG51bWJlcltdOyAvLyBMb3cgcHJpY2VzXG4gIG86IG51bWJlcltdOyAvLyBPcGVuIHByaWNlc1xuICBzOiBzdHJpbmc7ICAgLy8gU3RhdHVzXG4gIHQ6IG51bWJlcltdOyAvLyBUaW1lc3RhbXBzXG4gIHY6IG51bWJlcltdOyAvLyBWb2x1bWUgZGF0YVxuICBlcnJvcj86IHN0cmluZzsgLy8gRXJyb3IgbWVzc2FnZSBmcm9tIEFQSVxufVxuXG5pbnRlcmZhY2UgQ29tcGFueVByb2ZpbGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIG1hcmtldENhcGl0YWxpemF0aW9uOiBudW1iZXI7XG4gIHNoYXJlT3V0c3RhbmRpbmc6IG51bWJlcjtcbiAgaW5kdXN0cnk6IHN0cmluZztcbiAgc2VjdG9yOiBzdHJpbmc7XG4gIC8vIC4uLiBvdGhlciBmaWVsZHNcbn1cblxuaW50ZXJmYWNlIE5ld3NJdGVtIHtcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgZGF0ZXRpbWU6IG51bWJlcjtcbiAgaGVhZGxpbmU6IHN0cmluZztcbiAgaWQ6IG51bWJlcjtcbiAgaW1hZ2U6IHN0cmluZztcbiAgcmVsYXRlZDogc3RyaW5nO1xuICBzb3VyY2U6IHN0cmluZztcbiAgc3VtbWFyeTogc3RyaW5nO1xuICB1cmw6IHN0cmluZztcbn1cblxuYXN5bmMgZnVuY3Rpb24gbWFrZVJlcXVlc3QodXJsOiBzdHJpbmcpIHtcbiAgY29uc29sZS5sb2coJ01ha2luZyBGaW5uaHViIEFQSSByZXF1ZXN0OicsIHVybCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIFxuICAgIC8vIENoZWNrIGZvciByYXRlIGxpbWl0aW5nIGJ5IHN0YXR1cyBjb2RlXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGaW5uaHViIEFQSSByYXRlIGxpbWl0IHJlYWNoZWQnKTtcbiAgICAgIHNldFJhdGVMaW1pdGVkKHRydWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYXRlIGxpbWl0IHJlYWNoZWQnKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIC8vIFJlc2V0IHJhdGUgbGltaXRlZCBmbGFnIHdoZW4gd2Ugc3VjY2Vzc2Z1bGx5IGdldCBkYXRhXG4gICAgc2V0UmF0ZUxpbWl0ZWQoZmFsc2UpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdGaW5uaHViIEFQSSByZXNwb25zZTonLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1ha2luZyBGaW5uaHViIEFQSSByZXF1ZXN0OicsIGVycm9yKTtcbiAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gJ1JhdGUgbGltaXQgcmVhY2hlZCcpIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBSZS10aHJvdyB0byBoYW5kbGUgaXQgaW4gdGhlIGNhbGxpbmcgZnVuY3Rpb25cbiAgICB9XG4gICAgLy8gRm9yIG90aGVyIGVycm9ycywgbGV0J3MgYXNzdW1lIEFQSSBtaWdodCBiZSBoYXZpbmcgaXNzdWVzXG4gICAgc2V0UmF0ZUxpbWl0ZWQodHJ1ZSk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0b2NrQ2FuZGxlcyhzeW1ib2w6IHN0cmluZywgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCByZXNvbHV0aW9uID0gJ0QnKTogUHJvbWlzZTxTdG9ja0NhbmRsZT4ge1xuICBjb25zdCB1cmwgPSBgJHtCQVNFX1VSTH0vc3RvY2svY2FuZGxlP3N5bWJvbD0ke3N5bWJvbH0mcmVzb2x1dGlvbj0ke3Jlc29sdXRpb259JmZyb209JHtmcm9tfSZ0bz0ke3RvfSZ0b2tlbj0ke0ZJTk5IVUJfQVBJX0tFWX1gO1xuICByZXR1cm4gbWFrZVJlcXVlc3QodXJsKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbXBhbnlQcm9maWxlKHN5bWJvbDogc3RyaW5nKTogUHJvbWlzZTxDb21wYW55UHJvZmlsZT4ge1xuICB0cnkge1xuICAgIC8vIFRyeSB0byBnZXQgZnJvbSBjYWNoZSBmaXJzdCBpZiByYXRlIGxpbWl0ZWRcbiAgICBjb25zdCBjYWNoZWREYXRhID0gY29tcGFueURhdGFDYWNoZS5nZXQoc3ltYm9sKTtcbiAgICBpZiAoY2FjaGVkRGF0YT8uY29tcGFueUluZm8pIHtcbiAgICAgIGNvbnNvbGUubG9nKGBVc2luZyBjYWNoZWQgY29tcGFueSBpbmZvIGZvciAke3N5bWJvbH1gKTtcbiAgICAgIHJldHVybiBjYWNoZWREYXRhLmNvbXBhbnlJbmZvO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB1cmwgPSBgJHtCQVNFX1VSTH0vc3RvY2svcHJvZmlsZTI/c3ltYm9sPSR7c3ltYm9sfSZ0b2tlbj0ke0ZJTk5IVUJfQVBJX0tFWX1gO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBtYWtlUmVxdWVzdCh1cmwpO1xuICAgIFxuICAgIC8vIENhY2hlIHRoZSBjb21wYW55IGluZm9cbiAgICBpZiAoZGF0YSAmJiBkYXRhLm5hbWUpIHtcbiAgICAgIGNvbXBhbnlEYXRhQ2FjaGUuc2V0KHN5bWJvbCwge1xuICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgIGNvbXBhbnlJbmZvOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyBjb21wYW55IHByb2ZpbGUgZm9yICR7c3ltYm9sfTpgLCBlcnJvcik7XG4gICAgXG4gICAgLy8gSWYgd2UgaGF2ZSBjYWNoZWQgZGF0YSwgdXNlIGl0XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IGNvbXBhbnlEYXRhQ2FjaGUuZ2V0KHN5bWJvbCk7XG4gICAgaWYgKGNhY2hlZERhdGE/LmNvbXBhbnlJbmZvKSB7XG4gICAgICBjb25zb2xlLmxvZyhgVXNpbmcgY2FjaGVkIGNvbXBhbnkgaW5mbyBmb3IgJHtzeW1ib2x9YCk7XG4gICAgICByZXR1cm4gY2FjaGVkRGF0YS5jb21wYW55SW5mbztcbiAgICB9XG4gICAgXG4gICAgLy8gT3RoZXJ3aXNlIHRocm93IHRoZSBlcnJvclxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb21wYW55TmV3cyhzeW1ib2w6IHN0cmluZywgZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nKTogUHJvbWlzZTxOZXdzSXRlbVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYCR7QkFTRV9VUkx9L2NvbXBhbnktbmV3cz9zeW1ib2w9JHtzeW1ib2x9JmZyb209JHtmcm9tfSZ0bz0ke3RvfSZ0b2tlbj0ke0ZJTk5IVUJfQVBJX0tFWX1gO1xuICAgIHJldHVybiBtYWtlUmVxdWVzdCh1cmwpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGdldHRpbmcgY29tcGFueSBuZXdzIGZvciAke3N5bWJvbH06YCwgZXJyb3IpO1xuICAgIFxuICAgIC8vIFJldHVybiBlbXB0eSBhcnJheSBvbiBlcnJvciByYXRoZXIgdGhhbiB0aHJvd2luZ1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VhcmNoU3ltYm9sKHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPEFycmF5PHsgc3ltYm9sOiBzdHJpbmc7IGRlc2NyaXB0aW9uOiBzdHJpbmcgfT4+IHtcbiAgY29uc3QgdXJsID0gYCR7QkFTRV9VUkx9L3NlYXJjaD9xPSR7cXVlcnl9JnRva2VuPSR7RklOTkhVQl9BUElfS0VZfWA7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBtYWtlUmVxdWVzdCh1cmwpO1xuICByZXR1cm4gZGF0YS5yZXN1bHQgfHwgW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaW1lZnJhbWVUaW1lc3RhbXBzKHRpbWVmcmFtZTogc3RyaW5nKTogeyBmcm9tOiBudW1iZXI7IHRvOiBudW1iZXIgfSB7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IHRvID0gTWF0aC5mbG9vcihub3cuZ2V0VGltZSgpIC8gMTAwMCk7XG4gIGxldCBmcm9tOiBudW1iZXI7XG5cbiAgc3dpdGNoICh0aW1lZnJhbWUpIHtcbiAgICBjYXNlICcxdyc6XG4gICAgICBmcm9tID0gdG8gLSA3ICogMjQgKiA2MCAqIDYwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnMW0nOlxuICAgICAgZnJvbSA9IHRvIC0gMzAgKiAyNCAqIDYwICogNjA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICczbSc6XG4gICAgICBmcm9tID0gdG8gLSA5MCAqIDI0ICogNjAgKiA2MDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzF5JzpcbiAgICAgIGZyb20gPSB0byAtIDM2NSAqIDI0ICogNjAgKiA2MDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzV5JzpcbiAgICAgIGZyb20gPSB0byAtIDUgKiAzNjUgKiAyNCAqIDYwICogNjA7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZnJvbSA9IHRvIC0gMzAgKiAyNCAqIDYwICogNjA7XG4gIH1cblxuICByZXR1cm4geyBmcm9tLCB0byB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZVlZWVlNTUREKGRhdGU6IERhdGUpOiBzdHJpbmcge1xuICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhZGVEYXRhIHtcbiAgcDogbnVtYmVyOyAgICAvLyBMYXN0IHByaWNlXG4gIHM6IHN0cmluZzsgICAgLy8gU3ltYm9sXG4gIHQ6IG51bWJlcjsgICAgLy8gVU5JWCBtaWxsaXNlY29uZHMgdGltZXN0YW1wXG4gIHY6IG51bWJlcjsgICAgLy8gVm9sdW1lXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2ViU29ja2V0TWVzc2FnZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgZGF0YTogVHJhZGVEYXRhW107XG59XG5cbmxldCB3czogV2ViU29ja2V0IHwgbnVsbCA9IG51bGw7XG5sZXQgc3Vic2NyaWJlcnM6IE1hcDxzdHJpbmcsIFNldDwoZGF0YTogVHJhZGVEYXRhKSA9PiB2b2lkPj4gPSBuZXcgTWFwKCk7XG5sZXQgcGVuZGluZ1N1YnNjcmlwdGlvbnM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xubGV0IGlzQ29ubmVjdGluZyA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gY29ubmVjdFdlYlNvY2tldCgpOiBQcm9taXNlPFdlYlNvY2tldD4ge1xuICBpZiAod3M/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh3cyk7XG4gIH1cblxuICBpZiAoaXNDb25uZWN0aW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBjaGVja0Nvbm5lY3Rpb24gPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICh3cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGNoZWNrQ29ubmVjdGlvbik7XG4gICAgICAgICAgcmVzb2x2ZSh3cyk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgfSk7XG4gIH1cblxuICBpc0Nvbm5lY3RpbmcgPSB0cnVlO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHdzID0gbmV3IFdlYlNvY2tldChgd3NzOi8vd3MuZmlubmh1Yi5pbz90b2tlbj0ke0ZJTk5IVUJfQVBJX0tFWX1gKTtcblxuICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdGaW5uaHViIFdlYlNvY2tldCBjb25uZWN0ZWQnKTtcbiAgICAgIGlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgLy8gU3Vic2NyaWJlIHRvIGFueSBwZW5kaW5nIHN5bWJvbHNcbiAgICAgIHBlbmRpbmdTdWJzY3JpcHRpb25zLmZvckVhY2goc3ltYm9sID0+IHtcbiAgICAgICAgd3M/LnNlbmQoSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiAnc3Vic2NyaWJlJywgc3ltYm9sIH0pKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1N1YnNjcmlwdGlvbnMuY2xlYXIoKTtcbiAgICAgIHJlc29sdmUod3MhKTtcbiAgICB9O1xuXG4gICAgd3Mub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlOiBXZWJTb2NrZXRNZXNzYWdlID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICd0cmFkZScpIHtcbiAgICAgICAgbWVzc2FnZS5kYXRhLmZvckVhY2godHJhZGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IHRyYWRlLnM7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gc3Vic2NyaWJlcnMuZ2V0KHN5bWJvbCk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sodHJhZGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3cy5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGaW5uaHViIFdlYlNvY2tldCBlcnJvcjonLCBlcnJvcik7XG4gICAgICBpc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfTtcblxuICAgIHdzLm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnRmlubmh1YiBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQnKTtcbiAgICAgIGlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgd3MgPSBudWxsO1xuICAgICAgLy8gS2VlcCB0cmFjayBvZiBjdXJyZW50IHN1YnNjcmlwdGlvbnMgZm9yIHJlY29ubmVjdGlvblxuICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaCgoXywgc3ltYm9sKSA9PiB7XG4gICAgICAgIHBlbmRpbmdTdWJzY3JpcHRpb25zLmFkZChzeW1ib2wpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJzY3JpYmVUb1N5bWJvbChzeW1ib2w6IHN0cmluZywgY2FsbGJhY2s6IChkYXRhOiBUcmFkZURhdGEpID0+IHZvaWQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzb2NrZXQgPSBhd2FpdCBjb25uZWN0V2ViU29ja2V0KCk7XG4gICAgXG4gICAgaWYgKCFzdWJzY3JpYmVycy5oYXMoc3ltYm9sKSkge1xuICAgICAgc3Vic2NyaWJlcnMuc2V0KHN5bWJvbCwgbmV3IFNldCgpKTtcbiAgICAgIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHsgdHlwZTogJ3N1YnNjcmliZScsIHN5bWJvbCB9KSk7XG4gICAgfVxuICAgIFxuICAgIHN1YnNjcmliZXJzLmdldChzeW1ib2wpPy5hZGQoY2FsbGJhY2spO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHN1YnNjcmliaW5nIHRvICR7c3ltYm9sfTpgLCBlcnJvcik7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVuc3Vic2NyaWJlRnJvbVN5bWJvbChzeW1ib2w6IHN0cmluZywgY2FsbGJhY2s/OiAoZGF0YTogVHJhZGVEYXRhKSA9PiB2b2lkKSB7XG4gIGlmICghd3MgfHwgd3MucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHJldHVybjtcblxuICB0cnkge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgc3Vic2NyaWJlcnMuZ2V0KHN5bWJvbCk/LmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICBpZiAoc3Vic2NyaWJlcnMuZ2V0KHN5bWJvbCk/LnNpemUgPT09IDApIHtcbiAgICAgICAgd3Muc2VuZChKU09OLnN0cmluZ2lmeSh7IHR5cGU6ICd1bnN1YnNjcmliZScsIHN5bWJvbCB9KSk7XG4gICAgICAgIHN1YnNjcmliZXJzLmRlbGV0ZShzeW1ib2wpO1xuICAgICAgICBwZW5kaW5nU3Vic2NyaXB0aW9ucy5kZWxldGUoc3ltYm9sKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd3Muc2VuZChKU09OLnN0cmluZ2lmeSh7IHR5cGU6ICd1bnN1YnNjcmliZScsIHN5bWJvbCB9KSk7XG4gICAgICBzdWJzY3JpYmVycy5kZWxldGUoc3ltYm9sKTtcbiAgICAgIHBlbmRpbmdTdWJzY3JpcHRpb25zLmRlbGV0ZShzeW1ib2wpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciB1bnN1YnNjcmliaW5nIGZyb20gJHtzeW1ib2x9OmAsIGVycm9yKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VXZWJTb2NrZXQoKSB7XG4gIGlmICh3cykge1xuICAgIHN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgcGVuZGluZ1N1YnNjcmlwdGlvbnMuY2xlYXIoKTtcbiAgICB3cy5jbG9zZSgpO1xuICAgIHdzID0gbnVsbDtcbiAgfVxufSAiXSwibmFtZXMiOlsiRklOTkhVQl9BUElfS0VZIiwicHJvY2VzcyIsImVudiIsIkJBU0VfVVJMIiwiY29tcGFueURhdGFDYWNoZSIsInNldFJhdGVMaW1pdGVkIiwiY29uc29sZSIsImVycm9yIiwibWFrZVJlcXVlc3QiLCJ1cmwiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwic3RhdHVzIiwiRXJyb3IiLCJvayIsImRhdGEiLCJqc29uIiwibWVzc2FnZSIsImdldFN0b2NrQ2FuZGxlcyIsInN5bWJvbCIsImZyb20iLCJ0byIsInJlc29sdXRpb24iLCJnZXRDb21wYW55UHJvZmlsZSIsImNhY2hlZERhdGEiLCJnZXQiLCJjb21wYW55SW5mbyIsIm5hbWUiLCJzZXQiLCJnZXRDb21wYW55TmV3cyIsInNlYXJjaFN5bWJvbCIsInF1ZXJ5IiwicmVzdWx0IiwiZ2V0VGltZWZyYW1lVGltZXN0YW1wcyIsInRpbWVmcmFtZSIsIm5vdyIsIkRhdGUiLCJNYXRoIiwiZmxvb3IiLCJnZXRUaW1lIiwiZm9ybWF0RGF0ZVlZWVlNTUREIiwiZGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJ3cyIsInN1YnNjcmliZXJzIiwiTWFwIiwicGVuZGluZ1N1YnNjcmlwdGlvbnMiLCJTZXQiLCJpc0Nvbm5lY3RpbmciLCJjb25uZWN0V2ViU29ja2V0IiwicmVhZHlTdGF0ZSIsIldlYlNvY2tldCIsIk9QRU4iLCJQcm9taXNlIiwicmVzb2x2ZSIsImNoZWNrQ29ubmVjdGlvbiIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInJlamVjdCIsIm9ub3BlbiIsImZvckVhY2giLCJzZW5kIiwiSlNPTiIsInN0cmluZ2lmeSIsInR5cGUiLCJjbGVhciIsIm9ubWVzc2FnZSIsImV2ZW50IiwicGFyc2UiLCJ0cmFkZSIsInMiLCJjYWxsYmFja3MiLCJjYWxsYmFjayIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiXyIsImFkZCIsInN1YnNjcmliZVRvU3ltYm9sIiwic29ja2V0IiwiaGFzIiwidW5zdWJzY3JpYmVGcm9tU3ltYm9sIiwiZGVsZXRlIiwic2l6ZSIsImNsb3NlV2ViU29ja2V0IiwiY2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/utils/finnhub.ts\n");

/***/ }),

/***/ "(rsc)/./app/utils/request-queue.ts":
/*!************************************!*\
  !*** ./app/utils/request-queue.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIRequestQueue: () => (/* binding */ APIRequestQueue),\n/* harmony export */   alphaVantageQueue: () => (/* binding */ alphaVantageQueue),\n/* harmony export */   finnhubQueue: () => (/* binding */ finnhubQueue)\n/* harmony export */ });\n/**\n * Smart request queue to handle API rate limits\n * This provides a centralized way to manage API requests and respect rate limits\n */ class APIRequestQueue {\n    /**\n   * Creates a new request queue\n   * @param name Identifier for this queue (for logging)\n   * @param requestsPerMinute Maximum requests allowed per minute\n   * @param minDelayMs Minimum delay between requests (in milliseconds)\n   */ constructor(name, requestsPerMinute = 5, minDelayMs = 200){\n        this.queue = [];\n        this.processing = false;\n        this.lastRequestTime = 0;\n        this.name = name;\n        this.requestsPerMinute = requestsPerMinute;\n        this.minDelayMs = minDelayMs;\n        // Initialize processing state\n        this.processing = false;\n    }\n    /**\n   * Add a request to the queue with the specified priority\n   * @param requestFn Function that executes the API request\n   * @param priority Priority level (higher = more important)\n   * @returns Promise that resolves with the result of the request\n   */ enqueue(requestFn, priority = 1) {\n        return new Promise((resolve, reject)=>{\n            // Create a request object\n            const request = {\n                execute: requestFn,\n                resolve,\n                reject,\n                priority,\n                timestamp: Date.now()\n            };\n            // Add to queue\n            this.queue.push(request);\n            // Sort queue by priority (higher first) then by timestamp (older first)\n            this.queue.sort((a, b)=>{\n                if (a.priority !== b.priority) {\n                    return b.priority - a.priority; // Higher priority first\n                }\n                return a.timestamp - b.timestamp; // Older requests first\n            });\n            // Start processing if not already doing so\n            if (!this.processing) {\n                this.processQueue();\n            }\n        });\n    }\n    /**\n   * Process the next request in the queue\n   */ async processQueue() {\n        if (this.queue.length === 0) {\n            this.processing = false;\n            return;\n        }\n        this.processing = true;\n        // Calculate delay based on rate limit\n        const timeSinceLastRequest = Date.now() - this.lastRequestTime;\n        const delay = Math.max(this.minDelayMs, 60000 / this.requestsPerMinute - timeSinceLastRequest);\n        // Wait if needed\n        if (delay > 0) {\n            await new Promise((resolve)=>setTimeout(resolve, delay));\n        }\n        // Get the next request\n        const request = this.queue.shift();\n        if (!request) {\n            this.processQueue();\n            return;\n        }\n        // Log request if timeout is significant\n        if (delay > 500) {\n            console.log(`[${this.name}] Executing request after ${delay}ms delay (${this.queue.length} remaining)`);\n        }\n        // Execute the request\n        try {\n            this.lastRequestTime = Date.now();\n            const result = await request.execute();\n            request.resolve(result);\n        } catch (error) {\n            // Check if it's a rate limit error\n            if (error && (typeof error === \"object\" && \"message\" in error && (String(error.message).toLowerCase().includes(\"rate limit\") || String(error.message).toLowerCase().includes(\"too many requests\")) || typeof error === \"string\" && (error.toLowerCase().includes(\"rate limit\") || error.toLowerCase().includes(\"too many requests\")))) {\n                console.warn(`[${this.name}] Rate limit hit, adding request back to queue with delay`);\n                // Wait longer and retry this request with higher priority\n                setTimeout(()=>{\n                    this.enqueue(request.execute, request.priority + 1);\n                }, 10000); // 10 second delay before retrying\n                request.reject(new Error(`Rate limit hit for ${this.name} API`));\n            } else {\n                // If it's not a rate limit error, just reject normally\n                request.reject(error);\n            }\n        }\n        // Process the next request\n        this.processQueue();\n    }\n    /**\n   * Get the current queue length\n   */ get length() {\n        return this.queue.length;\n    }\n    /**\n   * Check if the queue is currently busy\n   */ get isBusy() {\n        return this.processing;\n    }\n    /**\n   * Clear all pending requests\n   */ clear() {\n        const count = this.queue.length;\n        this.queue.forEach((request)=>{\n            request.reject(new Error(\"Queue cleared\"));\n        });\n        this.queue = [];\n        return count;\n    }\n}\n// Create singleton instances for different APIs\nconst finnhubQueue = new APIRequestQueue(\"Finnhub\", 30, 200); // 30 requests/minute\nconst alphaVantageQueue = new APIRequestQueue(\"AlphaVantage\", 5, 500); // 5 requests/minute \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RjtBQUVBLGdEQUFnRDtBQUN6QyxNQUFNRSxlQUFlLElBQUk3QyxnQkFBZ0IsV0FBVyxJQUFJLEtBQUssQ0FBQyxxQkFBcUI7QUFDbkYsTUFBTThDLG9CQUFvQixJQUFJOUMsZ0JBQWdCLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1zdG9jay12aWRlby8uL2FwcC91dGlscy9yZXF1ZXN0LXF1ZXVlLnRzP2JiNjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTbWFydCByZXF1ZXN0IHF1ZXVlIHRvIGhhbmRsZSBBUEkgcmF0ZSBsaW1pdHNcbiAqIFRoaXMgcHJvdmlkZXMgYSBjZW50cmFsaXplZCB3YXkgdG8gbWFuYWdlIEFQSSByZXF1ZXN0cyBhbmQgcmVzcGVjdCByYXRlIGxpbWl0c1xuICovXG5cbnR5cGUgUXVldWVkUmVxdWVzdDxUPiA9IHtcbiAgZXhlY3V0ZTogKCkgPT4gUHJvbWlzZTxUPjtcbiAgcmVzb2x2ZTogKHZhbHVlOiBUKSA9PiB2b2lkO1xuICByZWplY3Q6IChlcnJvcjogYW55KSA9PiB2b2lkO1xuICBwcmlvcml0eTogbnVtYmVyO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBjbGFzcyBBUElSZXF1ZXN0UXVldWUge1xuICBwcml2YXRlIHF1ZXVlOiBBcnJheTxRdWV1ZWRSZXF1ZXN0PGFueT4+ID0gW107XG4gIHByaXZhdGUgcHJvY2Vzc2luZyA9IGZhbHNlO1xuICBwcml2YXRlIHJlcXVlc3RzUGVyTWludXRlOiBudW1iZXI7XG4gIHByaXZhdGUgbWluRGVsYXlNczogbnVtYmVyO1xuICBwcml2YXRlIGxhc3RSZXF1ZXN0VGltZTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBuYW1lOiBzdHJpbmc7XG4gIFxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyByZXF1ZXN0IHF1ZXVlXG4gICAqIEBwYXJhbSBuYW1lIElkZW50aWZpZXIgZm9yIHRoaXMgcXVldWUgKGZvciBsb2dnaW5nKVxuICAgKiBAcGFyYW0gcmVxdWVzdHNQZXJNaW51dGUgTWF4aW11bSByZXF1ZXN0cyBhbGxvd2VkIHBlciBtaW51dGVcbiAgICogQHBhcmFtIG1pbkRlbGF5TXMgTWluaW11bSBkZWxheSBiZXR3ZWVuIHJlcXVlc3RzIChpbiBtaWxsaXNlY29uZHMpXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIHJlcXVlc3RzUGVyTWludXRlOiBudW1iZXIgPSA1LCBtaW5EZWxheU1zOiBudW1iZXIgPSAyMDApIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucmVxdWVzdHNQZXJNaW51dGUgPSByZXF1ZXN0c1Blck1pbnV0ZTtcbiAgICB0aGlzLm1pbkRlbGF5TXMgPSBtaW5EZWxheU1zO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgcHJvY2Vzc2luZyBzdGF0ZVxuICAgIHRoaXMucHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG4gIFxuICAvKipcbiAgICogQWRkIGEgcmVxdWVzdCB0byB0aGUgcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHByaW9yaXR5XG4gICAqIEBwYXJhbSByZXF1ZXN0Rm4gRnVuY3Rpb24gdGhhdCBleGVjdXRlcyB0aGUgQVBJIHJlcXVlc3RcbiAgICogQHBhcmFtIHByaW9yaXR5IFByaW9yaXR5IGxldmVsIChoaWdoZXIgPSBtb3JlIGltcG9ydGFudClcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgcmVxdWVzdFxuICAgKi9cbiAgZW5xdWV1ZTxUPihyZXF1ZXN0Rm46ICgpID0+IFByb21pc2U8VD4sIHByaW9yaXR5OiBudW1iZXIgPSAxKTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBhIHJlcXVlc3Qgb2JqZWN0XG4gICAgICBjb25zdCByZXF1ZXN0OiBRdWV1ZWRSZXF1ZXN0PFQ+ID0ge1xuICAgICAgICBleGVjdXRlOiByZXF1ZXN0Rm4sXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIHJlamVjdCxcbiAgICAgICAgcHJpb3JpdHksXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHRvIHF1ZXVlXG4gICAgICB0aGlzLnF1ZXVlLnB1c2gocmVxdWVzdCk7XG4gICAgICBcbiAgICAgIC8vIFNvcnQgcXVldWUgYnkgcHJpb3JpdHkgKGhpZ2hlciBmaXJzdCkgdGhlbiBieSB0aW1lc3RhbXAgKG9sZGVyIGZpcnN0KVxuICAgICAgdGhpcy5xdWV1ZS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLnByaW9yaXR5ICE9PSBiLnByaW9yaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGIucHJpb3JpdHkgLSBhLnByaW9yaXR5OyAvLyBIaWdoZXIgcHJpb3JpdHkgZmlyc3RcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS50aW1lc3RhbXAgLSBiLnRpbWVzdGFtcDsgLy8gT2xkZXIgcmVxdWVzdHMgZmlyc3RcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTdGFydCBwcm9jZXNzaW5nIGlmIG5vdCBhbHJlYWR5IGRvaW5nIHNvXG4gICAgICBpZiAoIXRoaXMucHJvY2Vzc2luZykge1xuICAgICAgICB0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgbmV4dCByZXF1ZXN0IGluIHRoZSBxdWV1ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzUXVldWUoKSB7XG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5wcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZGVsYXkgYmFzZWQgb24gcmF0ZSBsaW1pdFxuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RSZXF1ZXN0ID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdFJlcXVlc3RUaW1lO1xuICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5tYXgoXG4gICAgICB0aGlzLm1pbkRlbGF5TXMsXG4gICAgICAoNjAwMDAgLyB0aGlzLnJlcXVlc3RzUGVyTWludXRlKSAtIHRpbWVTaW5jZUxhc3RSZXF1ZXN0XG4gICAgKTtcbiAgICBcbiAgICAvLyBXYWl0IGlmIG5lZWRlZFxuICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdGhlIG5leHQgcmVxdWVzdFxuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICB0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBMb2cgcmVxdWVzdCBpZiB0aW1lb3V0IGlzIHNpZ25pZmljYW50XG4gICAgaWYgKGRlbGF5ID4gNTAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhgWyR7dGhpcy5uYW1lfV0gRXhlY3V0aW5nIHJlcXVlc3QgYWZ0ZXIgJHtkZWxheX1tcyBkZWxheSAoJHt0aGlzLnF1ZXVlLmxlbmd0aH0gcmVtYWluaW5nKWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBFeGVjdXRlIHRoZSByZXF1ZXN0XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubGFzdFJlcXVlc3RUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3QuZXhlY3V0ZSgpO1xuICAgICAgcmVxdWVzdC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSByYXRlIGxpbWl0IGVycm9yXG4gICAgICBpZiAoZXJyb3IgJiYgKFxuICAgICAgICAgICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIFxuICAgICAgICAgICAoJ21lc3NhZ2UnIGluIGVycm9yKSAmJiBcbiAgICAgICAgICAgKFN0cmluZyhlcnJvci5tZXNzYWdlKS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgXG4gICAgICAgICAgICBTdHJpbmcoZXJyb3IubWVzc2FnZSkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndG9vIG1hbnkgcmVxdWVzdHMnKSkpIHx8XG4gICAgICAgICAgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgJiYgXG4gICAgICAgICAgIChlcnJvci50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdyYXRlIGxpbWl0JykgfHwgXG4gICAgICAgICAgICBlcnJvci50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd0b28gbWFueSByZXF1ZXN0cycpKSlcbiAgICAgICkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbJHt0aGlzLm5hbWV9XSBSYXRlIGxpbWl0IGhpdCwgYWRkaW5nIHJlcXVlc3QgYmFjayB0byBxdWV1ZSB3aXRoIGRlbGF5YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGxvbmdlciBhbmQgcmV0cnkgdGhpcyByZXF1ZXN0IHdpdGggaGlnaGVyIHByaW9yaXR5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW5xdWV1ZShyZXF1ZXN0LmV4ZWN1dGUsIHJlcXVlc3QucHJpb3JpdHkgKyAxKTtcbiAgICAgICAgfSwgMTAwMDApOyAvLyAxMCBzZWNvbmQgZGVsYXkgYmVmb3JlIHJldHJ5aW5nXG4gICAgICAgIFxuICAgICAgICByZXF1ZXN0LnJlamVjdChuZXcgRXJyb3IoYFJhdGUgbGltaXQgaGl0IGZvciAke3RoaXMubmFtZX0gQVBJYCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgaXQncyBub3QgYSByYXRlIGxpbWl0IGVycm9yLCBqdXN0IHJlamVjdCBub3JtYWxseVxuICAgICAgICByZXF1ZXN0LnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFByb2Nlc3MgdGhlIG5leHQgcmVxdWVzdFxuICAgIHRoaXMucHJvY2Vzc1F1ZXVlKCk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgcXVldWUgbGVuZ3RoXG4gICAqL1xuICBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucXVldWUubGVuZ3RoO1xuICB9XG4gIFxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBidXN5XG4gICAqL1xuICBnZXQgaXNCdXN5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3Npbmc7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgcGVuZGluZyByZXF1ZXN0c1xuICAgKi9cbiAgY2xlYXIoKTogbnVtYmVyIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMucXVldWUubGVuZ3RoO1xuICAgIHRoaXMucXVldWUuZm9yRWFjaChyZXF1ZXN0ID0+IHtcbiAgICAgIHJlcXVlc3QucmVqZWN0KG5ldyBFcnJvcignUXVldWUgY2xlYXJlZCcpKTtcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG59XG5cbi8vIENyZWF0ZSBzaW5nbGV0b24gaW5zdGFuY2VzIGZvciBkaWZmZXJlbnQgQVBJc1xuZXhwb3J0IGNvbnN0IGZpbm5odWJRdWV1ZSA9IG5ldyBBUElSZXF1ZXN0UXVldWUoJ0Zpbm5odWInLCAzMCwgMjAwKTsgLy8gMzAgcmVxdWVzdHMvbWludXRlXG5leHBvcnQgY29uc3QgYWxwaGFWYW50YWdlUXVldWUgPSBuZXcgQVBJUmVxdWVzdFF1ZXVlKCdBbHBoYVZhbnRhZ2UnLCA1LCA1MDApOyAvLyA1IHJlcXVlc3RzL21pbnV0ZSAiXSwibmFtZXMiOlsiQVBJUmVxdWVzdFF1ZXVlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwicmVxdWVzdHNQZXJNaW51dGUiLCJtaW5EZWxheU1zIiwicXVldWUiLCJwcm9jZXNzaW5nIiwibGFzdFJlcXVlc3RUaW1lIiwiZW5xdWV1ZSIsInJlcXVlc3RGbiIsInByaW9yaXR5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZXF1ZXN0IiwiZXhlY3V0ZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJwdXNoIiwic29ydCIsImEiLCJiIiwicHJvY2Vzc1F1ZXVlIiwibGVuZ3RoIiwidGltZVNpbmNlTGFzdFJlcXVlc3QiLCJkZWxheSIsIk1hdGgiLCJtYXgiLCJzZXRUaW1lb3V0Iiwic2hpZnQiLCJjb25zb2xlIiwibG9nIiwicmVzdWx0IiwiZXJyb3IiLCJTdHJpbmciLCJtZXNzYWdlIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsIndhcm4iLCJFcnJvciIsImlzQnVzeSIsImNsZWFyIiwiY291bnQiLCJmb3JFYWNoIiwiZmlubmh1YlF1ZXVlIiwiYWxwaGFWYW50YWdlUXVldWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/utils/request-queue.ts\n");

/***/ }),

/***/ "(rsc)/./app/utils/retry-helper.ts":
/*!***********************************!*\
  !*** ./app/utils/retry-helper.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiQueue: () => (/* binding */ ApiQueue),\n/* harmony export */   isRateLimitError: () => (/* binding */ isRateLimitError),\n/* harmony export */   retryWhenRateLimited: () => (/* binding */ retryWhenRateLimited),\n/* harmony export */   retryWithBackoff: () => (/* binding */ retryWithBackoff)\n/* harmony export */ });\n/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cache */ \"(rsc)/./app/utils/cache.ts\");\n/**\n * Retry Helper Utility\n * \n * This utility provides functions to help with API retries and\n * handling rate limiting more gracefully\n */ \n/**\n * Check if an error is related to rate limiting\n */ function isRateLimitError(error) {\n    if (!error) return false;\n    // Convert error to string for consistent checking\n    const errorStr = (typeof error === \"object\" ? error.message || error.toString() : String(error)).toLowerCase();\n    // Check for common rate limit indicators\n    return errorStr.includes(\"rate limit\") || errorStr.includes(\"too many requests\") || errorStr.includes(\"429\") || errorStr.includes(\"quota exceeded\") || errorStr.includes(\"api calls exceeded\") || errorStr.includes(\"please slow down\");\n}\n/**\n * Sleep for a given number of milliseconds\n */ const sleep = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n/**\n * Retry a function with exponential backoff\n */ async function retryWithBackoff(fn, options = {}) {\n    const { maxRetries = 3, initialDelayMs = 1000, maxDelayMs = 30000, backoffFactor = 2, retryCondition = (error)=>true, onRetry = ()=>{} } = options;\n    let lastError;\n    let delay = initialDelayMs;\n    for(let attempt = 1; attempt <= maxRetries; attempt++){\n        try {\n            return await fn();\n        } catch (error) {\n            lastError = error;\n            // Check if we should retry\n            if (!retryCondition(error) || attempt === maxRetries) {\n                throw error;\n            }\n            // Calculate next delay with exponential backoff\n            delay = Math.min(delay * backoffFactor, maxDelayMs);\n            // Add some jitter to prevent thundering herd\n            const jitter = Math.random() * 200 - 100; // 100ms\n            const finalDelay = delay + jitter;\n            // Notify callback\n            onRetry(attempt, finalDelay);\n            // Wait before retrying\n            await sleep(finalDelay);\n        }\n    }\n    throw lastError;\n}\n/**\n * Retry a function specifically when rate limited\n */ async function retryWhenRateLimited(fn, options = {}) {\n    const { maxRetries = 3, initialDelayMs = 2000, maxDelayMs = 60000, onRetry = ()=>{} } = options;\n    try {\n        return await retryWithBackoff(fn, {\n            maxRetries,\n            initialDelayMs,\n            maxDelayMs,\n            backoffFactor: 3,\n            retryCondition: (error)=>{\n                const isRateLimit = isRateLimitError(error);\n                if (isRateLimit) {\n                    (0,_cache__WEBPACK_IMPORTED_MODULE_0__.setRateLimited)(true);\n                }\n                return isRateLimit;\n            },\n            onRetry: (attempt, delay)=>{\n                onRetry(attempt, delay);\n            }\n        });\n    } catch (error) {\n        // If we failed due to rate limiting, ensure the flag is set\n        if (isRateLimitError(error)) {\n            (0,_cache__WEBPACK_IMPORTED_MODULE_0__.setRateLimited)(true);\n        }\n        throw error;\n    }\n}\n/**\n * Queue for rate-limited API calls\n */ class ApiQueue {\n    constructor(callsPerSecond){\n        this.queue = [];\n        this.processing = false;\n        this.lastCallTime = 0;\n        this.minDelayMs = 1000 / callsPerSecond;\n    }\n    async add(fn) {\n        return new Promise((resolve, reject)=>{\n            this.queue.push(async ()=>{\n                try {\n                    // Ensure minimum delay between calls\n                    const now = Date.now();\n                    const timeSinceLastCall = now - this.lastCallTime;\n                    if (timeSinceLastCall < this.minDelayMs) {\n                        await sleep(this.minDelayMs - timeSinceLastCall);\n                    }\n                    const result = await fn();\n                    this.lastCallTime = Date.now();\n                    resolve(result);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            this.process();\n        });\n    }\n    async process() {\n        if (this.processing || this.queue.length === 0) return;\n        this.processing = true;\n        while(this.queue.length > 0){\n            const task = this.queue.shift();\n            if (task) {\n                await task();\n            }\n        }\n        this.processing = false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQWM7UUFDN0MsT0FBTyxJQUFJSixRQUFRLENBQUNDLFNBQVM2QjtZQUMzQixJQUFJLENBQUNMLEtBQUssQ0FBQ00sSUFBSSxDQUFDO2dCQUNkLElBQUk7b0JBQ0YscUNBQXFDO29CQUNyQyxNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO29CQUNwQixNQUFNRSxvQkFBb0JGLE1BQU0sSUFBSSxDQUFDTCxZQUFZO29CQUNqRCxJQUFJTyxvQkFBb0IsSUFBSSxDQUFDTixVQUFVLEVBQUU7d0JBQ3ZDLE1BQU05QixNQUFNLElBQUksQ0FBQzhCLFVBQVUsR0FBR007b0JBQ2hDO29CQUVBLE1BQU1DLFNBQVMsTUFBTS9CO29CQUNyQixJQUFJLENBQUN1QixZQUFZLEdBQUdNLEtBQUtELEdBQUc7b0JBQzVCL0IsUUFBUWtDO2dCQUNWLEVBQUUsT0FBTzVDLE9BQU87b0JBQ2R1QyxPQUFPdkM7Z0JBQ1Q7WUFDRjtZQUVBLElBQUksQ0FBQzZDLE9BQU87UUFDZDtJQUNGO0lBRUEsTUFBY0EsVUFBVTtRQUN0QixJQUFJLElBQUksQ0FBQ1YsVUFBVSxJQUFJLElBQUksQ0FBQ0QsS0FBSyxDQUFDWSxNQUFNLEtBQUssR0FBRztRQUVoRCxJQUFJLENBQUNYLFVBQVUsR0FBRztRQUNsQixNQUFPLElBQUksQ0FBQ0QsS0FBSyxDQUFDWSxNQUFNLEdBQUcsRUFBRztZQUM1QixNQUFNQyxPQUFPLElBQUksQ0FBQ2IsS0FBSyxDQUFDYyxLQUFLO1lBQzdCLElBQUlELE1BQU07Z0JBQ1IsTUFBTUE7WUFDUjtRQUNGO1FBQ0EsSUFBSSxDQUFDWixVQUFVLEdBQUc7SUFDcEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXN0b2NrLXZpZGVvLy4vYXBwL3V0aWxzL3JldHJ5LWhlbHBlci50cz85ZTRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmV0cnkgSGVscGVyIFV0aWxpdHlcbiAqIFxuICogVGhpcyB1dGlsaXR5IHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBoZWxwIHdpdGggQVBJIHJldHJpZXMgYW5kXG4gKiBoYW5kbGluZyByYXRlIGxpbWl0aW5nIG1vcmUgZ3JhY2VmdWxseVxuICovXG5cbmltcG9ydCB7IHNldFJhdGVMaW1pdGVkIH0gZnJvbSAnLi9jYWNoZSc7XG5cbmludGVyZmFjZSBSZXRyeU9wdGlvbnMge1xuICBtYXhSZXRyaWVzPzogbnVtYmVyO1xuICBpbml0aWFsRGVsYXlNcz86IG51bWJlcjtcbiAgbWF4RGVsYXlNcz86IG51bWJlcjtcbiAgYmFja29mZkZhY3Rvcj86IG51bWJlcjtcbiAgcmV0cnlDb25kaXRpb24/OiAoZXJyb3I6IGFueSkgPT4gYm9vbGVhbjtcbiAgb25SZXRyeT86IChhdHRlbXB0OiBudW1iZXIsIGRlbGF5OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZXJyb3IgaXMgcmVsYXRlZCB0byByYXRlIGxpbWl0aW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JhdGVMaW1pdEVycm9yKGVycm9yOiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKCFlcnJvcikgcmV0dXJuIGZhbHNlO1xuICBcbiAgLy8gQ29udmVydCBlcnJvciB0byBzdHJpbmcgZm9yIGNvbnNpc3RlbnQgY2hlY2tpbmdcbiAgY29uc3QgZXJyb3JTdHIgPSAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyA/IFxuICAgIChlcnJvci5tZXNzYWdlIHx8IGVycm9yLnRvU3RyaW5nKCkpIDogXG4gICAgU3RyaW5nKGVycm9yKSkudG9Mb3dlckNhc2UoKTtcbiAgXG4gIC8vIENoZWNrIGZvciBjb21tb24gcmF0ZSBsaW1pdCBpbmRpY2F0b3JzXG4gIHJldHVybiAoXG4gICAgZXJyb3JTdHIuaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fFxuICAgIGVycm9yU3RyLmluY2x1ZGVzKCd0b28gbWFueSByZXF1ZXN0cycpIHx8XG4gICAgZXJyb3JTdHIuaW5jbHVkZXMoJzQyOScpIHx8XG4gICAgZXJyb3JTdHIuaW5jbHVkZXMoJ3F1b3RhIGV4Y2VlZGVkJykgfHxcbiAgICBlcnJvclN0ci5pbmNsdWRlcygnYXBpIGNhbGxzIGV4Y2VlZGVkJykgfHxcbiAgICBlcnJvclN0ci5pbmNsdWRlcygncGxlYXNlIHNsb3cgZG93bicpXG4gICk7XG59XG5cbi8qKlxuICogU2xlZXAgZm9yIGEgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCBzbGVlcCA9IChtczogbnVtYmVyKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuLyoqXG4gKiBSZXRyeSBhIGZ1bmN0aW9uIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV0cnlXaXRoQmFja29mZjxUPihcbiAgZm46ICgpID0+IFByb21pc2U8VD4sXG4gIG9wdGlvbnM6IFJldHJ5T3B0aW9ucyA9IHt9XG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3Qge1xuICAgIG1heFJldHJpZXMgPSAzLFxuICAgIGluaXRpYWxEZWxheU1zID0gMTAwMCxcbiAgICBtYXhEZWxheU1zID0gMzAwMDAsXG4gICAgYmFja29mZkZhY3RvciA9IDIsXG4gICAgcmV0cnlDb25kaXRpb24gPSAoZXJyb3I6IGFueSkgPT4gdHJ1ZSxcbiAgICBvblJldHJ5ID0gKCkgPT4ge31cbiAgfSA9IG9wdGlvbnM7XG4gIFxuICBsZXQgbGFzdEVycm9yOiBhbnk7XG4gIGxldCBkZWxheSA9IGluaXRpYWxEZWxheU1zO1xuICBcbiAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gbWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHJldHJ5XG4gICAgICBpZiAoIXJldHJ5Q29uZGl0aW9uKGVycm9yKSB8fCBhdHRlbXB0ID09PSBtYXhSZXRyaWVzKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgbmV4dCBkZWxheSB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgIGRlbGF5ID0gTWF0aC5taW4oZGVsYXkgKiBiYWNrb2ZmRmFjdG9yLCBtYXhEZWxheU1zKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHNvbWUgaml0dGVyIHRvIHByZXZlbnQgdGh1bmRlcmluZyBoZXJkXG4gICAgICBjb25zdCBqaXR0ZXIgPSBNYXRoLnJhbmRvbSgpICogMjAwIC0gMTAwOyAvLyDCsTEwMG1zXG4gICAgICBjb25zdCBmaW5hbERlbGF5ID0gZGVsYXkgKyBqaXR0ZXI7XG4gICAgICBcbiAgICAgIC8vIE5vdGlmeSBjYWxsYmFja1xuICAgICAgb25SZXRyeShhdHRlbXB0LCBmaW5hbERlbGF5KTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlpbmdcbiAgICAgIGF3YWl0IHNsZWVwKGZpbmFsRGVsYXkpO1xuICAgIH1cbiAgfVxuICBcbiAgdGhyb3cgbGFzdEVycm9yO1xufVxuXG4vKipcbiAqIFJldHJ5IGEgZnVuY3Rpb24gc3BlY2lmaWNhbGx5IHdoZW4gcmF0ZSBsaW1pdGVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXRyeVdoZW5SYXRlTGltaXRlZDxUPihcbiAgZm46ICgpID0+IFByb21pc2U8VD4sXG4gIG9wdGlvbnM6IFJldHJ5T3B0aW9ucyA9IHt9XG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3Qge1xuICAgIG1heFJldHJpZXMgPSAzLFxuICAgIGluaXRpYWxEZWxheU1zID0gMjAwMCxcbiAgICBtYXhEZWxheU1zID0gNjAwMDAsXG4gICAgb25SZXRyeSA9ICgpID0+IHt9XG4gIH0gPSBvcHRpb25zO1xuICBcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcmV0cnlXaXRoQmFja29mZihmbiwge1xuICAgICAgbWF4UmV0cmllcyxcbiAgICAgIGluaXRpYWxEZWxheU1zLFxuICAgICAgbWF4RGVsYXlNcyxcbiAgICAgIGJhY2tvZmZGYWN0b3I6IDMsIC8vIE1vcmUgYWdncmVzc2l2ZSBiYWNrb2ZmIGZvciByYXRlIGxpbWl0c1xuICAgICAgcmV0cnlDb25kaXRpb246IChlcnJvcikgPT4ge1xuICAgICAgICBjb25zdCBpc1JhdGVMaW1pdCA9IGlzUmF0ZUxpbWl0RXJyb3IoZXJyb3IpO1xuICAgICAgICBpZiAoaXNSYXRlTGltaXQpIHtcbiAgICAgICAgICBzZXRSYXRlTGltaXRlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNSYXRlTGltaXQ7XG4gICAgICB9LFxuICAgICAgb25SZXRyeTogKGF0dGVtcHQsIGRlbGF5KSA9PiB7XG4gICAgICAgIG9uUmV0cnkoYXR0ZW1wdCwgZGVsYXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIElmIHdlIGZhaWxlZCBkdWUgdG8gcmF0ZSBsaW1pdGluZywgZW5zdXJlIHRoZSBmbGFnIGlzIHNldFxuICAgIGlmIChpc1JhdGVMaW1pdEVycm9yKGVycm9yKSkge1xuICAgICAgc2V0UmF0ZUxpbWl0ZWQodHJ1ZSk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogUXVldWUgZm9yIHJhdGUtbGltaXRlZCBBUEkgY2FsbHNcbiAqL1xuZXhwb3J0IGNsYXNzIEFwaVF1ZXVlIHtcbiAgcHJpdmF0ZSBxdWV1ZTogQXJyYXk8KCkgPT4gUHJvbWlzZTxhbnk+PiA9IFtdO1xuICBwcml2YXRlIHByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBsYXN0Q2FsbFRpbWUgPSAwO1xuICBwcml2YXRlIG1pbkRlbGF5TXM6IG51bWJlcjtcbiAgXG4gIGNvbnN0cnVjdG9yKGNhbGxzUGVyU2Vjb25kOiBudW1iZXIpIHtcbiAgICB0aGlzLm1pbkRlbGF5TXMgPSAxMDAwIC8gY2FsbHNQZXJTZWNvbmQ7XG4gIH1cbiAgXG4gIGFzeW5jIGFkZDxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEVuc3VyZSBtaW5pbXVtIGRlbGF5IGJldHdlZW4gY2FsbHNcbiAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDYWxsID0gbm93IC0gdGhpcy5sYXN0Q2FsbFRpbWU7XG4gICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RDYWxsIDwgdGhpcy5taW5EZWxheU1zKSB7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcCh0aGlzLm1pbkRlbGF5TXMgLSB0aW1lU2luY2VMYXN0Q2FsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKCk7XG4gICAgICAgICAgdGhpcy5sYXN0Q2FsbFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgdGhpcy5wcm9jZXNzKCk7XG4gICAgfSk7XG4gIH1cbiAgXG4gIHByaXZhdGUgYXN5bmMgcHJvY2VzcygpIHtcbiAgICBpZiAodGhpcy5wcm9jZXNzaW5nIHx8IHRoaXMucXVldWUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgXG4gICAgdGhpcy5wcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0YXNrID0gdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgYXdhaXQgdGFzaygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxufSAiXSwibmFtZXMiOlsic2V0UmF0ZUxpbWl0ZWQiLCJpc1JhdGVMaW1pdEVycm9yIiwiZXJyb3IiLCJlcnJvclN0ciIsIm1lc3NhZ2UiLCJ0b1N0cmluZyIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJzbGVlcCIsIm1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicmV0cnlXaXRoQmFja29mZiIsImZuIiwib3B0aW9ucyIsIm1heFJldHJpZXMiLCJpbml0aWFsRGVsYXlNcyIsIm1heERlbGF5TXMiLCJiYWNrb2ZmRmFjdG9yIiwicmV0cnlDb25kaXRpb24iLCJvblJldHJ5IiwibGFzdEVycm9yIiwiZGVsYXkiLCJhdHRlbXB0IiwiTWF0aCIsIm1pbiIsImppdHRlciIsInJhbmRvbSIsImZpbmFsRGVsYXkiLCJyZXRyeVdoZW5SYXRlTGltaXRlZCIsImlzUmF0ZUxpbWl0IiwiQXBpUXVldWUiLCJjb25zdHJ1Y3RvciIsImNhbGxzUGVyU2Vjb25kIiwicXVldWUiLCJwcm9jZXNzaW5nIiwibGFzdENhbGxUaW1lIiwibWluRGVsYXlNcyIsImFkZCIsInJlamVjdCIsInB1c2giLCJub3ciLCJEYXRlIiwidGltZVNpbmNlTGFzdENhbGwiLCJyZXN1bHQiLCJwcm9jZXNzIiwibGVuZ3RoIiwidGFzayIsInNoaWZ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/utils/retry-helper.ts\n");

/***/ }),

/***/ "(rsc)/./app/utils/stock-api.ts":
/*!********************************!*\
  !*** ./app/utils/stock-api.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PROVIDERS: () => (/* binding */ PROVIDERS),\n/* harmony export */   getCompanyNewsWithFallback: () => (/* binding */ getCompanyNewsWithFallback),\n/* harmony export */   getCompanyProfileWithFallback: () => (/* binding */ getCompanyProfileWithFallback),\n/* harmony export */   getStockData: () => (/* binding */ getStockData),\n/* harmony export */   resetConfig: () => (/* binding */ resetConfig),\n/* harmony export */   updateConfig: () => (/* binding */ updateConfig)\n/* harmony export */ });\n/* harmony import */ var _finnhub__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./finnhub */ \"(rsc)/./app/utils/finnhub.ts\");\n/* harmony import */ var _alphavantage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./alphavantage */ \"(rsc)/./app/utils/alphavantage.ts\");\n/* harmony import */ var _request_queue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./request-queue */ \"(rsc)/./app/utils/request-queue.ts\");\n/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cache */ \"(rsc)/./app/utils/cache.ts\");\n/* harmony import */ var _retry_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./retry-helper */ \"(rsc)/./app/utils/retry-helper.ts\");\n/**\n * Unified Stock API Client with Fallback Mechanisms\n * \n * This file provides a unified interface for fetching stock data from multiple providers,\n * with automatic fallback between Finnhub and Alpha Vantage.\n */ \n\n\n\n\n// ===== Configuration =====\nconst PROVIDERS = {\n    ALPHA_VANTAGE: {\n        name: \"AlphaVantage\",\n        priority: 1\n    },\n    FINNHUB: {\n        name: \"Finnhub\",\n        priority: 2\n    }\n};\n// Default configuration\nconst defaultConfig = {\n    preferredOHLCProvider: PROVIDERS.FINNHUB,\n    preferredNewsProvider: PROVIDERS.FINNHUB,\n    enableFallback: true,\n    cacheResults: true,\n    logApiCalls: true,\n    alphaVantageConfig: {\n        apiKey: process.env.ALPHA_VANTAGE_API_KEY || \"\"\n    },\n    finnhubConfig: {\n        apiKey: process.env.FINNHUB_API_KEY || \"\"\n    }\n};\n// Current configuration (mutable)\nlet currentConfig = {\n    ...defaultConfig\n};\n// Configuration functions\nfunction updateConfig(newConfig) {\n    currentConfig = {\n        ...currentConfig,\n        ...newConfig\n    };\n}\nfunction resetConfig() {\n    currentConfig = {\n        ...defaultConfig\n    };\n}\n// ===== Utility Functions =====\n/**\n * Enhanced logging function\n */ function logApi(message, level = \"info\", details) {\n    const timestamp = new Date().toISOString();\n    const logMessage = `[${timestamp}] ${level.toUpperCase()}: ${message}`;\n    // Log to console with appropriate level\n    if (level === \"error\") {\n        console.error(logMessage);\n        if (details) console.error(\"Details:\", details);\n    } else if (level === \"warn\") {\n        console.warn(logMessage);\n        if (details) console.warn(\"Details:\", details);\n    } else {\n        console.log(logMessage);\n        if (details) console.log(\"Details:\", details);\n    }\n// In a production environment, you might want to:\n// 1. Store logs in localStorage for debugging\n// 2. Send logs to a server\n// 3. Maintain a rolling log buffer\n}\n/**\n * Check if data is in cache\n */ function checkCache(symbol) {\n    if (currentConfig.cacheResults) {\n        const cachedData = _cache__WEBPACK_IMPORTED_MODULE_3__.companyDataCache.get(symbol);\n        if (cachedData?.timeSeriesData?.length) {\n            logApi(`Using cached data for ${symbol}`);\n            return {\n                timeSeriesData: cachedData.timeSeriesData,\n                significantMoves: cachedData.significantMoves || []\n            };\n        }\n    }\n    return null;\n}\n/**\n * Save data to cache\n */ function saveToCache(symbol, data) {\n    if (currentConfig.cacheResults && data) {\n        logApi(`Saving ${symbol} data to cache`);\n        _cache__WEBPACK_IMPORTED_MODULE_3__.companyDataCache.set(symbol, data);\n    }\n}\n// Track API key status\nconst apiKeyStatus = {};\n/**\n * Check if an API key is currently rate limited\n */ function isKeyRateLimited(key) {\n    const status = apiKeyStatus[key];\n    if (!status) return false;\n    // Check if we're still within the rate limit period\n    if (status.rateLimitedUntil > Date.now()) {\n        logApi(`API key ${key.slice(0, 8)}... is rate limited until ${new Date(status.rateLimitedUntil).toISOString()}`, \"warn\");\n        return true;\n    }\n    return false;\n}\n/**\n * Mark an API key as rate limited\n */ function markKeyRateLimited(key, provider, durationMs = 60000) {\n    if (!apiKeyStatus[key]) {\n        apiKeyStatus[key] = {\n            key,\n            provider,\n            lastUsed: Date.now(),\n            errorCount: 0,\n            rateLimitedUntil: 0\n        };\n    }\n    apiKeyStatus[key].errorCount++;\n    apiKeyStatus[key].rateLimitedUntil = Date.now() + durationMs;\n    logApi(`Marked API key ${key.slice(0, 8)}... as rate limited for ${durationMs / 1000}s`, \"warn\", {\n        provider,\n        errorCount: apiKeyStatus[key].errorCount\n    });\n}\n/**\n * Update API key status after successful use\n */ function markKeySuccess(key, provider) {\n    if (!apiKeyStatus[key]) {\n        apiKeyStatus[key] = {\n            key,\n            provider,\n            lastUsed: Date.now(),\n            errorCount: 0,\n            rateLimitedUntil: 0\n        };\n    }\n    // Reset error count on success\n    apiKeyStatus[key].errorCount = 0;\n    apiKeyStatus[key].lastUsed = Date.now();\n    apiKeyStatus[key].rateLimitedUntil = 0;\n}\n/**\n * Get the next available API key for a provider\n */ function getAvailableApiKey(provider) {\n    const config = provider === PROVIDERS.ALPHA_VANTAGE.name ? currentConfig.alphaVantageConfig : currentConfig.finnhubConfig;\n    // If we have multiple API keys, try to find one that's not rate limited\n    if (Array.isArray(config.apiKey)) {\n        for (const key of config.apiKey){\n            if (!isKeyRateLimited(key)) {\n                return key;\n            }\n        }\n        return null; // All keys are rate limited\n    }\n    // Single API key\n    return isKeyRateLimited(config.apiKey) ? null : config.apiKey;\n}\n/**\n * Enhanced getOHLCFromFinnhub with API key management\n */ async function getOHLCFromFinnhub(symbol, timeframe) {\n    const apiKey = getAvailableApiKey(PROVIDERS.FINNHUB.name);\n    if (!apiKey) {\n        throw new Error(\"All Finnhub API keys are currently rate limited\");\n    }\n    try {\n        // Make the API call with the selected key\n        const result = await _request_queue__WEBPACK_IMPORTED_MODULE_2__.finnhubQueue.enqueue(async ()=>{\n            logApi(`Fetching OHLC data for ${symbol} from Finnhub`);\n            // Calculate date range based on timeframe\n            const now = Math.floor(Date.now() / 1000);\n            const oneDay = 24 * 60 * 60;\n            let fromTime;\n            let resolution = \"D\";\n            switch(timeframe){\n                case \"1w\":\n                    fromTime = now - 7 * oneDay;\n                    resolution = \"15\";\n                    break;\n                case \"1m\":\n                    fromTime = now - 30 * oneDay;\n                    resolution = \"60\";\n                    break;\n                case \"3m\":\n                    fromTime = now - 90 * oneDay;\n                    resolution = \"D\";\n                    break;\n                case \"6m\":\n                    fromTime = now - 180 * oneDay;\n                    resolution = \"D\";\n                    break;\n                case \"1y\":\n                    fromTime = now - 365 * oneDay;\n                    resolution = \"D\";\n                    break;\n                default:\n                    fromTime = now - 90 * oneDay;\n                    resolution = \"D\";\n                    break;\n            }\n            const candles = await (0,_finnhub__WEBPACK_IMPORTED_MODULE_0__.getStockCandles)(symbol, fromTime, now, \"D\");\n            if (candles.s !== \"ok\" || !candles.t || candles.t.length === 0) {\n                throw new Error(`Invalid Finnhub response for ${symbol}: ${candles.s || \"No status\"}`);\n            }\n            // Convert Finnhub format to our standard OHLC format\n            const timeSeriesData = candles.t.map((timestamp, index)=>{\n                const open = candles.o[index];\n                const close = candles.c[index];\n                const percentageChange = (close - open) / open * 100;\n                return {\n                    date: new Date(timestamp * 1000).toISOString().split(\"T\")[0],\n                    open,\n                    high: candles.h[index],\n                    low: candles.l[index],\n                    close,\n                    volume: candles.v[index],\n                    percentageChange: Number(percentageChange.toFixed(2)),\n                    direction: percentageChange >= 0 ? \"up\" : \"down\"\n                };\n            }).sort((a, b)=>new Date(b.date).getTime() - new Date(a.date).getTime());\n            // Process the data to find significant moves\n            const significantMoves = [];\n            // Calculate average volume\n            const avgVolume = timeSeriesData.reduce((sum, day)=>sum + day.volume, 0) / timeSeriesData.length;\n            // Find days with significant price and volume movement\n            for (const day of timeSeriesData){\n                // Significant move criteria: >2% price change AND volume > 1.5x average\n                if (Math.abs(day.percentageChange) > 2 && day.volume > avgVolume * 1.5) {\n                    significantMoves.push(day);\n                }\n            }\n            // Sort by date (most recent first) and limit to top 10\n            significantMoves.sort((a, b)=>new Date(b.date).getTime() - new Date(a.date).getTime());\n            significantMoves.splice(10);\n            return {\n                timeSeriesData,\n                significantMoves\n            };\n        });\n        // Mark the key as successful\n        markKeySuccess(apiKey, PROVIDERS.FINNHUB.name);\n        return result;\n    } catch (error) {\n        if ((0,_retry_helper__WEBPACK_IMPORTED_MODULE_4__.isRateLimitError)(error)) {\n            markKeyRateLimited(apiKey, PROVIDERS.FINNHUB.name);\n        }\n        throw error;\n    }\n}\n/**\n * Enhanced getOHLCFromAlphaVantage with API key management\n */ async function getOHLCFromAlphaVantage(symbol, timeframe) {\n    const apiKey = getAvailableApiKey(PROVIDERS.ALPHA_VANTAGE.name);\n    if (!apiKey) {\n        throw new Error(\"All Alpha Vantage API keys are currently rate limited\");\n    }\n    try {\n        // Make the API call with the selected key\n        const result = await _request_queue__WEBPACK_IMPORTED_MODULE_2__.alphaVantageQueue.enqueue(async ()=>{\n            logApi(`Fetching OHLC data for ${symbol} from Alpha Vantage with timeframe ${timeframe}`);\n            // Convert timeframe to Alpha Vantage format\n            const outputsize = timeframe === \"1w\" || timeframe === \"1m\" ? \"compact\" : \"full\";\n            const result = await (0,_alphavantage__WEBPACK_IMPORTED_MODULE_1__.getDailyTimeSeries)(symbol, outputsize);\n            // Filter data based on timeframe\n            const now = Date.now();\n            const oneDay = 24 * 60 * 60 * 1000;\n            const timeframeMap = {\n                \"1w\": 7 * oneDay,\n                \"1m\": 30 * oneDay,\n                \"3m\": 90 * oneDay,\n                \"6m\": 180 * oneDay,\n                \"1y\": 365 * oneDay\n            };\n            const timeframeMs = timeframeMap[timeframe] || timeframeMap[\"3m\"];\n            const cutoffDate = new Date(now - timeframeMs).toISOString().split(\"T\")[0];\n            const filteredData = result.allDailyData.filter((day)=>day.date >= cutoffDate);\n            // Calculate significant moves\n            const avgVolume = filteredData.reduce((sum, day)=>sum + day.volume, 0) / filteredData.length;\n            const significantMoves = [];\n            // Find days with significant price and volume movement\n            for (const day of filteredData){\n                // Significant move criteria: >2% price change AND volume > 1.5x average\n                if (Math.abs(day.percentageChange) > 2 && day.volume > avgVolume * 1.5) {\n                    significantMoves.push(day);\n                }\n            }\n            // Sort by date (most recent first) and limit to top 10\n            significantMoves.sort((a, b)=>new Date(b.date).getTime() - new Date(a.date).getTime());\n            significantMoves.splice(10);\n            return {\n                timeSeriesData: filteredData,\n                significantMoves\n            };\n        });\n        // Mark the key as successful\n        markKeySuccess(apiKey, PROVIDERS.ALPHA_VANTAGE.name);\n        return result;\n    } catch (error) {\n        if ((0,_retry_helper__WEBPACK_IMPORTED_MODULE_4__.isRateLimitError)(error)) {\n            markKeyRateLimited(apiKey, PROVIDERS.ALPHA_VANTAGE.name);\n        }\n        throw error;\n    }\n}\n/**\n * Unified API to get OHLC data with fallback\n */ async function getStockData(symbol, timeframe = \"3m\", forceRefresh = false) {\n    logApi(`Starting getStockData for ${symbol}`, \"info\", {\n        timeframe,\n        forceRefresh\n    });\n    // Check if we're rate limited and have cached data\n    if (_cache__WEBPACK_IMPORTED_MODULE_3__.isRateLimited && !forceRefresh) {\n        logApi(`Rate limited check for ${symbol}`, \"warn\", {\n            isRateLimited: _cache__WEBPACK_IMPORTED_MODULE_3__.isRateLimited\n        });\n        const cachedData = checkCache(symbol);\n        if (cachedData) {\n            logApi(`Using cached data for ${symbol} due to rate limiting`, \"warn\", {\n                cacheAge: Date.now() - (cachedData.timestamp || 0),\n                dataPoints: cachedData.timeSeriesData?.length\n            });\n            return cachedData;\n        }\n    }\n    // Standardize symbol and timeframe\n    symbol = symbol.toUpperCase();\n    const standardizedTimeframe = (()=>{\n        switch(timeframe){\n            case \"1w\":\n                return \"1w\";\n            case \"1mo\":\n                return \"1m\";\n            case \"3mo\":\n                return \"3m\";\n            case \"6mo\":\n                return \"6m\";\n            case \"1y\":\n                return \"1y\";\n            default:\n                return \"3m\";\n        }\n    })();\n    logApi(`Standardized symbol: ${symbol}, timeframe: ${standardizedTimeframe}`, \"info\");\n    // Check cache first if not forcing refresh\n    if (!forceRefresh) {\n        const cachedData = checkCache(symbol);\n        if (cachedData) {\n            const cacheAge = Date.now() - (cachedData.timestamp || 0);\n            const isMarketHours = new Date().getHours() >= 9 && new Date().getHours() < 16;\n            const maxCacheAge = isMarketHours ? 60 * 60 * 1000 : 6 * 60 * 60 * 1000;\n            logApi(`Cache check for ${symbol}`, \"info\", {\n                cacheAge,\n                maxCacheAge,\n                isMarketHours,\n                dataPoints: cachedData.timeSeriesData?.length\n            });\n            if (cacheAge < maxCacheAge) {\n                logApi(`Using fresh cached data for ${symbol}`, \"info\");\n                return cachedData;\n            }\n        }\n    } else {\n        logApi(`Forced refresh requested for ${symbol}`, \"info\");\n    }\n    // Determine order of providers based on configuration\n    const providers = [\n        currentConfig.preferredOHLCProvider,\n        ...currentConfig.enableFallback ? [\n            currentConfig.preferredOHLCProvider.name === PROVIDERS.ALPHA_VANTAGE.name ? PROVIDERS.FINNHUB : PROVIDERS.ALPHA_VANTAGE\n        ] : []\n    ];\n    logApi(`Provider order for ${symbol}`, \"info\", {\n        providers: providers.map((p)=>p.name),\n        enableFallback: currentConfig.enableFallback\n    });\n    // Try each provider in sequence\n    let lastError = null;\n    for (const provider of providers){\n        try {\n            logApi(`Attempting to fetch data from ${provider.name}`, \"info\");\n            let result;\n            // Use retry helper for better error handling\n            if (provider.name === PROVIDERS.ALPHA_VANTAGE.name) {\n                result = await (0,_retry_helper__WEBPACK_IMPORTED_MODULE_4__.retryWhenRateLimited)(()=>getOHLCFromAlphaVantage(symbol, standardizedTimeframe), {\n                    maxRetries: 2,\n                    onRetry: (attempt, delay)=>{\n                        logApi(`Retrying Alpha Vantage for ${symbol}`, \"warn\", {\n                            attempt,\n                            delay\n                        });\n                    }\n                });\n            } else {\n                result = await (0,_retry_helper__WEBPACK_IMPORTED_MODULE_4__.retryWhenRateLimited)(()=>getOHLCFromFinnhub(symbol, standardizedTimeframe), {\n                    maxRetries: 2,\n                    onRetry: (attempt, delay)=>{\n                        logApi(`Retrying Finnhub for ${symbol}`, \"warn\", {\n                            attempt,\n                            delay\n                        });\n                    }\n                });\n            }\n            // Log successful response\n            logApi(`Successfully fetched data from ${provider.name}`, \"info\", {\n                dataPoints: result.timeSeriesData?.length,\n                firstDate: result.timeSeriesData?.[0]?.date,\n                lastDate: result.timeSeriesData?.[result.timeSeriesData.length - 1]?.date\n            });\n            // Add timestamp and forceRefresh flag to result\n            const timestampedResult = {\n                ...result,\n                timestamp: Date.now(),\n                forceRefreshed: forceRefresh,\n                provider: provider.name\n            };\n            // Save to cache if allowed\n            if (currentConfig.cacheResults && !forceRefresh) {\n                logApi(`Caching results from ${provider.name}`, \"info\");\n                saveToCache(symbol, timestampedResult);\n            }\n            return timestampedResult;\n        } catch (error) {\n            lastError = error;\n            logApi(`Provider ${provider.name} failed`, \"error\", {\n                error\n            });\n            // Check for rate limiting\n            if (typeof error === \"object\" && error !== null) {\n                const errorStr = error.toString().toLowerCase();\n                if (errorStr.includes(\"rate limit\") || errorStr.includes(\"too many requests\") || errorStr.includes(\"429\")) {\n                    logApi(`Rate limit detected for ${provider.name}`, \"warn\");\n                    (0,_cache__WEBPACK_IMPORTED_MODULE_3__.setRateLimited)(true);\n                }\n            }\n            if (!currentConfig.enableFallback) {\n                logApi(`Fallback disabled, stopping after ${provider.name} failure`, \"warn\");\n                break;\n            }\n        }\n    }\n    // All providers failed\n    logApi(\"All providers failed\", \"error\", {\n        lastError\n    });\n    // Final attempt to get from cache if not forcing refresh\n    if (!forceRefresh) {\n        const finalCacheCheck = checkCache(symbol);\n        if (finalCacheCheck) {\n            logApi(`Using cached data as final fallback for ${symbol}`, \"warn\", {\n                cacheAge: Date.now() - (finalCacheCheck.timestamp || 0),\n                dataPoints: finalCacheCheck.timeSeriesData?.length\n            });\n            return finalCacheCheck;\n        }\n    }\n    // If everything failed, throw the last error\n    throw lastError || new Error(`Failed to fetch stock data for ${symbol}`);\n}\n// ===== News API =====\n/**\n * Get news from Finnhub\n */ async function getNewsFromFinnhub(symbol, days = 30) {\n    logApi(`Fetching news for ${symbol} from Finnhub`);\n    return _request_queue__WEBPACK_IMPORTED_MODULE_2__.finnhubQueue.enqueue(async ()=>{\n        try {\n            // Calculate date range\n            const endDate = new Date();\n            const startDate = new Date();\n            startDate.setDate(startDate.getDate() - days);\n            const from = (0,_finnhub__WEBPACK_IMPORTED_MODULE_0__.formatDateYYYYMMDD)(startDate);\n            const to = (0,_finnhub__WEBPACK_IMPORTED_MODULE_0__.formatDateYYYYMMDD)(endDate);\n            const news = await (0,_finnhub__WEBPACK_IMPORTED_MODULE_0__.getCompanyNews)(symbol, from, to);\n            if (!news || !Array.isArray(news)) {\n                throw new Error(`Invalid Finnhub news response for ${symbol}`);\n            }\n            // Format the news items\n            return news.filter((item)=>item.category === \"company news\" || item.related?.includes(symbol) || item.headline?.includes(symbol)).map((item)=>({\n                    date: (0,_finnhub__WEBPACK_IMPORTED_MODULE_0__.formatDateYYYYMMDD)(new Date(item.datetime * 1000)),\n                    title: item.headline,\n                    source: item.source,\n                    url: item.url,\n                    summary: item.summary\n                })).slice(0, 10); // Limit to 10 items\n        } catch (error) {\n            logApi(`Error fetching news from Finnhub: ${error}`);\n            throw error;\n        }\n    });\n}\n/**\n * Get news from Alpha Vantage\n * Alpha Vantage has a News Sentiment API we can use as fallback\n */ async function getNewsFromAlphaVantage(symbol) {\n    logApi(`Fetching news for ${symbol} from Alpha Vantage`);\n    return _request_queue__WEBPACK_IMPORTED_MODULE_2__.alphaVantageQueue.enqueue(async ()=>{\n        try {\n            const url = `https://www.alphavantage.co/query?function=NEWS_SENTIMENT&tickers=${symbol}&apikey=${process.env.ALPHA_VANTAGE_API_KEY}`;\n            const response = await fetch(url);\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            const data = await response.json();\n            if (data.Information?.includes(\"API rate limit\")) {\n                (0,_cache__WEBPACK_IMPORTED_MODULE_3__.setRateLimited)(true);\n                throw new Error(\"Alpha Vantage API rate limit exceeded\");\n            }\n            if (!data.feed || !Array.isArray(data.feed)) {\n                throw new Error(`Invalid Alpha Vantage news response for ${symbol}`);\n            }\n            // Format the news items\n            return data.feed.slice(0, 10) // Limit to 10 items\n            .map((item)=>{\n                const time = item.time_published; // Format: YYYYMMDDTHHMMSS\n                const year = time.substring(0, 4);\n                const month = time.substring(4, 6);\n                const day = time.substring(6, 8);\n                return {\n                    date: `${year}-${month}-${day}`,\n                    title: item.title,\n                    source: item.source,\n                    url: item.url,\n                    summary: item.summary\n                };\n            });\n        } catch (error) {\n            logApi(`Error fetching news from Alpha Vantage: ${error}`);\n            throw error;\n        }\n    });\n}\n/**\n * Unified API to get news with fallback\n */ async function getCompanyNewsWithFallback(symbol, days = 30) {\n    // Standardize symbol\n    symbol = symbol.toUpperCase();\n    logApi(`Getting news for ${symbol}`);\n    // Determine order of providers based on configuration\n    const providers = [\n        currentConfig.preferredNewsProvider,\n        ...currentConfig.enableFallback ? [\n            currentConfig.preferredNewsProvider.name === PROVIDERS.FINNHUB.name ? PROVIDERS.ALPHA_VANTAGE : PROVIDERS.FINNHUB\n        ] : []\n    ];\n    // Try each provider in sequence\n    let lastError = null;\n    for (const provider of providers){\n        try {\n            let news;\n            if (provider.name === PROVIDERS.FINNHUB.name) {\n                news = await getNewsFromFinnhub(symbol, days);\n            } else {\n                news = await getNewsFromAlphaVantage(symbol);\n            }\n            // If we got here, the request succeeded\n            logApi(`Successfully fetched news from ${provider.name}`);\n            return news;\n        } catch (error) {\n            lastError = error;\n            logApi(`Provider ${provider.name} failed, ${currentConfig.enableFallback ? \"trying next provider\" : \"aborting\"}`);\n            // If fallback is disabled, break immediately\n            if (!currentConfig.enableFallback) break;\n        }\n    }\n    // All providers failed\n    logApi(\"All providers failed, returning empty news array\");\n    // For news, it's better to return an empty array than throw an error\n    return [];\n}\n// ===== Company Profile API =====\n/**\n * Get company profile from Finnhub\n */ async function getCompanyProfileFromFinnhub(symbol) {\n    logApi(`Fetching company profile for ${symbol} from Finnhub`);\n    return _request_queue__WEBPACK_IMPORTED_MODULE_2__.finnhubQueue.enqueue(async ()=>{\n        try {\n            // Import directly here to avoid circular dependencies\n            const { getCompanyProfile } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./finnhub */ \"(rsc)/./app/utils/finnhub.ts\"));\n            const profile = await getCompanyProfile(symbol);\n            if (!profile || !profile.name) {\n                throw new Error(`Invalid company profile response from Finnhub for ${symbol}`);\n            }\n            return {\n                name: profile.name,\n                description: profile.description || \"\",\n                marketCap: profile.marketCapitalization ? profile.marketCapitalization * 1000000 : 0,\n                volume: profile.shareOutstanding || 0,\n                sector: profile.sector || \"Unknown\",\n                industry: profile.industry || \"Unknown\"\n            };\n        } catch (error) {\n            logApi(`Error fetching company profile from Finnhub: ${error}`);\n            throw error;\n        }\n    });\n}\n/**\n * Get company profile from Alpha Vantage\n * Alpha Vantage has a Company Overview API we can use as fallback\n */ async function getCompanyProfileFromAlphaVantage(symbol) {\n    logApi(`Fetching company profile for ${symbol} from Alpha Vantage`);\n    return _request_queue__WEBPACK_IMPORTED_MODULE_2__.alphaVantageQueue.enqueue(async ()=>{\n        try {\n            const url = `https://www.alphavantage.co/query?function=OVERVIEW&symbol=${symbol}&apikey=${process.env.ALPHA_VANTAGE_API_KEY}`;\n            const response = await fetch(url);\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            const data = await response.json();\n            if (data.Information?.includes(\"API rate limit\")) {\n                (0,_cache__WEBPACK_IMPORTED_MODULE_3__.setRateLimited)(true);\n                throw new Error(\"Alpha Vantage API rate limit exceeded\");\n            }\n            if (!data.Name || !data.Symbol) {\n                throw new Error(`Invalid Alpha Vantage company profile response for ${symbol}`);\n            }\n            return {\n                name: data.Name,\n                description: data.Description || \"\",\n                marketCap: parseFloat(data.MarketCapitalization) || 0,\n                volume: parseFloat(data.SharesOutstanding) || 0,\n                sector: data.Sector || \"Unknown\",\n                industry: data.Industry || \"Unknown\"\n            };\n        } catch (error) {\n            logApi(`Error fetching company profile from Alpha Vantage: ${error}`);\n            throw error;\n        }\n    });\n}\n/**\n * Unified API to get company profile with fallback\n */ async function getCompanyProfileWithFallback(symbol) {\n    // Standardize symbol\n    symbol = symbol.toUpperCase();\n    logApi(`Getting company profile for ${symbol}`);\n    // Check if we're rate limited and have cached data\n    if (_cache__WEBPACK_IMPORTED_MODULE_3__.isRateLimited) {\n        logApi(\"API is rate limited, checking cache\", \"warn\");\n        const cachedData = _cache__WEBPACK_IMPORTED_MODULE_3__.companyDataCache.get(symbol);\n        if (cachedData?.companyInfo) {\n            logApi(`Using cached company profile for ${symbol} due to rate limiting`);\n            return cachedData.companyInfo;\n        }\n    }\n    // Check cache first regardless of rate limiting\n    const cachedData = _cache__WEBPACK_IMPORTED_MODULE_3__.companyDataCache.get(symbol);\n    if (cachedData?.companyInfo) {\n        const cacheAge = Date.now() - (cachedData.lastUpdated || 0);\n        const cacheAgeMinutes = Math.round(cacheAge / 60000);\n        logApi(`Found cached company profile for ${symbol} (${cacheAgeMinutes} minutes old)`);\n        // If cache is fresh (less than 30 minutes), use it\n        if (cacheAge < 1800000) {\n            logApi(`Using fresh cached company profile for ${symbol}`);\n            return cachedData.companyInfo;\n        } else {\n            logApi(`Cached company profile for ${symbol} is stale, will try to refresh`);\n        }\n    }\n    // Determine order of providers based on configuration\n    const providers = [\n        {\n            name: \"Finnhub\",\n            priority: 1\n        },\n        ...currentConfig.enableFallback ? [\n            {\n                name: \"AlphaVantage\",\n                priority: 2\n            }\n        ] : []\n    ];\n    // Try each provider in sequence\n    let lastError = null;\n    for (const provider of providers){\n        try {\n            logApi(`Attempting to fetch company profile for ${symbol} from ${provider.name}`);\n            let profile;\n            if (provider.name === \"Finnhub\") {\n                profile = await getCompanyProfileFromFinnhub(symbol);\n            } else {\n                profile = await getCompanyProfileFromAlphaVantage(symbol);\n            }\n            // If we got here, the request succeeded\n            logApi(`Successfully fetched company profile from ${provider.name}`);\n            // Save to cache\n            if (currentConfig.cacheResults) {\n                logApi(`Caching company profile for ${symbol}`);\n                _cache__WEBPACK_IMPORTED_MODULE_3__.companyDataCache.set(symbol, {\n                    name: profile.name,\n                    companyInfo: profile,\n                    lastUpdated: Date.now()\n                });\n            }\n            // Reset rate limited flag if we succeeded\n            (0,_cache__WEBPACK_IMPORTED_MODULE_3__.setRateLimited)(false);\n            return profile;\n        } catch (error) {\n            lastError = error;\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            logApi(`Provider ${provider.name} failed for ${symbol}: ${errorMessage}`, \"error\");\n            // Check if it's a rate limit error\n            if (errorMessage.toLowerCase().includes(\"rate limit\") || errorMessage.toLowerCase().includes(\"too many requests\")) {\n                logApi(`Rate limit detected for ${provider.name}`, \"warn\");\n                // Only set rate limited if we don't have more providers to try\n                if (!currentConfig.enableFallback || provider.name === \"AlphaVantage\") {\n                    (0,_cache__WEBPACK_IMPORTED_MODULE_3__.setRateLimited)(true, 3600000); // 1 hour\n                }\n            }\n            // If fallback is disabled, break immediately\n            if (!currentConfig.enableFallback) {\n                logApi(\"Fallback is disabled, aborting after first failure\", \"warn\");\n                break;\n            } else {\n                logApi(`Will try next provider for ${symbol}`);\n            }\n        }\n    }\n    // All providers failed\n    logApi(\"All providers failed, checking cache one last time\", \"warn\");\n    // Final attempt to get from cache, even if it's stale\n    const finalCacheCheck = _cache__WEBPACK_IMPORTED_MODULE_3__.companyDataCache.get(symbol);\n    if (finalCacheCheck?.companyInfo) {\n        logApi(`Using cached company profile for ${symbol} as last resort`, \"warn\");\n        return finalCacheCheck.companyInfo;\n    }\n    // If everything failed, throw the last error\n    logApi(`Failed to fetch company profile for ${symbol} from any source`, \"error\");\n    throw lastError || new Error(`Failed to fetch company profile for ${symbol}`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxJQUFJLENBQUNxQixjQUFjVixjQUFjLEVBQUU7Z0JBQ2pDYyxPQUFPLHNEQUFzRDtnQkFDN0Q7WUFDRixPQUFPO2dCQUNMQSxPQUFPLENBQUMsMkJBQTJCLEVBQUVjLE9BQU8sQ0FBQztZQUMvQztRQUNGO0lBQ0Y7SUFFQSx1QkFBdUI7SUFDdkJkLE9BQU8sc0RBQXNEO0lBRTdELHNEQUFzRDtJQUN0RCxNQUFNaUgsa0JBQWtCNUksb0RBQWdCQSxDQUFDMkMsR0FBRyxDQUFDRjtJQUM3QyxJQUFJbUcsaUJBQWlCbUQsYUFBYTtRQUNoQ3BLLE9BQU8sQ0FBQyxpQ0FBaUMsRUFBRWMsT0FBTyxlQUFlLENBQUMsRUFBRTtRQUNwRSxPQUFPbUcsZ0JBQWdCbUQsV0FBVztJQUNwQztJQUVBLDZDQUE2QztJQUM3Q3BLLE9BQU8sQ0FBQyxvQ0FBb0MsRUFBRWMsT0FBTyxnQkFBZ0IsQ0FBQyxFQUFFO0lBQ3hFLE1BQU1zRixhQUFhLElBQUkxRCxNQUFNLENBQUMsb0NBQW9DLEVBQUU1QixPQUFPLENBQUM7QUFDOUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1zdG9jay12aWRlby8uL2FwcC91dGlscy9zdG9jay1hcGkudHM/MWI2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVuaWZpZWQgU3RvY2sgQVBJIENsaWVudCB3aXRoIEZhbGxiYWNrIE1lY2hhbmlzbXNcbiAqIFxuICogVGhpcyBmaWxlIHByb3ZpZGVzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGZldGNoaW5nIHN0b2NrIGRhdGEgZnJvbSBtdWx0aXBsZSBwcm92aWRlcnMsXG4gKiB3aXRoIGF1dG9tYXRpYyBmYWxsYmFjayBiZXR3ZWVuIEZpbm5odWIgYW5kIEFscGhhIFZhbnRhZ2UuXG4gKi9cblxuaW1wb3J0IHsgZ2V0U3RvY2tDYW5kbGVzLCBnZXRDb21wYW55TmV3cywgZm9ybWF0RGF0ZVlZWVlNTUREIH0gZnJvbSAnLi9maW5uaHViJztcbmltcG9ydCB7IGdldERhaWx5VGltZVNlcmllcywgRGFpbHlEYXRhIH0gZnJvbSAnLi9hbHBoYXZhbnRhZ2UnO1xuaW1wb3J0IHsgZmlubmh1YlF1ZXVlLCBhbHBoYVZhbnRhZ2VRdWV1ZSB9IGZyb20gJy4vcmVxdWVzdC1xdWV1ZSc7XG5pbXBvcnQgeyBjb21wYW55RGF0YUNhY2hlLCBpc1JhdGVMaW1pdGVkLCBzZXRSYXRlTGltaXRlZCB9IGZyb20gJy4vY2FjaGUnO1xuaW1wb3J0IHsgcmV0cnlXaGVuUmF0ZUxpbWl0ZWQsIGlzUmF0ZUxpbWl0RXJyb3IgfSBmcm9tICcuL3JldHJ5LWhlbHBlcic7XG5cbi8vID09PT09IEludGVyZmFjZXMgPT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBOZXdzSXRlbSB7XG4gIGRhdGU6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgc291cmNlOiBzdHJpbmc7XG4gIHVybDogc3RyaW5nO1xuICBzdW1tYXJ5Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9ITENEYXRhIHtcbiAgZGF0ZTogc3RyaW5nO1xuICBvcGVuOiBudW1iZXI7XG4gIGhpZ2g6IG51bWJlcjtcbiAgbG93OiBudW1iZXI7XG4gIGNsb3NlOiBudW1iZXI7XG4gIHZvbHVtZTogbnVtYmVyO1xuICBwZXJjZW50YWdlQ2hhbmdlOiBudW1iZXI7XG4gIGRpcmVjdGlvbjogJ3VwJyB8ICdkb3duJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdG9ja0RhdGFSZXN1bHQge1xuICB0aW1lU2VyaWVzRGF0YTogT0hMQ0RhdGFbXTtcbiAgc2lnbmlmaWNhbnRNb3ZlczogT0hMQ0RhdGFbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBUElQcm92aWRlciB7XG4gIG5hbWU6IHN0cmluZztcbiAgcHJpb3JpdHk6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wYW55UHJvZmlsZSB7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgbWFya2V0Q2FwOiBudW1iZXI7XG4gIHZvbHVtZTogbnVtYmVyO1xuICBzZWN0b3I6IHN0cmluZztcbiAgaW5kdXN0cnk6IHN0cmluZztcbn1cblxuLy8gPT09PT0gQ29uZmlndXJhdGlvbiA9PT09PVxuXG5leHBvcnQgY29uc3QgUFJPVklERVJTID0ge1xuICBBTFBIQV9WQU5UQUdFOiB7IG5hbWU6ICdBbHBoYVZhbnRhZ2UnLCBwcmlvcml0eTogMSB9LFxuICBGSU5OSFVCOiB7IG5hbWU6ICdGaW5uaHViJywgcHJpb3JpdHk6IDIgfVxufSBhcyBjb25zdDtcblxuaW50ZXJmYWNlIFN0b2NrQVBJQ29uZmlnIHtcbiAgcHJlZmVycmVkT0hMQ1Byb3ZpZGVyOiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICB9O1xuICBwcmVmZXJyZWROZXdzUHJvdmlkZXI6IEFQSVByb3ZpZGVyO1xuICBlbmFibGVGYWxsYmFjazogYm9vbGVhbjtcbiAgY2FjaGVSZXN1bHRzOiBib29sZWFuO1xuICBsb2dBcGlDYWxsczogYm9vbGVhbjtcbiAgYWxwaGFWYW50YWdlQ29uZmlnOiB7XG4gICAgYXBpS2V5OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgfTtcbiAgZmlubmh1YkNvbmZpZzoge1xuICAgIGFwaUtleTogc3RyaW5nIHwgc3RyaW5nW107XG4gIH07XG59XG5cbi8vIERlZmF1bHQgY29uZmlndXJhdGlvblxuY29uc3QgZGVmYXVsdENvbmZpZzogU3RvY2tBUElDb25maWcgPSB7XG4gIHByZWZlcnJlZE9ITENQcm92aWRlcjogUFJPVklERVJTLkZJTk5IVUIsXG4gIHByZWZlcnJlZE5ld3NQcm92aWRlcjogUFJPVklERVJTLkZJTk5IVUIsXG4gIGVuYWJsZUZhbGxiYWNrOiB0cnVlLFxuICBjYWNoZVJlc3VsdHM6IHRydWUsXG4gIGxvZ0FwaUNhbGxzOiB0cnVlLFxuICBhbHBoYVZhbnRhZ2VDb25maWc6IHtcbiAgICBhcGlLZXk6IHByb2Nlc3MuZW52LkFMUEhBX1ZBTlRBR0VfQVBJX0tFWSB8fCAnJ1xuICB9LFxuICBmaW5uaHViQ29uZmlnOiB7XG4gICAgYXBpS2V5OiBwcm9jZXNzLmVudi5GSU5OSFVCX0FQSV9LRVkgfHwgJydcbiAgfVxufTtcblxuLy8gQ3VycmVudCBjb25maWd1cmF0aW9uIChtdXRhYmxlKVxubGV0IGN1cnJlbnRDb25maWc6IFN0b2NrQVBJQ29uZmlnID0geyAuLi5kZWZhdWx0Q29uZmlnIH07XG5cbi8vIENvbmZpZ3VyYXRpb24gZnVuY3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQ29uZmlnKG5ld0NvbmZpZzogUGFydGlhbDxTdG9ja0FQSUNvbmZpZz4pIHtcbiAgY3VycmVudENvbmZpZyA9IHtcbiAgICAuLi5jdXJyZW50Q29uZmlnLFxuICAgIC4uLm5ld0NvbmZpZ1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRDb25maWcoKSB7XG4gIGN1cnJlbnRDb25maWcgPSB7IC4uLmRlZmF1bHRDb25maWcgfTtcbn1cblxuLy8gVXBkYXRlIHF1ZXVlIHR5cGVzXG5pbnRlcmZhY2UgUXVldWVkRnVuY3Rpb248VD4ge1xuICAoKTogUHJvbWlzZTxUPjtcbn1cblxuaW50ZXJmYWNlIEFQSVJlcXVlc3RRdWV1ZSB7XG4gIGFkZDxUPihmbjogUXVldWVkRnVuY3Rpb248VD4pOiBQcm9taXNlPFQ+O1xuICBlbnF1ZXVlPFQ+KGZuOiBRdWV1ZWRGdW5jdGlvbjxUPik6IFByb21pc2U8VD47XG59XG5cbi8vID09PT09IFV0aWxpdHkgRnVuY3Rpb25zID09PT09XG5cbi8qKlxuICogRW5oYW5jZWQgbG9nZ2luZyBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBsb2dBcGkobWVzc2FnZTogc3RyaW5nLCBsZXZlbDogJ2luZm8nIHwgJ3dhcm4nIHwgJ2Vycm9yJyA9ICdpbmZvJywgZGV0YWlscz86IGFueSkge1xuICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIGNvbnN0IGxvZ01lc3NhZ2UgPSBgWyR7dGltZXN0YW1wfV0gJHtsZXZlbC50b1VwcGVyQ2FzZSgpfTogJHttZXNzYWdlfWA7XG4gIFxuICAvLyBMb2cgdG8gY29uc29sZSB3aXRoIGFwcHJvcHJpYXRlIGxldmVsXG4gIGlmIChsZXZlbCA9PT0gJ2Vycm9yJykge1xuICAgIGNvbnNvbGUuZXJyb3IobG9nTWVzc2FnZSk7XG4gICAgaWYgKGRldGFpbHMpIGNvbnNvbGUuZXJyb3IoJ0RldGFpbHM6JywgZGV0YWlscyk7XG4gIH0gZWxzZSBpZiAobGV2ZWwgPT09ICd3YXJuJykge1xuICAgIGNvbnNvbGUud2Fybihsb2dNZXNzYWdlKTtcbiAgICBpZiAoZGV0YWlscykgY29uc29sZS53YXJuKCdEZXRhaWxzOicsIGRldGFpbHMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKGxvZ01lc3NhZ2UpO1xuICAgIGlmIChkZXRhaWxzKSBjb25zb2xlLmxvZygnRGV0YWlsczonLCBkZXRhaWxzKTtcbiAgfVxuICBcbiAgLy8gSW4gYSBwcm9kdWN0aW9uIGVudmlyb25tZW50LCB5b3UgbWlnaHQgd2FudCB0bzpcbiAgLy8gMS4gU3RvcmUgbG9ncyBpbiBsb2NhbFN0b3JhZ2UgZm9yIGRlYnVnZ2luZ1xuICAvLyAyLiBTZW5kIGxvZ3MgdG8gYSBzZXJ2ZXJcbiAgLy8gMy4gTWFpbnRhaW4gYSByb2xsaW5nIGxvZyBidWZmZXJcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBkYXRhIGlzIGluIGNhY2hlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ2FjaGUoc3ltYm9sOiBzdHJpbmcpOiBhbnkge1xuICBpZiAoY3VycmVudENvbmZpZy5jYWNoZVJlc3VsdHMpIHtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gY29tcGFueURhdGFDYWNoZS5nZXQoc3ltYm9sKTtcbiAgICBpZiAoY2FjaGVkRGF0YT8udGltZVNlcmllc0RhdGE/Lmxlbmd0aCkge1xuICAgICAgbG9nQXBpKGBVc2luZyBjYWNoZWQgZGF0YSBmb3IgJHtzeW1ib2x9YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aW1lU2VyaWVzRGF0YTogY2FjaGVkRGF0YS50aW1lU2VyaWVzRGF0YSxcbiAgICAgICAgc2lnbmlmaWNhbnRNb3ZlczogY2FjaGVkRGF0YS5zaWduaWZpY2FudE1vdmVzIHx8IFtdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBTYXZlIGRhdGEgdG8gY2FjaGVcbiAqL1xuZnVuY3Rpb24gc2F2ZVRvQ2FjaGUoc3ltYm9sOiBzdHJpbmcsIGRhdGE6IGFueSk6IHZvaWQge1xuICBpZiAoY3VycmVudENvbmZpZy5jYWNoZVJlc3VsdHMgJiYgZGF0YSkge1xuICAgIGxvZ0FwaShgU2F2aW5nICR7c3ltYm9sfSBkYXRhIHRvIGNhY2hlYCk7XG4gICAgY29tcGFueURhdGFDYWNoZS5zZXQoc3ltYm9sLCBkYXRhKTtcbiAgfVxufVxuXG4vLyA9PT09PSBPSExDIERhdGEgQVBJID09PT09XG5cbi8vIEFkZCBBUEkga2V5IHN0YXR1cyB0cmFja2luZ1xuaW50ZXJmYWNlIEFwaUtleVN0YXR1cyB7XG4gIGtleTogc3RyaW5nO1xuICBwcm92aWRlcjogc3RyaW5nO1xuICBsYXN0VXNlZDogbnVtYmVyO1xuICBlcnJvckNvdW50OiBudW1iZXI7XG4gIHJhdGVMaW1pdGVkVW50aWw6IG51bWJlcjtcbn1cblxuLy8gVHJhY2sgQVBJIGtleSBzdGF0dXNcbmNvbnN0IGFwaUtleVN0YXR1czogeyBba2V5OiBzdHJpbmddOiBBcGlLZXlTdGF0dXMgfSA9IHt9O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIEFQSSBrZXkgaXMgY3VycmVudGx5IHJhdGUgbGltaXRlZFxuICovXG5mdW5jdGlvbiBpc0tleVJhdGVMaW1pdGVkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IHN0YXR1cyA9IGFwaUtleVN0YXR1c1trZXldO1xuICBpZiAoIXN0YXR1cykgcmV0dXJuIGZhbHNlO1xuICBcbiAgLy8gQ2hlY2sgaWYgd2UncmUgc3RpbGwgd2l0aGluIHRoZSByYXRlIGxpbWl0IHBlcmlvZFxuICBpZiAoc3RhdHVzLnJhdGVMaW1pdGVkVW50aWwgPiBEYXRlLm5vdygpKSB7XG4gICAgbG9nQXBpKGBBUEkga2V5ICR7a2V5LnNsaWNlKDAsIDgpfS4uLiBpcyByYXRlIGxpbWl0ZWQgdW50aWwgJHtuZXcgRGF0ZShzdGF0dXMucmF0ZUxpbWl0ZWRVbnRpbCkudG9JU09TdHJpbmcoKX1gLCAnd2FybicpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogTWFyayBhbiBBUEkga2V5IGFzIHJhdGUgbGltaXRlZFxuICovXG5mdW5jdGlvbiBtYXJrS2V5UmF0ZUxpbWl0ZWQoa2V5OiBzdHJpbmcsIHByb3ZpZGVyOiBzdHJpbmcsIGR1cmF0aW9uTXM6IG51bWJlciA9IDYwMDAwKSB7XG4gIGlmICghYXBpS2V5U3RhdHVzW2tleV0pIHtcbiAgICBhcGlLZXlTdGF0dXNba2V5XSA9IHtcbiAgICAgIGtleSxcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgbGFzdFVzZWQ6IERhdGUubm93KCksXG4gICAgICBlcnJvckNvdW50OiAwLFxuICAgICAgcmF0ZUxpbWl0ZWRVbnRpbDogMFxuICAgIH07XG4gIH1cbiAgXG4gIGFwaUtleVN0YXR1c1trZXldLmVycm9yQ291bnQrKztcbiAgYXBpS2V5U3RhdHVzW2tleV0ucmF0ZUxpbWl0ZWRVbnRpbCA9IERhdGUubm93KCkgKyBkdXJhdGlvbk1zO1xuICBcbiAgbG9nQXBpKGBNYXJrZWQgQVBJIGtleSAke2tleS5zbGljZSgwLCA4KX0uLi4gYXMgcmF0ZSBsaW1pdGVkIGZvciAke2R1cmF0aW9uTXMvMTAwMH1zYCwgJ3dhcm4nLCB7XG4gICAgcHJvdmlkZXIsXG4gICAgZXJyb3JDb3VudDogYXBpS2V5U3RhdHVzW2tleV0uZXJyb3JDb3VudFxuICB9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgQVBJIGtleSBzdGF0dXMgYWZ0ZXIgc3VjY2Vzc2Z1bCB1c2VcbiAqL1xuZnVuY3Rpb24gbWFya0tleVN1Y2Nlc3Moa2V5OiBzdHJpbmcsIHByb3ZpZGVyOiBzdHJpbmcpIHtcbiAgaWYgKCFhcGlLZXlTdGF0dXNba2V5XSkge1xuICAgIGFwaUtleVN0YXR1c1trZXldID0ge1xuICAgICAga2V5LFxuICAgICAgcHJvdmlkZXIsXG4gICAgICBsYXN0VXNlZDogRGF0ZS5ub3coKSxcbiAgICAgIGVycm9yQ291bnQ6IDAsXG4gICAgICByYXRlTGltaXRlZFVudGlsOiAwXG4gICAgfTtcbiAgfVxuICBcbiAgLy8gUmVzZXQgZXJyb3IgY291bnQgb24gc3VjY2Vzc1xuICBhcGlLZXlTdGF0dXNba2V5XS5lcnJvckNvdW50ID0gMDtcbiAgYXBpS2V5U3RhdHVzW2tleV0ubGFzdFVzZWQgPSBEYXRlLm5vdygpO1xuICBhcGlLZXlTdGF0dXNba2V5XS5yYXRlTGltaXRlZFVudGlsID0gMDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgYXZhaWxhYmxlIEFQSSBrZXkgZm9yIGEgcHJvdmlkZXJcbiAqL1xuZnVuY3Rpb24gZ2V0QXZhaWxhYmxlQXBpS2V5KHByb3ZpZGVyOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgY29uZmlnID0gcHJvdmlkZXIgPT09IFBST1ZJREVSUy5BTFBIQV9WQU5UQUdFLm5hbWUgPyBcbiAgICBjdXJyZW50Q29uZmlnLmFscGhhVmFudGFnZUNvbmZpZyA6IFxuICAgIGN1cnJlbnRDb25maWcuZmlubmh1YkNvbmZpZztcbiAgXG4gIC8vIElmIHdlIGhhdmUgbXVsdGlwbGUgQVBJIGtleXMsIHRyeSB0byBmaW5kIG9uZSB0aGF0J3Mgbm90IHJhdGUgbGltaXRlZFxuICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcuYXBpS2V5KSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGNvbmZpZy5hcGlLZXkpIHtcbiAgICAgIGlmICghaXNLZXlSYXRlTGltaXRlZChrZXkpKSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsOyAvLyBBbGwga2V5cyBhcmUgcmF0ZSBsaW1pdGVkXG4gIH1cbiAgXG4gIC8vIFNpbmdsZSBBUEkga2V5XG4gIHJldHVybiBpc0tleVJhdGVMaW1pdGVkKGNvbmZpZy5hcGlLZXkpID8gbnVsbCA6IGNvbmZpZy5hcGlLZXk7XG59XG5cbi8qKlxuICogRW5oYW5jZWQgZ2V0T0hMQ0Zyb21GaW5uaHViIHdpdGggQVBJIGtleSBtYW5hZ2VtZW50XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldE9ITENGcm9tRmlubmh1YihzeW1ib2w6IHN0cmluZywgdGltZWZyYW1lOiBzdHJpbmcpOiBQcm9taXNlPFN0b2NrRGF0YVJlc3VsdD4ge1xuICBjb25zdCBhcGlLZXkgPSBnZXRBdmFpbGFibGVBcGlLZXkoUFJPVklERVJTLkZJTk5IVUIubmFtZSk7XG4gIGlmICghYXBpS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbGwgRmlubmh1YiBBUEkga2V5cyBhcmUgY3VycmVudGx5IHJhdGUgbGltaXRlZCcpO1xuICB9XG4gIFxuICB0cnkge1xuICAgIC8vIE1ha2UgdGhlIEFQSSBjYWxsIHdpdGggdGhlIHNlbGVjdGVkIGtleVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpbm5odWJRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgIGxvZ0FwaShgRmV0Y2hpbmcgT0hMQyBkYXRhIGZvciAke3N5bWJvbH0gZnJvbSBGaW5uaHViYCk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBkYXRlIHJhbmdlIGJhc2VkIG9uIHRpbWVmcmFtZVxuICAgICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICBjb25zdCBvbmVEYXkgPSAyNCAqIDYwICogNjA7XG4gICAgICBsZXQgZnJvbVRpbWU6IG51bWJlcjtcbiAgICAgIGxldCByZXNvbHV0aW9uOiAnRCcgfCAnNjAnIHwgJzE1JyA9ICdEJztcbiAgICAgIFxuICAgICAgc3dpdGNoICh0aW1lZnJhbWUpIHtcbiAgICAgICAgY2FzZSAnMXcnOlxuICAgICAgICAgIGZyb21UaW1lID0gbm93IC0gKDcgKiBvbmVEYXkpO1xuICAgICAgICAgIHJlc29sdXRpb24gPSAnMTUnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcxbSc6XG4gICAgICAgICAgZnJvbVRpbWUgPSBub3cgLSAoMzAgKiBvbmVEYXkpO1xuICAgICAgICAgIHJlc29sdXRpb24gPSAnNjAnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICczbSc6XG4gICAgICAgICAgZnJvbVRpbWUgPSBub3cgLSAoOTAgKiBvbmVEYXkpO1xuICAgICAgICAgIHJlc29sdXRpb24gPSAnRCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzZtJzpcbiAgICAgICAgICBmcm9tVGltZSA9IG5vdyAtICgxODAgKiBvbmVEYXkpO1xuICAgICAgICAgIHJlc29sdXRpb24gPSAnRCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzF5JzpcbiAgICAgICAgICBmcm9tVGltZSA9IG5vdyAtICgzNjUgKiBvbmVEYXkpO1xuICAgICAgICAgIHJlc29sdXRpb24gPSAnRCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZnJvbVRpbWUgPSBub3cgLSAoOTAgKiBvbmVEYXkpO1xuICAgICAgICAgIHJlc29sdXRpb24gPSAnRCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGNhbmRsZXMgPSBhd2FpdCBnZXRTdG9ja0NhbmRsZXMoc3ltYm9sLCBmcm9tVGltZSwgbm93LCAnRCcpO1xuICAgICAgXG4gICAgICBpZiAoY2FuZGxlcy5zICE9PSAnb2snIHx8ICFjYW5kbGVzLnQgfHwgY2FuZGxlcy50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgRmlubmh1YiByZXNwb25zZSBmb3IgJHtzeW1ib2x9OiAke2NhbmRsZXMucyB8fCAnTm8gc3RhdHVzJ31gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ29udmVydCBGaW5uaHViIGZvcm1hdCB0byBvdXIgc3RhbmRhcmQgT0hMQyBmb3JtYXRcbiAgICAgIGNvbnN0IHRpbWVTZXJpZXNEYXRhOiBPSExDRGF0YVtdID0gY2FuZGxlcy50Lm1hcCgodGltZXN0YW1wLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBvcGVuID0gY2FuZGxlcy5vW2luZGV4XTtcbiAgICAgICAgY29uc3QgY2xvc2UgPSBjYW5kbGVzLmNbaW5kZXhdO1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlQ2hhbmdlID0gKChjbG9zZSAtIG9wZW4pIC8gb3BlbikgKiAxMDA7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKHRpbWVzdGFtcCAqIDEwMDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgICBvcGVuLFxuICAgICAgICAgIGhpZ2g6IGNhbmRsZXMuaFtpbmRleF0sXG4gICAgICAgICAgbG93OiBjYW5kbGVzLmxbaW5kZXhdLFxuICAgICAgICAgIGNsb3NlLFxuICAgICAgICAgIHZvbHVtZTogY2FuZGxlcy52W2luZGV4XSxcbiAgICAgICAgICBwZXJjZW50YWdlQ2hhbmdlOiBOdW1iZXIocGVyY2VudGFnZUNoYW5nZS50b0ZpeGVkKDIpKSxcbiAgICAgICAgICBkaXJlY3Rpb246IHBlcmNlbnRhZ2VDaGFuZ2UgPj0gMCA/ICd1cCcgYXMgY29uc3QgOiAnZG93bicgYXMgY29uc3RcbiAgICAgICAgfTtcbiAgICAgIH0pLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGIuZGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5kYXRlKS5nZXRUaW1lKCkpO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIHRoZSBkYXRhIHRvIGZpbmQgc2lnbmlmaWNhbnQgbW92ZXNcbiAgICAgIGNvbnN0IHNpZ25pZmljYW50TW92ZXMgPSBbXTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2Ugdm9sdW1lXG4gICAgICBjb25zdCBhdmdWb2x1bWUgPSB0aW1lU2VyaWVzRGF0YS5yZWR1Y2UoKHN1bSwgZGF5KSA9PiBzdW0gKyBkYXkudm9sdW1lLCAwKSAvIHRpbWVTZXJpZXNEYXRhLmxlbmd0aDtcbiAgICAgIFxuICAgICAgLy8gRmluZCBkYXlzIHdpdGggc2lnbmlmaWNhbnQgcHJpY2UgYW5kIHZvbHVtZSBtb3ZlbWVudFxuICAgICAgZm9yIChjb25zdCBkYXkgb2YgdGltZVNlcmllc0RhdGEpIHtcbiAgICAgICAgLy8gU2lnbmlmaWNhbnQgbW92ZSBjcml0ZXJpYTogPjIlIHByaWNlIGNoYW5nZSBBTkQgdm9sdW1lID4gMS41eCBhdmVyYWdlXG4gICAgICAgIGlmIChNYXRoLmFicyhkYXkucGVyY2VudGFnZUNoYW5nZSkgPiAyICYmIGRheS52b2x1bWUgPiBhdmdWb2x1bWUgKiAxLjUpIHtcbiAgICAgICAgICBzaWduaWZpY2FudE1vdmVzLnB1c2goZGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTb3J0IGJ5IGRhdGUgKG1vc3QgcmVjZW50IGZpcnN0KSBhbmQgbGltaXQgdG8gdG9wIDEwXG4gICAgICBzaWduaWZpY2FudE1vdmVzLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGIuZGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5kYXRlKS5nZXRUaW1lKCkpO1xuICAgICAgc2lnbmlmaWNhbnRNb3Zlcy5zcGxpY2UoMTApO1xuICAgICAgXG4gICAgICByZXR1cm4geyB0aW1lU2VyaWVzRGF0YSwgc2lnbmlmaWNhbnRNb3ZlcyB9O1xuICAgIH0pO1xuICAgIFxuICAgIC8vIE1hcmsgdGhlIGtleSBhcyBzdWNjZXNzZnVsXG4gICAgbWFya0tleVN1Y2Nlc3MoYXBpS2V5LCBQUk9WSURFUlMuRklOTkhVQi5uYW1lKTtcbiAgICBcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc1JhdGVMaW1pdEVycm9yKGVycm9yKSkge1xuICAgICAgbWFya0tleVJhdGVMaW1pdGVkKGFwaUtleSwgUFJPVklERVJTLkZJTk5IVUIubmFtZSk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogRW5oYW5jZWQgZ2V0T0hMQ0Zyb21BbHBoYVZhbnRhZ2Ugd2l0aCBBUEkga2V5IG1hbmFnZW1lbnRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0T0hMQ0Zyb21BbHBoYVZhbnRhZ2Uoc3ltYm9sOiBzdHJpbmcsIHRpbWVmcmFtZTogc3RyaW5nKTogUHJvbWlzZTxTdG9ja0RhdGFSZXN1bHQ+IHtcbiAgY29uc3QgYXBpS2V5ID0gZ2V0QXZhaWxhYmxlQXBpS2V5KFBST1ZJREVSUy5BTFBIQV9WQU5UQUdFLm5hbWUpO1xuICBpZiAoIWFwaUtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWxsIEFscGhhIFZhbnRhZ2UgQVBJIGtleXMgYXJlIGN1cnJlbnRseSByYXRlIGxpbWl0ZWQnKTtcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICAvLyBNYWtlIHRoZSBBUEkgY2FsbCB3aXRoIHRoZSBzZWxlY3RlZCBrZXlcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbHBoYVZhbnRhZ2VRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgIGxvZ0FwaShgRmV0Y2hpbmcgT0hMQyBkYXRhIGZvciAke3N5bWJvbH0gZnJvbSBBbHBoYSBWYW50YWdlIHdpdGggdGltZWZyYW1lICR7dGltZWZyYW1lfWApO1xuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IHRpbWVmcmFtZSB0byBBbHBoYSBWYW50YWdlIGZvcm1hdFxuICAgICAgY29uc3Qgb3V0cHV0c2l6ZSA9IHRpbWVmcmFtZSA9PT0gJzF3JyB8fCB0aW1lZnJhbWUgPT09ICcxbScgPyAnY29tcGFjdCcgOiAnZnVsbCc7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXREYWlseVRpbWVTZXJpZXMoc3ltYm9sLCBvdXRwdXRzaXplKTtcbiAgICAgIFxuICAgICAgLy8gRmlsdGVyIGRhdGEgYmFzZWQgb24gdGltZWZyYW1lXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3Qgb25lRGF5ID0gMjQgKiA2MCAqIDYwICogMTAwMDtcbiAgICAgIGNvbnN0IHRpbWVmcmFtZU1hcCA9IHtcbiAgICAgICAgJzF3JzogNyAqIG9uZURheSxcbiAgICAgICAgJzFtJzogMzAgKiBvbmVEYXksXG4gICAgICAgICczbSc6IDkwICogb25lRGF5LFxuICAgICAgICAnNm0nOiAxODAgKiBvbmVEYXksXG4gICAgICAgICcxeSc6IDM2NSAqIG9uZURheVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgdGltZWZyYW1lTXMgPSB0aW1lZnJhbWVNYXBbdGltZWZyYW1lXSB8fCB0aW1lZnJhbWVNYXBbJzNtJ107XG4gICAgICBjb25zdCBjdXRvZmZEYXRlID0gbmV3IERhdGUobm93IC0gdGltZWZyYW1lTXMpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgICAgIFxuICAgICAgY29uc3QgZmlsdGVyZWREYXRhID0gcmVzdWx0LmFsbERhaWx5RGF0YS5maWx0ZXIoZGF5ID0+IGRheS5kYXRlID49IGN1dG9mZkRhdGUpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgc2lnbmlmaWNhbnQgbW92ZXNcbiAgICAgIGNvbnN0IGF2Z1ZvbHVtZSA9IGZpbHRlcmVkRGF0YS5yZWR1Y2UoKHN1bSwgZGF5KSA9PiBzdW0gKyBkYXkudm9sdW1lLCAwKSAvIGZpbHRlcmVkRGF0YS5sZW5ndGg7XG4gICAgICBjb25zdCBzaWduaWZpY2FudE1vdmVzID0gW107XG4gICAgICBcbiAgICAgIC8vIEZpbmQgZGF5cyB3aXRoIHNpZ25pZmljYW50IHByaWNlIGFuZCB2b2x1bWUgbW92ZW1lbnRcbiAgICAgIGZvciAoY29uc3QgZGF5IG9mIGZpbHRlcmVkRGF0YSkge1xuICAgICAgICAvLyBTaWduaWZpY2FudCBtb3ZlIGNyaXRlcmlhOiA+MiUgcHJpY2UgY2hhbmdlIEFORCB2b2x1bWUgPiAxLjV4IGF2ZXJhZ2VcbiAgICAgICAgaWYgKE1hdGguYWJzKGRheS5wZXJjZW50YWdlQ2hhbmdlKSA+IDIgJiYgZGF5LnZvbHVtZSA+IGF2Z1ZvbHVtZSAqIDEuNSkge1xuICAgICAgICAgIHNpZ25pZmljYW50TW92ZXMucHVzaChkYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNvcnQgYnkgZGF0ZSAobW9zdCByZWNlbnQgZmlyc3QpIGFuZCBsaW1pdCB0byB0b3AgMTBcbiAgICAgIHNpZ25pZmljYW50TW92ZXMuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi5kYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmRhdGUpLmdldFRpbWUoKSk7XG4gICAgICBzaWduaWZpY2FudE1vdmVzLnNwbGljZSgxMCk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVTZXJpZXNEYXRhOiBmaWx0ZXJlZERhdGEsXG4gICAgICAgIHNpZ25pZmljYW50TW92ZXNcbiAgICAgIH07XG4gICAgfSk7XG4gICAgXG4gICAgLy8gTWFyayB0aGUga2V5IGFzIHN1Y2Nlc3NmdWxcbiAgICBtYXJrS2V5U3VjY2VzcyhhcGlLZXksIFBST1ZJREVSUy5BTFBIQV9WQU5UQUdFLm5hbWUpO1xuICAgIFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzUmF0ZUxpbWl0RXJyb3IoZXJyb3IpKSB7XG4gICAgICBtYXJrS2V5UmF0ZUxpbWl0ZWQoYXBpS2V5LCBQUk9WSURFUlMuQUxQSEFfVkFOVEFHRS5uYW1lKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBVbmlmaWVkIEFQSSB0byBnZXQgT0hMQyBkYXRhIHdpdGggZmFsbGJhY2tcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0b2NrRGF0YShcbiAgc3ltYm9sOiBzdHJpbmcsIFxuICB0aW1lZnJhbWU6IHN0cmluZyA9ICczbScsXG4gIGZvcmNlUmVmcmVzaDogYm9vbGVhbiA9IGZhbHNlXG4pOiBQcm9taXNlPFN0b2NrRGF0YVJlc3VsdD4ge1xuICBsb2dBcGkoYFN0YXJ0aW5nIGdldFN0b2NrRGF0YSBmb3IgJHtzeW1ib2x9YCwgJ2luZm8nLCB7IHRpbWVmcmFtZSwgZm9yY2VSZWZyZXNoIH0pO1xuICBcbiAgLy8gQ2hlY2sgaWYgd2UncmUgcmF0ZSBsaW1pdGVkIGFuZCBoYXZlIGNhY2hlZCBkYXRhXG4gIGlmIChpc1JhdGVMaW1pdGVkICYmICFmb3JjZVJlZnJlc2gpIHtcbiAgICBsb2dBcGkoYFJhdGUgbGltaXRlZCBjaGVjayBmb3IgJHtzeW1ib2x9YCwgJ3dhcm4nLCB7IGlzUmF0ZUxpbWl0ZWQgfSk7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IGNoZWNrQ2FjaGUoc3ltYm9sKTtcbiAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgbG9nQXBpKGBVc2luZyBjYWNoZWQgZGF0YSBmb3IgJHtzeW1ib2x9IGR1ZSB0byByYXRlIGxpbWl0aW5nYCwgJ3dhcm4nLCB7XG4gICAgICAgIGNhY2hlQWdlOiBEYXRlLm5vdygpIC0gKGNhY2hlZERhdGEudGltZXN0YW1wIHx8IDApLFxuICAgICAgICBkYXRhUG9pbnRzOiBjYWNoZWREYXRhLnRpbWVTZXJpZXNEYXRhPy5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNhY2hlZERhdGE7XG4gICAgfVxuICB9XG5cbiAgLy8gU3RhbmRhcmRpemUgc3ltYm9sIGFuZCB0aW1lZnJhbWVcbiAgc3ltYm9sID0gc3ltYm9sLnRvVXBwZXJDYXNlKCk7XG4gIGNvbnN0IHN0YW5kYXJkaXplZFRpbWVmcmFtZSA9ICgoKSA9PiB7XG4gICAgc3dpdGNoICh0aW1lZnJhbWUpIHtcbiAgICAgIGNhc2UgJzF3JzogcmV0dXJuICcxdyc7XG4gICAgICBjYXNlICcxbW8nOiByZXR1cm4gJzFtJztcbiAgICAgIGNhc2UgJzNtbyc6IHJldHVybiAnM20nO1xuICAgICAgY2FzZSAnNm1vJzogcmV0dXJuICc2bSc7XG4gICAgICBjYXNlICcxeSc6IHJldHVybiAnMXknO1xuICAgICAgZGVmYXVsdDogcmV0dXJuICczbSc7XG4gICAgfVxuICB9KSgpO1xuICBcbiAgbG9nQXBpKGBTdGFuZGFyZGl6ZWQgc3ltYm9sOiAke3N5bWJvbH0sIHRpbWVmcmFtZTogJHtzdGFuZGFyZGl6ZWRUaW1lZnJhbWV9YCwgJ2luZm8nKTtcblxuICAvLyBDaGVjayBjYWNoZSBmaXJzdCBpZiBub3QgZm9yY2luZyByZWZyZXNoXG4gIGlmICghZm9yY2VSZWZyZXNoKSB7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IGNoZWNrQ2FjaGUoc3ltYm9sKTtcbiAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgY29uc3QgY2FjaGVBZ2UgPSBEYXRlLm5vdygpIC0gKGNhY2hlZERhdGEudGltZXN0YW1wIHx8IDApO1xuICAgICAgY29uc3QgaXNNYXJrZXRIb3VycyA9IG5ldyBEYXRlKCkuZ2V0SG91cnMoKSA+PSA5ICYmIG5ldyBEYXRlKCkuZ2V0SG91cnMoKSA8IDE2O1xuICAgICAgY29uc3QgbWF4Q2FjaGVBZ2UgPSBpc01hcmtldEhvdXJzID8gNjAgKiA2MCAqIDEwMDAgOiA2ICogNjAgKiA2MCAqIDEwMDA7XG4gICAgICBcbiAgICAgIGxvZ0FwaShgQ2FjaGUgY2hlY2sgZm9yICR7c3ltYm9sfWAsICdpbmZvJywge1xuICAgICAgICBjYWNoZUFnZSxcbiAgICAgICAgbWF4Q2FjaGVBZ2UsXG4gICAgICAgIGlzTWFya2V0SG91cnMsXG4gICAgICAgIGRhdGFQb2ludHM6IGNhY2hlZERhdGEudGltZVNlcmllc0RhdGE/Lmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChjYWNoZUFnZSA8IG1heENhY2hlQWdlKSB7XG4gICAgICAgIGxvZ0FwaShgVXNpbmcgZnJlc2ggY2FjaGVkIGRhdGEgZm9yICR7c3ltYm9sfWAsICdpbmZvJyk7XG4gICAgICAgIHJldHVybiBjYWNoZWREYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsb2dBcGkoYEZvcmNlZCByZWZyZXNoIHJlcXVlc3RlZCBmb3IgJHtzeW1ib2x9YCwgJ2luZm8nKTtcbiAgfVxuXG4gIC8vIERldGVybWluZSBvcmRlciBvZiBwcm92aWRlcnMgYmFzZWQgb24gY29uZmlndXJhdGlvblxuICBjb25zdCBwcm92aWRlcnMgPSBbXG4gICAgY3VycmVudENvbmZpZy5wcmVmZXJyZWRPSExDUHJvdmlkZXIsXG4gICAgLi4uKGN1cnJlbnRDb25maWcuZW5hYmxlRmFsbGJhY2sgXG4gICAgICA/IFtjdXJyZW50Q29uZmlnLnByZWZlcnJlZE9ITENQcm92aWRlci5uYW1lID09PSBQUk9WSURFUlMuQUxQSEFfVkFOVEFHRS5uYW1lIFxuICAgICAgICAgID8gUFJPVklERVJTLkZJTk5IVUIgXG4gICAgICAgICAgOiBQUk9WSURFUlMuQUxQSEFfVkFOVEFHRV0gXG4gICAgICA6IFtdKVxuICBdO1xuICBcbiAgbG9nQXBpKGBQcm92aWRlciBvcmRlciBmb3IgJHtzeW1ib2x9YCwgJ2luZm8nLCB7IFxuICAgIHByb3ZpZGVyczogcHJvdmlkZXJzLm1hcChwID0+IHAubmFtZSksXG4gICAgZW5hYmxlRmFsbGJhY2s6IGN1cnJlbnRDb25maWcuZW5hYmxlRmFsbGJhY2tcbiAgfSk7XG4gIFxuICAvLyBUcnkgZWFjaCBwcm92aWRlciBpbiBzZXF1ZW5jZVxuICBsZXQgbGFzdEVycm9yOiBhbnkgPSBudWxsO1xuICBcbiAgZm9yIChjb25zdCBwcm92aWRlciBvZiBwcm92aWRlcnMpIHtcbiAgICB0cnkge1xuICAgICAgbG9nQXBpKGBBdHRlbXB0aW5nIHRvIGZldGNoIGRhdGEgZnJvbSAke3Byb3ZpZGVyLm5hbWV9YCwgJ2luZm8nKTtcbiAgICAgIFxuICAgICAgbGV0IHJlc3VsdDogU3RvY2tEYXRhUmVzdWx0O1xuICAgICAgXG4gICAgICAvLyBVc2UgcmV0cnkgaGVscGVyIGZvciBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcbiAgICAgIGlmIChwcm92aWRlci5uYW1lID09PSBQUk9WSURFUlMuQUxQSEFfVkFOVEFHRS5uYW1lKSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHJldHJ5V2hlblJhdGVMaW1pdGVkKFxuICAgICAgICAgICgpID0+IGdldE9ITENGcm9tQWxwaGFWYW50YWdlKHN5bWJvbCwgc3RhbmRhcmRpemVkVGltZWZyYW1lKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXhSZXRyaWVzOiAyLFxuICAgICAgICAgICAgb25SZXRyeTogKGF0dGVtcHQ6IG51bWJlciwgZGVsYXk6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICBsb2dBcGkoYFJldHJ5aW5nIEFscGhhIFZhbnRhZ2UgZm9yICR7c3ltYm9sfWAsICd3YXJuJywgeyBhdHRlbXB0LCBkZWxheSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCByZXRyeVdoZW5SYXRlTGltaXRlZChcbiAgICAgICAgICAoKSA9PiBnZXRPSExDRnJvbUZpbm5odWIoc3ltYm9sLCBzdGFuZGFyZGl6ZWRUaW1lZnJhbWUpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1heFJldHJpZXM6IDIsXG4gICAgICAgICAgICBvblJldHJ5OiAoYXR0ZW1wdDogbnVtYmVyLCBkZWxheTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgIGxvZ0FwaShgUmV0cnlpbmcgRmlubmh1YiBmb3IgJHtzeW1ib2x9YCwgJ3dhcm4nLCB7IGF0dGVtcHQsIGRlbGF5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTG9nIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcbiAgICAgIGxvZ0FwaShgU3VjY2Vzc2Z1bGx5IGZldGNoZWQgZGF0YSBmcm9tICR7cHJvdmlkZXIubmFtZX1gLCAnaW5mbycsIHtcbiAgICAgICAgZGF0YVBvaW50czogcmVzdWx0LnRpbWVTZXJpZXNEYXRhPy5sZW5ndGgsXG4gICAgICAgIGZpcnN0RGF0ZTogcmVzdWx0LnRpbWVTZXJpZXNEYXRhPy5bMF0/LmRhdGUsXG4gICAgICAgIGxhc3REYXRlOiByZXN1bHQudGltZVNlcmllc0RhdGE/LltyZXN1bHQudGltZVNlcmllc0RhdGEubGVuZ3RoIC0gMV0/LmRhdGVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBBZGQgdGltZXN0YW1wIGFuZCBmb3JjZVJlZnJlc2ggZmxhZyB0byByZXN1bHRcbiAgICAgIGNvbnN0IHRpbWVzdGFtcGVkUmVzdWx0ID0ge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgZm9yY2VSZWZyZXNoZWQ6IGZvcmNlUmVmcmVzaCxcbiAgICAgICAgcHJvdmlkZXI6IHByb3ZpZGVyLm5hbWVcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFNhdmUgdG8gY2FjaGUgaWYgYWxsb3dlZFxuICAgICAgaWYgKGN1cnJlbnRDb25maWcuY2FjaGVSZXN1bHRzICYmICFmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgbG9nQXBpKGBDYWNoaW5nIHJlc3VsdHMgZnJvbSAke3Byb3ZpZGVyLm5hbWV9YCwgJ2luZm8nKTtcbiAgICAgICAgc2F2ZVRvQ2FjaGUoc3ltYm9sLCB0aW1lc3RhbXBlZFJlc3VsdCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aW1lc3RhbXBlZFJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICBsb2dBcGkoYFByb3ZpZGVyICR7cHJvdmlkZXIubmFtZX0gZmFpbGVkYCwgJ2Vycm9yJywgeyBlcnJvciB9KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHJhdGUgbGltaXRpbmdcbiAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGVycm9yU3RyID0gZXJyb3IudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZXJyb3JTdHIuaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBcbiAgICAgICAgICBlcnJvclN0ci5pbmNsdWRlcygndG9vIG1hbnkgcmVxdWVzdHMnKSB8fFxuICAgICAgICAgIGVycm9yU3RyLmluY2x1ZGVzKCc0MjknKVxuICAgICAgICApIHtcbiAgICAgICAgICBsb2dBcGkoYFJhdGUgbGltaXQgZGV0ZWN0ZWQgZm9yICR7cHJvdmlkZXIubmFtZX1gLCAnd2FybicpO1xuICAgICAgICAgIHNldFJhdGVMaW1pdGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghY3VycmVudENvbmZpZy5lbmFibGVGYWxsYmFjaykge1xuICAgICAgICBsb2dBcGkoYEZhbGxiYWNrIGRpc2FibGVkLCBzdG9wcGluZyBhZnRlciAke3Byb3ZpZGVyLm5hbWV9IGZhaWx1cmVgLCAnd2FybicpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFsbCBwcm92aWRlcnMgZmFpbGVkXG4gIGxvZ0FwaSgnQWxsIHByb3ZpZGVycyBmYWlsZWQnLCAnZXJyb3InLCB7IGxhc3RFcnJvciB9KTtcbiAgXG4gIC8vIEZpbmFsIGF0dGVtcHQgdG8gZ2V0IGZyb20gY2FjaGUgaWYgbm90IGZvcmNpbmcgcmVmcmVzaFxuICBpZiAoIWZvcmNlUmVmcmVzaCkge1xuICAgIGNvbnN0IGZpbmFsQ2FjaGVDaGVjayA9IGNoZWNrQ2FjaGUoc3ltYm9sKTtcbiAgICBpZiAoZmluYWxDYWNoZUNoZWNrKSB7XG4gICAgICBsb2dBcGkoYFVzaW5nIGNhY2hlZCBkYXRhIGFzIGZpbmFsIGZhbGxiYWNrIGZvciAke3N5bWJvbH1gLCAnd2FybicsIHtcbiAgICAgICAgY2FjaGVBZ2U6IERhdGUubm93KCkgLSAoZmluYWxDYWNoZUNoZWNrLnRpbWVzdGFtcCB8fCAwKSxcbiAgICAgICAgZGF0YVBvaW50czogZmluYWxDYWNoZUNoZWNrLnRpbWVTZXJpZXNEYXRhPy5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZpbmFsQ2FjaGVDaGVjaztcbiAgICB9XG4gIH1cbiAgXG4gIC8vIElmIGV2ZXJ5dGhpbmcgZmFpbGVkLCB0aHJvdyB0aGUgbGFzdCBlcnJvclxuICB0aHJvdyBsYXN0RXJyb3IgfHwgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggc3RvY2sgZGF0YSBmb3IgJHtzeW1ib2x9YCk7XG59XG5cbi8vID09PT09IE5ld3MgQVBJID09PT09XG5cbi8qKlxuICogR2V0IG5ld3MgZnJvbSBGaW5uaHViXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldE5ld3NGcm9tRmlubmh1YihzeW1ib2w6IHN0cmluZywgZGF5czogbnVtYmVyID0gMzApOiBQcm9taXNlPE5ld3NJdGVtW10+IHtcbiAgbG9nQXBpKGBGZXRjaGluZyBuZXdzIGZvciAke3N5bWJvbH0gZnJvbSBGaW5uaHViYCk7XG4gIFxuICByZXR1cm4gZmlubmh1YlF1ZXVlLmVucXVldWUoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDYWxjdWxhdGUgZGF0ZSByYW5nZVxuICAgICAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgc3RhcnREYXRlLnNldERhdGUoc3RhcnREYXRlLmdldERhdGUoKSAtIGRheXMpO1xuICAgICAgXG4gICAgICBjb25zdCBmcm9tID0gZm9ybWF0RGF0ZVlZWVlNTUREKHN0YXJ0RGF0ZSk7XG4gICAgICBjb25zdCB0byA9IGZvcm1hdERhdGVZWVlZTU1ERChlbmREYXRlKTtcbiAgICAgIFxuICAgICAgY29uc3QgbmV3cyA9IGF3YWl0IGdldENvbXBhbnlOZXdzKHN5bWJvbCwgZnJvbSwgdG8pO1xuICAgICAgXG4gICAgICBpZiAoIW5ld3MgfHwgIUFycmF5LmlzQXJyYXkobmV3cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEZpbm5odWIgbmV3cyByZXNwb25zZSBmb3IgJHtzeW1ib2x9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvcm1hdCB0aGUgbmV3cyBpdGVtc1xuICAgICAgcmV0dXJuIG5ld3NcbiAgICAgICAgLmZpbHRlcihpdGVtID0+IChcbiAgICAgICAgICBpdGVtLmNhdGVnb3J5ID09PSAnY29tcGFueSBuZXdzJyB8fCBcbiAgICAgICAgICBpdGVtLnJlbGF0ZWQ/LmluY2x1ZGVzKHN5bWJvbCkgfHxcbiAgICAgICAgICBpdGVtLmhlYWRsaW5lPy5pbmNsdWRlcyhzeW1ib2wpXG4gICAgICAgICkpXG4gICAgICAgIC5tYXAoaXRlbSA9PiAoe1xuICAgICAgICAgIGRhdGU6IGZvcm1hdERhdGVZWVlZTU1ERChuZXcgRGF0ZShpdGVtLmRhdGV0aW1lICogMTAwMCkpLFxuICAgICAgICAgIHRpdGxlOiBpdGVtLmhlYWRsaW5lLFxuICAgICAgICAgIHNvdXJjZTogaXRlbS5zb3VyY2UsXG4gICAgICAgICAgdXJsOiBpdGVtLnVybCxcbiAgICAgICAgICBzdW1tYXJ5OiBpdGVtLnN1bW1hcnlcbiAgICAgICAgfSkpXG4gICAgICAgIC5zbGljZSgwLCAxMCk7IC8vIExpbWl0IHRvIDEwIGl0ZW1zXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ0FwaShgRXJyb3IgZmV0Y2hpbmcgbmV3cyBmcm9tIEZpbm5odWI6ICR7ZXJyb3J9YCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBuZXdzIGZyb20gQWxwaGEgVmFudGFnZVxuICogQWxwaGEgVmFudGFnZSBoYXMgYSBOZXdzIFNlbnRpbWVudCBBUEkgd2UgY2FuIHVzZSBhcyBmYWxsYmFja1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXROZXdzRnJvbUFscGhhVmFudGFnZShzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8TmV3c0l0ZW1bXT4ge1xuICBsb2dBcGkoYEZldGNoaW5nIG5ld3MgZm9yICR7c3ltYm9sfSBmcm9tIEFscGhhIFZhbnRhZ2VgKTtcbiAgXG4gIHJldHVybiBhbHBoYVZhbnRhZ2VRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vd3d3LmFscGhhdmFudGFnZS5jby9xdWVyeT9mdW5jdGlvbj1ORVdTX1NFTlRJTUVOVCZ0aWNrZXJzPSR7c3ltYm9sfSZhcGlrZXk9JHtwcm9jZXNzLmVudi5BTFBIQV9WQU5UQUdFX0FQSV9LRVl9YDtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGlmIChkYXRhLkluZm9ybWF0aW9uPy5pbmNsdWRlcygnQVBJIHJhdGUgbGltaXQnKSkge1xuICAgICAgICBzZXRSYXRlTGltaXRlZCh0cnVlKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHBoYSBWYW50YWdlIEFQSSByYXRlIGxpbWl0IGV4Y2VlZGVkJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghZGF0YS5mZWVkIHx8ICFBcnJheS5pc0FycmF5KGRhdGEuZmVlZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEFscGhhIFZhbnRhZ2UgbmV3cyByZXNwb25zZSBmb3IgJHtzeW1ib2x9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvcm1hdCB0aGUgbmV3cyBpdGVtc1xuICAgICAgcmV0dXJuIGRhdGEuZmVlZFxuICAgICAgICAuc2xpY2UoMCwgMTApIC8vIExpbWl0IHRvIDEwIGl0ZW1zXG4gICAgICAgIC5tYXAoKGl0ZW06IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRpbWUgPSBpdGVtLnRpbWVfcHVibGlzaGVkOyAvLyBGb3JtYXQ6IFlZWVlNTUREVEhITU1TU1xuICAgICAgICAgIGNvbnN0IHllYXIgPSB0aW1lLnN1YnN0cmluZygwLCA0KTtcbiAgICAgICAgICBjb25zdCBtb250aCA9IHRpbWUuc3Vic3RyaW5nKDQsIDYpO1xuICAgICAgICAgIGNvbnN0IGRheSA9IHRpbWUuc3Vic3RyaW5nKDYsIDgpO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRlOiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1gLFxuICAgICAgICAgICAgdGl0bGU6IGl0ZW0udGl0bGUsXG4gICAgICAgICAgICBzb3VyY2U6IGl0ZW0uc291cmNlLFxuICAgICAgICAgICAgdXJsOiBpdGVtLnVybCxcbiAgICAgICAgICAgIHN1bW1hcnk6IGl0ZW0uc3VtbWFyeVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dBcGkoYEVycm9yIGZldGNoaW5nIG5ld3MgZnJvbSBBbHBoYSBWYW50YWdlOiAke2Vycm9yfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBVbmlmaWVkIEFQSSB0byBnZXQgbmV3cyB3aXRoIGZhbGxiYWNrXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb21wYW55TmV3c1dpdGhGYWxsYmFjayhzeW1ib2w6IHN0cmluZywgZGF5czogbnVtYmVyID0gMzApOiBQcm9taXNlPE5ld3NJdGVtW10+IHtcbiAgLy8gU3RhbmRhcmRpemUgc3ltYm9sXG4gIHN5bWJvbCA9IHN5bWJvbC50b1VwcGVyQ2FzZSgpO1xuICBsb2dBcGkoYEdldHRpbmcgbmV3cyBmb3IgJHtzeW1ib2x9YCk7XG5cbiAgLy8gRGV0ZXJtaW5lIG9yZGVyIG9mIHByb3ZpZGVycyBiYXNlZCBvbiBjb25maWd1cmF0aW9uXG4gIGNvbnN0IHByb3ZpZGVycyA9IFtcbiAgICBjdXJyZW50Q29uZmlnLnByZWZlcnJlZE5ld3NQcm92aWRlcixcbiAgICAuLi4oY3VycmVudENvbmZpZy5lbmFibGVGYWxsYmFjayBcbiAgICAgID8gW2N1cnJlbnRDb25maWcucHJlZmVycmVkTmV3c1Byb3ZpZGVyLm5hbWUgPT09IFBST1ZJREVSUy5GSU5OSFVCLm5hbWUgXG4gICAgICAgICAgPyBQUk9WSURFUlMuQUxQSEFfVkFOVEFHRSBcbiAgICAgICAgICA6IFBST1ZJREVSUy5GSU5OSFVCXSBcbiAgICAgIDogW10pXG4gIF07XG5cbiAgLy8gVHJ5IGVhY2ggcHJvdmlkZXIgaW4gc2VxdWVuY2VcbiAgbGV0IGxhc3RFcnJvcjogYW55ID0gbnVsbDtcbiAgXG4gIGZvciAoY29uc3QgcHJvdmlkZXIgb2YgcHJvdmlkZXJzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBuZXdzOiBOZXdzSXRlbVtdO1xuICAgICAgXG4gICAgICBpZiAocHJvdmlkZXIubmFtZSA9PT0gUFJPVklERVJTLkZJTk5IVUIubmFtZSkge1xuICAgICAgICBuZXdzID0gYXdhaXQgZ2V0TmV3c0Zyb21GaW5uaHViKHN5bWJvbCwgZGF5cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdzID0gYXdhaXQgZ2V0TmV3c0Zyb21BbHBoYVZhbnRhZ2Uoc3ltYm9sKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIHRoZSByZXF1ZXN0IHN1Y2NlZWRlZFxuICAgICAgbG9nQXBpKGBTdWNjZXNzZnVsbHkgZmV0Y2hlZCBuZXdzIGZyb20gJHtwcm92aWRlci5uYW1lfWApO1xuICAgICAgXG4gICAgICByZXR1cm4gbmV3cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICBsb2dBcGkoYFByb3ZpZGVyICR7cHJvdmlkZXIubmFtZX0gZmFpbGVkLCAke2N1cnJlbnRDb25maWcuZW5hYmxlRmFsbGJhY2sgPyAndHJ5aW5nIG5leHQgcHJvdmlkZXInIDogJ2Fib3J0aW5nJ31gKTtcbiAgICAgIFxuICAgICAgLy8gSWYgZmFsbGJhY2sgaXMgZGlzYWJsZWQsIGJyZWFrIGltbWVkaWF0ZWx5XG4gICAgICBpZiAoIWN1cnJlbnRDb25maWcuZW5hYmxlRmFsbGJhY2spIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQWxsIHByb3ZpZGVycyBmYWlsZWRcbiAgbG9nQXBpKCdBbGwgcHJvdmlkZXJzIGZhaWxlZCwgcmV0dXJuaW5nIGVtcHR5IG5ld3MgYXJyYXknKTtcbiAgXG4gIC8vIEZvciBuZXdzLCBpdCdzIGJldHRlciB0byByZXR1cm4gYW4gZW1wdHkgYXJyYXkgdGhhbiB0aHJvdyBhbiBlcnJvclxuICByZXR1cm4gW107XG59XG5cbi8vID09PT09IENvbXBhbnkgUHJvZmlsZSBBUEkgPT09PT1cblxuLyoqXG4gKiBHZXQgY29tcGFueSBwcm9maWxlIGZyb20gRmlubmh1YlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRDb21wYW55UHJvZmlsZUZyb21GaW5uaHViKHN5bWJvbDogc3RyaW5nKTogUHJvbWlzZTxDb21wYW55UHJvZmlsZT4ge1xuICBsb2dBcGkoYEZldGNoaW5nIGNvbXBhbnkgcHJvZmlsZSBmb3IgJHtzeW1ib2x9IGZyb20gRmlubmh1YmApO1xuICBcbiAgcmV0dXJuIGZpbm5odWJRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSW1wb3J0IGRpcmVjdGx5IGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gICAgICBjb25zdCB7IGdldENvbXBhbnlQcm9maWxlIH0gPSBhd2FpdCBpbXBvcnQoJy4vZmlubmh1YicpO1xuICAgICAgY29uc3QgcHJvZmlsZSA9IGF3YWl0IGdldENvbXBhbnlQcm9maWxlKHN5bWJvbCk7XG4gICAgICBcbiAgICAgIGlmICghcHJvZmlsZSB8fCAhcHJvZmlsZS5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb21wYW55IHByb2ZpbGUgcmVzcG9uc2UgZnJvbSBGaW5uaHViIGZvciAke3N5bWJvbH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogcHJvZmlsZS5uYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbjogcHJvZmlsZS5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgbWFya2V0Q2FwOiBwcm9maWxlLm1hcmtldENhcGl0YWxpemF0aW9uID8gcHJvZmlsZS5tYXJrZXRDYXBpdGFsaXphdGlvbiAqIDEwMDAwMDAgOiAwLCAvLyBDb252ZXJ0IGZyb20gbWlsbGlvbnNcbiAgICAgICAgdm9sdW1lOiBwcm9maWxlLnNoYXJlT3V0c3RhbmRpbmcgfHwgMCxcbiAgICAgICAgc2VjdG9yOiBwcm9maWxlLnNlY3RvciB8fCAnVW5rbm93bicsXG4gICAgICAgIGluZHVzdHJ5OiBwcm9maWxlLmluZHVzdHJ5IHx8ICdVbmtub3duJ1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nQXBpKGBFcnJvciBmZXRjaGluZyBjb21wYW55IHByb2ZpbGUgZnJvbSBGaW5uaHViOiAke2Vycm9yfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgY29tcGFueSBwcm9maWxlIGZyb20gQWxwaGEgVmFudGFnZVxuICogQWxwaGEgVmFudGFnZSBoYXMgYSBDb21wYW55IE92ZXJ2aWV3IEFQSSB3ZSBjYW4gdXNlIGFzIGZhbGxiYWNrXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENvbXBhbnlQcm9maWxlRnJvbUFscGhhVmFudGFnZShzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8Q29tcGFueVByb2ZpbGU+IHtcbiAgbG9nQXBpKGBGZXRjaGluZyBjb21wYW55IHByb2ZpbGUgZm9yICR7c3ltYm9sfSBmcm9tIEFscGhhIFZhbnRhZ2VgKTtcbiAgXG4gIHJldHVybiBhbHBoYVZhbnRhZ2VRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vd3d3LmFscGhhdmFudGFnZS5jby9xdWVyeT9mdW5jdGlvbj1PVkVSVklFVyZzeW1ib2w9JHtzeW1ib2x9JmFwaWtleT0ke3Byb2Nlc3MuZW52LkFMUEhBX1ZBTlRBR0VfQVBJX0tFWX1gO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEuSW5mb3JtYXRpb24/LmluY2x1ZGVzKCdBUEkgcmF0ZSBsaW1pdCcpKSB7XG4gICAgICAgIHNldFJhdGVMaW1pdGVkKHRydWUpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FscGhhIFZhbnRhZ2UgQVBJIHJhdGUgbGltaXQgZXhjZWVkZWQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCFkYXRhLk5hbWUgfHwgIWRhdGEuU3ltYm9sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBBbHBoYSBWYW50YWdlIGNvbXBhbnkgcHJvZmlsZSByZXNwb25zZSBmb3IgJHtzeW1ib2x9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRhdGEuTmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IGRhdGEuRGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgIG1hcmtldENhcDogcGFyc2VGbG9hdChkYXRhLk1hcmtldENhcGl0YWxpemF0aW9uKSB8fCAwLFxuICAgICAgICB2b2x1bWU6IHBhcnNlRmxvYXQoZGF0YS5TaGFyZXNPdXRzdGFuZGluZykgfHwgMCxcbiAgICAgICAgc2VjdG9yOiBkYXRhLlNlY3RvciB8fCAnVW5rbm93bicsXG4gICAgICAgIGluZHVzdHJ5OiBkYXRhLkluZHVzdHJ5IHx8ICdVbmtub3duJ1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nQXBpKGBFcnJvciBmZXRjaGluZyBjb21wYW55IHByb2ZpbGUgZnJvbSBBbHBoYSBWYW50YWdlOiAke2Vycm9yfWApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBVbmlmaWVkIEFQSSB0byBnZXQgY29tcGFueSBwcm9maWxlIHdpdGggZmFsbGJhY2tcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbXBhbnlQcm9maWxlV2l0aEZhbGxiYWNrKHN5bWJvbDogc3RyaW5nKTogUHJvbWlzZTxDb21wYW55UHJvZmlsZT4ge1xuICAvLyBTdGFuZGFyZGl6ZSBzeW1ib2xcbiAgc3ltYm9sID0gc3ltYm9sLnRvVXBwZXJDYXNlKCk7XG4gIGxvZ0FwaShgR2V0dGluZyBjb21wYW55IHByb2ZpbGUgZm9yICR7c3ltYm9sfWApO1xuICBcbiAgLy8gQ2hlY2sgaWYgd2UncmUgcmF0ZSBsaW1pdGVkIGFuZCBoYXZlIGNhY2hlZCBkYXRhXG4gIGlmIChpc1JhdGVMaW1pdGVkKSB7XG4gICAgbG9nQXBpKCdBUEkgaXMgcmF0ZSBsaW1pdGVkLCBjaGVja2luZyBjYWNoZScsICd3YXJuJyk7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IGNvbXBhbnlEYXRhQ2FjaGUuZ2V0KHN5bWJvbCk7XG4gICAgaWYgKGNhY2hlZERhdGE/LmNvbXBhbnlJbmZvKSB7XG4gICAgICBsb2dBcGkoYFVzaW5nIGNhY2hlZCBjb21wYW55IHByb2ZpbGUgZm9yICR7c3ltYm9sfSBkdWUgdG8gcmF0ZSBsaW1pdGluZ2ApO1xuICAgICAgcmV0dXJuIGNhY2hlZERhdGEuY29tcGFueUluZm87XG4gICAgfVxuICB9XG4gIFxuICAvLyBDaGVjayBjYWNoZSBmaXJzdCByZWdhcmRsZXNzIG9mIHJhdGUgbGltaXRpbmdcbiAgY29uc3QgY2FjaGVkRGF0YSA9IGNvbXBhbnlEYXRhQ2FjaGUuZ2V0KHN5bWJvbCk7XG4gIGlmIChjYWNoZWREYXRhPy5jb21wYW55SW5mbykge1xuICAgIGNvbnN0IGNhY2hlQWdlID0gRGF0ZS5ub3coKSAtIChjYWNoZWREYXRhLmxhc3RVcGRhdGVkIHx8IDApO1xuICAgIGNvbnN0IGNhY2hlQWdlTWludXRlcyA9IE1hdGgucm91bmQoY2FjaGVBZ2UgLyA2MDAwMCk7XG4gICAgbG9nQXBpKGBGb3VuZCBjYWNoZWQgY29tcGFueSBwcm9maWxlIGZvciAke3N5bWJvbH0gKCR7Y2FjaGVBZ2VNaW51dGVzfSBtaW51dGVzIG9sZClgKTtcbiAgICBcbiAgICAvLyBJZiBjYWNoZSBpcyBmcmVzaCAobGVzcyB0aGFuIDMwIG1pbnV0ZXMpLCB1c2UgaXRcbiAgICBpZiAoY2FjaGVBZ2UgPCAxODAwMDAwKSB7XG4gICAgICBsb2dBcGkoYFVzaW5nIGZyZXNoIGNhY2hlZCBjb21wYW55IHByb2ZpbGUgZm9yICR7c3ltYm9sfWApO1xuICAgICAgcmV0dXJuIGNhY2hlZERhdGEuY29tcGFueUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ0FwaShgQ2FjaGVkIGNvbXBhbnkgcHJvZmlsZSBmb3IgJHtzeW1ib2x9IGlzIHN0YWxlLCB3aWxsIHRyeSB0byByZWZyZXNoYCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIG9yZGVyIG9mIHByb3ZpZGVycyBiYXNlZCBvbiBjb25maWd1cmF0aW9uXG4gIGNvbnN0IHByb3ZpZGVycyA9IFtcbiAgICB7IG5hbWU6ICdGaW5uaHViJywgcHJpb3JpdHk6IDEgfSwgLy8gRGVmYXVsdCB0byBGaW5uaHViIGZvciBjb21wYW55IGluZm9cbiAgICAuLi4oY3VycmVudENvbmZpZy5lbmFibGVGYWxsYmFjayA/IFt7IG5hbWU6ICdBbHBoYVZhbnRhZ2UnLCBwcmlvcml0eTogMiB9XSA6IFtdKVxuICBdO1xuXG4gIC8vIFRyeSBlYWNoIHByb3ZpZGVyIGluIHNlcXVlbmNlXG4gIGxldCBsYXN0RXJyb3I6IGFueSA9IG51bGw7XG4gIFxuICBmb3IgKGNvbnN0IHByb3ZpZGVyIG9mIHByb3ZpZGVycykge1xuICAgIHRyeSB7XG4gICAgICBsb2dBcGkoYEF0dGVtcHRpbmcgdG8gZmV0Y2ggY29tcGFueSBwcm9maWxlIGZvciAke3N5bWJvbH0gZnJvbSAke3Byb3ZpZGVyLm5hbWV9YCk7XG4gICAgICBcbiAgICAgIGxldCBwcm9maWxlOiBDb21wYW55UHJvZmlsZTtcbiAgICAgIFxuICAgICAgaWYgKHByb3ZpZGVyLm5hbWUgPT09ICdGaW5uaHViJykge1xuICAgICAgICBwcm9maWxlID0gYXdhaXQgZ2V0Q29tcGFueVByb2ZpbGVGcm9tRmlubmh1YihzeW1ib2wpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZmlsZSA9IGF3YWl0IGdldENvbXBhbnlQcm9maWxlRnJvbUFscGhhVmFudGFnZShzeW1ib2wpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgdGhlIHJlcXVlc3Qgc3VjY2VlZGVkXG4gICAgICBsb2dBcGkoYFN1Y2Nlc3NmdWxseSBmZXRjaGVkIGNvbXBhbnkgcHJvZmlsZSBmcm9tICR7cHJvdmlkZXIubmFtZX1gKTtcbiAgICAgIFxuICAgICAgLy8gU2F2ZSB0byBjYWNoZVxuICAgICAgaWYgKGN1cnJlbnRDb25maWcuY2FjaGVSZXN1bHRzKSB7XG4gICAgICAgIGxvZ0FwaShgQ2FjaGluZyBjb21wYW55IHByb2ZpbGUgZm9yICR7c3ltYm9sfWApO1xuICAgICAgICBjb21wYW55RGF0YUNhY2hlLnNldChzeW1ib2wsIHsgXG4gICAgICAgICAgbmFtZTogcHJvZmlsZS5uYW1lLFxuICAgICAgICAgIGNvbXBhbnlJbmZvOiBwcm9maWxlLFxuICAgICAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZXNldCByYXRlIGxpbWl0ZWQgZmxhZyBpZiB3ZSBzdWNjZWVkZWRcbiAgICAgIHNldFJhdGVMaW1pdGVkKGZhbHNlKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHByb2ZpbGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgbG9nQXBpKGBQcm92aWRlciAke3Byb3ZpZGVyLm5hbWV9IGZhaWxlZCBmb3IgJHtzeW1ib2x9OiAke2Vycm9yTWVzc2FnZX1gLCAnZXJyb3InKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHJhdGUgbGltaXQgZXJyb3JcbiAgICAgIGlmIChlcnJvck1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygncmF0ZSBsaW1pdCcpIHx8IFxuICAgICAgICAgIGVycm9yTWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd0b28gbWFueSByZXF1ZXN0cycpKSB7XG4gICAgICAgIGxvZ0FwaShgUmF0ZSBsaW1pdCBkZXRlY3RlZCBmb3IgJHtwcm92aWRlci5uYW1lfWAsICd3YXJuJyk7XG4gICAgICAgIC8vIE9ubHkgc2V0IHJhdGUgbGltaXRlZCBpZiB3ZSBkb24ndCBoYXZlIG1vcmUgcHJvdmlkZXJzIHRvIHRyeVxuICAgICAgICBpZiAoIWN1cnJlbnRDb25maWcuZW5hYmxlRmFsbGJhY2sgfHwgcHJvdmlkZXIubmFtZSA9PT0gJ0FscGhhVmFudGFnZScpIHtcbiAgICAgICAgICBzZXRSYXRlTGltaXRlZCh0cnVlLCAzNjAwMDAwKTsgLy8gMSBob3VyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgZmFsbGJhY2sgaXMgZGlzYWJsZWQsIGJyZWFrIGltbWVkaWF0ZWx5XG4gICAgICBpZiAoIWN1cnJlbnRDb25maWcuZW5hYmxlRmFsbGJhY2spIHtcbiAgICAgICAgbG9nQXBpKCdGYWxsYmFjayBpcyBkaXNhYmxlZCwgYWJvcnRpbmcgYWZ0ZXIgZmlyc3QgZmFpbHVyZScsICd3YXJuJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nQXBpKGBXaWxsIHRyeSBuZXh0IHByb3ZpZGVyIGZvciAke3N5bWJvbH1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIEFsbCBwcm92aWRlcnMgZmFpbGVkXG4gIGxvZ0FwaSgnQWxsIHByb3ZpZGVycyBmYWlsZWQsIGNoZWNraW5nIGNhY2hlIG9uZSBsYXN0IHRpbWUnLCAnd2FybicpO1xuICBcbiAgLy8gRmluYWwgYXR0ZW1wdCB0byBnZXQgZnJvbSBjYWNoZSwgZXZlbiBpZiBpdCdzIHN0YWxlXG4gIGNvbnN0IGZpbmFsQ2FjaGVDaGVjayA9IGNvbXBhbnlEYXRhQ2FjaGUuZ2V0KHN5bWJvbCk7XG4gIGlmIChmaW5hbENhY2hlQ2hlY2s/LmNvbXBhbnlJbmZvKSB7XG4gICAgbG9nQXBpKGBVc2luZyBjYWNoZWQgY29tcGFueSBwcm9maWxlIGZvciAke3N5bWJvbH0gYXMgbGFzdCByZXNvcnRgLCAnd2FybicpO1xuICAgIHJldHVybiBmaW5hbENhY2hlQ2hlY2suY29tcGFueUluZm87XG4gIH1cbiAgXG4gIC8vIElmIGV2ZXJ5dGhpbmcgZmFpbGVkLCB0aHJvdyB0aGUgbGFzdCBlcnJvclxuICBsb2dBcGkoYEZhaWxlZCB0byBmZXRjaCBjb21wYW55IHByb2ZpbGUgZm9yICR7c3ltYm9sfSBmcm9tIGFueSBzb3VyY2VgLCAnZXJyb3InKTtcbiAgdGhyb3cgbGFzdEVycm9yIHx8IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGNvbXBhbnkgcHJvZmlsZSBmb3IgJHtzeW1ib2x9YCk7XG59Il0sIm5hbWVzIjpbImdldFN0b2NrQ2FuZGxlcyIsImdldENvbXBhbnlOZXdzIiwiZm9ybWF0RGF0ZVlZWVlNTUREIiwiZ2V0RGFpbHlUaW1lU2VyaWVzIiwiZmlubmh1YlF1ZXVlIiwiYWxwaGFWYW50YWdlUXVldWUiLCJjb21wYW55RGF0YUNhY2hlIiwiaXNSYXRlTGltaXRlZCIsInNldFJhdGVMaW1pdGVkIiwicmV0cnlXaGVuUmF0ZUxpbWl0ZWQiLCJpc1JhdGVMaW1pdEVycm9yIiwiUFJPVklERVJTIiwiQUxQSEFfVkFOVEFHRSIsIm5hbWUiLCJwcmlvcml0eSIsIkZJTk5IVUIiLCJkZWZhdWx0Q29uZmlnIiwicHJlZmVycmVkT0hMQ1Byb3ZpZGVyIiwicHJlZmVycmVkTmV3c1Byb3ZpZGVyIiwiZW5hYmxlRmFsbGJhY2siLCJjYWNoZVJlc3VsdHMiLCJsb2dBcGlDYWxscyIsImFscGhhVmFudGFnZUNvbmZpZyIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJBTFBIQV9WQU5UQUdFX0FQSV9LRVkiLCJmaW5uaHViQ29uZmlnIiwiRklOTkhVQl9BUElfS0VZIiwiY3VycmVudENvbmZpZyIsInVwZGF0ZUNvbmZpZyIsIm5ld0NvbmZpZyIsInJlc2V0Q29uZmlnIiwibG9nQXBpIiwibWVzc2FnZSIsImxldmVsIiwiZGV0YWlscyIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImxvZ01lc3NhZ2UiLCJ0b1VwcGVyQ2FzZSIsImNvbnNvbGUiLCJlcnJvciIsIndhcm4iLCJsb2ciLCJjaGVja0NhY2hlIiwic3ltYm9sIiwiY2FjaGVkRGF0YSIsImdldCIsInRpbWVTZXJpZXNEYXRhIiwibGVuZ3RoIiwic2lnbmlmaWNhbnRNb3ZlcyIsInNhdmVUb0NhY2hlIiwiZGF0YSIsInNldCIsImFwaUtleVN0YXR1cyIsImlzS2V5UmF0ZUxpbWl0ZWQiLCJrZXkiLCJzdGF0dXMiLCJyYXRlTGltaXRlZFVudGlsIiwibm93Iiwic2xpY2UiLCJtYXJrS2V5UmF0ZUxpbWl0ZWQiLCJwcm92aWRlciIsImR1cmF0aW9uTXMiLCJsYXN0VXNlZCIsImVycm9yQ291bnQiLCJtYXJrS2V5U3VjY2VzcyIsImdldEF2YWlsYWJsZUFwaUtleSIsImNvbmZpZyIsIkFycmF5IiwiaXNBcnJheSIsImdldE9ITENGcm9tRmlubmh1YiIsInRpbWVmcmFtZSIsIkVycm9yIiwicmVzdWx0IiwiZW5xdWV1ZSIsIk1hdGgiLCJmbG9vciIsIm9uZURheSIsImZyb21UaW1lIiwicmVzb2x1dGlvbiIsImNhbmRsZXMiLCJzIiwidCIsIm1hcCIsImluZGV4Iiwib3BlbiIsIm8iLCJjbG9zZSIsImMiLCJwZXJjZW50YWdlQ2hhbmdlIiwiZGF0ZSIsInNwbGl0IiwiaGlnaCIsImgiLCJsb3ciLCJsIiwidm9sdW1lIiwidiIsIk51bWJlciIsInRvRml4ZWQiLCJkaXJlY3Rpb24iLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwiYXZnVm9sdW1lIiwicmVkdWNlIiwic3VtIiwiZGF5IiwiYWJzIiwicHVzaCIsInNwbGljZSIsImdldE9ITENGcm9tQWxwaGFWYW50YWdlIiwib3V0cHV0c2l6ZSIsInRpbWVmcmFtZU1hcCIsInRpbWVmcmFtZU1zIiwiY3V0b2ZmRGF0ZSIsImZpbHRlcmVkRGF0YSIsImFsbERhaWx5RGF0YSIsImZpbHRlciIsImdldFN0b2NrRGF0YSIsImZvcmNlUmVmcmVzaCIsImNhY2hlQWdlIiwiZGF0YVBvaW50cyIsInN0YW5kYXJkaXplZFRpbWVmcmFtZSIsImlzTWFya2V0SG91cnMiLCJnZXRIb3VycyIsIm1heENhY2hlQWdlIiwicHJvdmlkZXJzIiwicCIsImxhc3RFcnJvciIsIm1heFJldHJpZXMiLCJvblJldHJ5IiwiYXR0ZW1wdCIsImRlbGF5IiwiZmlyc3REYXRlIiwibGFzdERhdGUiLCJ0aW1lc3RhbXBlZFJlc3VsdCIsImZvcmNlUmVmcmVzaGVkIiwiZXJyb3JTdHIiLCJ0b1N0cmluZyIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJmaW5hbENhY2hlQ2hlY2siLCJnZXROZXdzRnJvbUZpbm5odWIiLCJkYXlzIiwiZW5kRGF0ZSIsInN0YXJ0RGF0ZSIsInNldERhdGUiLCJnZXREYXRlIiwiZnJvbSIsInRvIiwibmV3cyIsIml0ZW0iLCJjYXRlZ29yeSIsInJlbGF0ZWQiLCJoZWFkbGluZSIsImRhdGV0aW1lIiwidGl0bGUiLCJzb3VyY2UiLCJ1cmwiLCJzdW1tYXJ5IiwiZ2V0TmV3c0Zyb21BbHBoYVZhbnRhZ2UiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJqc29uIiwiSW5mb3JtYXRpb24iLCJmZWVkIiwidGltZSIsInRpbWVfcHVibGlzaGVkIiwieWVhciIsInN1YnN0cmluZyIsIm1vbnRoIiwiZ2V0Q29tcGFueU5ld3NXaXRoRmFsbGJhY2siLCJnZXRDb21wYW55UHJvZmlsZUZyb21GaW5uaHViIiwiZ2V0Q29tcGFueVByb2ZpbGUiLCJwcm9maWxlIiwiZGVzY3JpcHRpb24iLCJtYXJrZXRDYXAiLCJtYXJrZXRDYXBpdGFsaXphdGlvbiIsInNoYXJlT3V0c3RhbmRpbmciLCJzZWN0b3IiLCJpbmR1c3RyeSIsImdldENvbXBhbnlQcm9maWxlRnJvbUFscGhhVmFudGFnZSIsIk5hbWUiLCJTeW1ib2wiLCJEZXNjcmlwdGlvbiIsInBhcnNlRmxvYXQiLCJNYXJrZXRDYXBpdGFsaXphdGlvbiIsIlNoYXJlc091dHN0YW5kaW5nIiwiU2VjdG9yIiwiSW5kdXN0cnkiLCJnZXRDb21wYW55UHJvZmlsZVdpdGhGYWxsYmFjayIsImNvbXBhbnlJbmZvIiwibGFzdFVwZGF0ZWQiLCJjYWNoZUFnZU1pbnV0ZXMiLCJyb3VuZCIsImVycm9yTWVzc2FnZSIsIlN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/utils/stock-api.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvolume-analysis%2Froute&page=%2Fapi%2Fvolume-analysis%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvolume-analysis%2Froute.ts&appDir=%2FUsers%2Fstefantrasca%2FCascadeProjects%2Fai-video%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fstefantrasca%2FCascadeProjects%2Fai-video&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();